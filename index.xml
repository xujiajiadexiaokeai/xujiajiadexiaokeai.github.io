<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>xujiajiadexiaokeai</title><link>https://xujiajiadexiaokeai.github.io/</link><description>Recent content on xujiajiadexiaokeai</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2021-2022 xujiajiadexiaokeai</copyright><lastBuildDate>Thu, 20 Oct 2022 09:20:17 +0800</lastBuildDate><atom:link href="https://xujiajiadexiaokeai.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>关于离职的这一年我做了什么</title><link>https://xujiajiadexiaokeai.github.io/2022-09-20/summary/</link><pubDate>Tue, 20 Sep 2022 22:14:47 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-09-20/summary/</guid><description>关于离职的这一年我做了什么? 起子 其实这篇文章本可以叫做《未来的XX时间我要做什么》,用来指导关于技术上的学习计划. 可惜由于某些原因,我选择了离职来完成这部分学习计划. 也由于某些原因, 这部分计划的完成距我2021年8月20日离职至今已经近13个月的时间, 这大大超出了我的预期,对自己的生活也造成了一定的影响. 希望通过这篇文章对过去这13个月的时间进行总结和复盘.
我想要做什么? 补全大学时期忽略的一些理论知识, 比如操作系统原理、计算机体系结构、编译原理、计算机网络等等 重新梳理知识结构,搭建知识框架,达到以理论指导实践 搭建自己的从“输入”到“输出”的知识管理工具体系 为什么要这么做? 对自己没有清晰的认知,对生活的掌握是失控的
为什么离职? 大学时没有好好的学习基础,过于专注于业务实现 工作时感觉到困惑和恐惧 决定好好复习下基础知识 想当然,不知其所以然 这一年做了什么? 读完《DDIA》 读完《现代操作系统 原理与实现》 看了6.824 看了jyy的操作系统课 从头学了Golang 玩了PingCAP的tinyKV 写操作系统内核 写TCP协议 写编译器 写Raft算法 写Kubernetes Operator 玩Chaos Mesh 玩eBPF 剩下的任务 补全leetcode-diary.md 完成go的相关文章 完成ribbonfilter.md 完成paxos.md 写一个operator 看etcd-operator 看tidb-operator 看inference server 看nginx 看系统设计 系统调用的角度 syscall</description><content>&lt;h2 id="关于离职的这一年我做了什么">关于离职的这一年我做了什么?&lt;/h2>
&lt;h1 id="起子">起子&lt;/h1>
&lt;p>其实这篇文章本可以叫做《未来的XX时间我要做什么》,用来指导关于技术上的学习计划.
可惜由于某些原因,我选择了离职来完成这部分学习计划.
也由于某些原因, 这部分计划的完成距我2021年8月20日离职至今已经近13个月的时间,
这大大超出了我的预期,对自己的生活也造成了一定的影响.
希望通过这篇文章对过去这13个月的时间进行总结和复盘.&lt;/p>
&lt;h1 id="我想要做什么">我想要做什么?&lt;/h1>
&lt;ul>
&lt;li>补全大学时期忽略的一些理论知识, 比如操作系统原理、计算机体系结构、编译原理、计算机网络等等&lt;/li>
&lt;li>重新梳理知识结构,搭建知识框架,达到以理论指导实践&lt;/li>
&lt;li>搭建自己的从“输入”到“输出”的知识管理工具体系&lt;/li>
&lt;/ul>
&lt;h1 id="为什么要这么做">为什么要这么做?&lt;/h1>
&lt;p>对自己没有清晰的认知,对生活的掌握是失控的&lt;/p>
&lt;h1 id="为什么离职">为什么离职?&lt;/h1>
&lt;ul>
&lt;li>大学时没有好好的学习基础,过于专注于业务实现&lt;/li>
&lt;li>工作时感觉到困惑和恐惧&lt;/li>
&lt;li>决定好好复习下基础知识&lt;/li>
&lt;li>想当然,不知其所以然&lt;/li>
&lt;/ul>
&lt;h1 id="这一年做了什么">这一年做了什么?&lt;/h1>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 读完《DDIA》&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 读完《现代操作系统 原理与实现》&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 看了6.824&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 看了jyy的操作系统课&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 从头学了Golang&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 玩了PingCAP的tinyKV&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 写操作系统内核&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 写TCP协议&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 写编译器&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 写Raft算法&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 写Kubernetes Operator&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 玩Chaos Mesh&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 玩eBPF&lt;/li>
&lt;/ul>
&lt;h1 id="剩下的任务">剩下的任务&lt;/h1>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 补全leetcode-diary.md&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 完成go的相关文章&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 完成ribbonfilter.md&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 完成paxos.md&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 写一个operator&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 看etcd-operator&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 看tidb-operator&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 看inference server&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 看nginx&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 看系统设计&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 系统调用的角度 syscall&lt;/li>
&lt;/ul></content></item><item><title>什么是mTLS</title><link>https://xujiajiadexiaokeai.github.io/2022-10-20/what-is-mtls/</link><pubDate>Thu, 20 Oct 2022 09:20:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-10-20/what-is-mtls/</guid><description>无密钥SSL 这可以防止或帮助阻止在没有身份验证时可能发生的多种攻击，例如： 在途攻击 DNS 劫持 BGP 劫持 域欺骗</description><content>&lt;ul>
&lt;li>无密钥SSL&lt;/li>
&lt;/ul>
&lt;p>这可以防止或帮助阻止在没有身份验证时可能发生的多种攻击，例如：
在途攻击
DNS 劫持
BGP 劫持
域欺骗&lt;/p></content></item><item><title>Go Generic</title><link>https://xujiajiadexiaokeai.github.io/2022-10-01/go-goroutine/</link><pubDate>Sat, 01 Oct 2022 15:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-10-01/go-goroutine/</guid><description>什么是泛型 类型系统 类型内存布局 类型检查 强类型、弱类型 静态检查、动态检查 静态检查: 编译阶段 动态检查: 运行时阶段 Go的类型检查发生在编译阶段
类型推导 编译器来做类型推导
非泛型突破类型的限制 手工复制 代码生成 genny
需要一些集成的手段去使用这些库，可能让代码构建变的更复杂。 增加了编译时间。 增加了二进制包的体积。 类型断言 通过将函数中的参数类型转换为根类型(interface{}),然后对根类型进行期望的类型断言
// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; ) func MaxNumber(s []interface{}) (interface{}, error) { // HL if len(s) == 0 { return nil, errors.New(&amp;#34;no values given&amp;#34;) } switch first := s[0].(type) { // HL case int: // HL max := first for _, rawV := range s[1:] { v := rawV.</description><content>&lt;h1 id="什么是泛型">什么是泛型&lt;/h1>
&lt;h1 id="类型系统">类型系统&lt;/h1>
&lt;h2 id="类型内存布局">类型内存布局&lt;/h2>
&lt;h2 id="类型检查">类型检查&lt;/h2>
&lt;ul>
&lt;li>强类型、弱类型&lt;/li>
&lt;li>静态检查、动态检查&lt;/li>
&lt;/ul>
&lt;p>静态检查: 编译阶段
动态检查: 运行时阶段
Go的类型检查发生在编译阶段&lt;/p>
&lt;ul>
&lt;li>类型推导&lt;/li>
&lt;/ul>
&lt;p>编译器来做类型推导&lt;/p>
&lt;h2 id="非泛型突破类型的限制">非泛型突破类型的限制&lt;/h2>
&lt;h3 id="手工复制">手工复制&lt;/h3>
&lt;h3 id="代码生成">代码生成&lt;/h3>
&lt;p>&lt;a href="https://github.com/cheekybits/genny">genny&lt;/a>&lt;/p>
&lt;ul>
&lt;li>需要一些集成的手段去使用这些库，可能让代码构建变的更复杂。&lt;/li>
&lt;li>增加了编译时间。&lt;/li>
&lt;li>增加了二进制包的体积。&lt;/li>
&lt;/ul>
&lt;h3 id="类型断言">类型断言&lt;/h3>
&lt;p>通过将函数中的参数类型转换为根类型(interface{}),然后对根类型进行期望的类型断言&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;errors&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#66d9ef">error&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">s&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;no values given&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].(&lt;span style="color:#66d9ef">type&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>: &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">rawV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rawV&lt;/span>.(&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span>
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span>: &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">rawV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rawV&lt;/span>.(&lt;span style="color:#66d9ef">float64&lt;/span>) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span>
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#66d9ef">default&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unsupported element type of given slice: %T&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">first&lt;/span>)
}
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">err1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">m2&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4.1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8.1&lt;/span>, &lt;span style="color:#ae81ff">15.1&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err1&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span>) &lt;span style="color:#75715e">// &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">m2&lt;/span>) &lt;span style="color:#75715e">// 15 15.1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>调用方需要将参数包装或转换成根类型。&lt;/li>
&lt;li>实现方代码中耦合了大量的类型断言代码。&lt;/li>
&lt;li>失去了编译器的类型安全保障。&lt;/li>
&lt;/ul>
&lt;h3 id="反射">反射&lt;/h3>
&lt;p>用反射的技术在运行时获取类型信息,通过对类型的枚举判断来实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;errors&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;reflect&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#66d9ef">error&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">s&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;no values given&amp;#34;&lt;/span>)
}
&lt;span style="color:#a6e22e">first&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">CanInt&lt;/span>() {
&lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">Int&lt;/span>()
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ifV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">ifV&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">CanInt&lt;/span>() {
&lt;span style="color:#a6e22e">intV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Int&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">intV&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">intV&lt;/span>
}
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">CanFloat&lt;/span>() {
&lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">Float&lt;/span>()
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ifV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">ifV&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">CanFloat&lt;/span>() {
&lt;span style="color:#a6e22e">intV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Float&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">intV&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">intV&lt;/span>
}
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unsupported element type of given slice: %T&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">err1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">m2&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4.1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8.1&lt;/span>, &lt;span style="color:#ae81ff">15.1&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err1&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span>) &lt;span style="color:#75715e">// &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">m2&lt;/span>) &lt;span style="color:#75715e">// 15 15.1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>可读性可能不太好，因为用到了复杂的反射技术。&lt;/li>
&lt;li>会导致运行时性能差。运行时反射要比直接的代码多了很多指令操作，所以性能要慢很多。&lt;/li>
&lt;li>失去了编译器的类型安全保障。&lt;/li>
&lt;/ul>
&lt;h3 id="接口">接口&lt;/h3>
&lt;p>SOLID设计模式中的依赖倒置原则（Dependency Inversion Principle）要求软件接口在设计中应该依赖抽象而不是具体。&lt;/p>
&lt;ul>
&lt;li>可能需要定义很多数据类型。&lt;/li>
&lt;/ul>
&lt;h1 id="实现泛型">实现泛型&lt;/h1>
&lt;p>通常意义下的泛型也叫参数多态，指的是声明与定义函数、复合类型、变量时不指定其具体的类型，而把这部分类型作为参数使用，使得该定义对各种具体类型都适用。参数化多态使得语言更具表达力，同时保持了完全的静态类型安全。这被称为泛化函数、泛化数据类型、泛型变量，形成了泛型编程的基础。&lt;/p>
&lt;blockquote>
&lt;p>编程语言理论(PLT)中多态(Polymorphism)包含三个主要方面：特设多态(Ad-hoc)，参数多态(Parametric)和子类型(Subtyping)。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Ad-hoc：也叫重载(Overloading)，允许具有相同名称的函数对不同类型执行不同的操作。例如，+运算符即可以将两个整数相加，也可以连接两个字符串。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Subtyping：也叫包容性多态(Inclusion)，是指通过基类指针和引用使用派生类的能力。&lt;/p>
&lt;/blockquote>
&lt;p>子类型多态(Subtyping)是面向对象编程(OOP)中很重要的一个概念，它也称为运行时多态性，因为编译器在编译时不定位函数的地址，而是在运行时动态调用函数。这也称为动态派发(Dynamic Dispatch)。&lt;/p>
&lt;p>派发目的是让程序运行时知道被执行的函数或方法所在的内存位置。派发分为：&lt;/p>
&lt;p>静态派发(Static dispatch/early binding)：当程序在编译时可以找到执行的函数。C++默认使用的是直接派发，加上virtual修饰符可以改成虚函数表(Vtable)派发。直接派发是最快的，原因是调用指令少，还可通过编译器进行内联等方式的优化。这种派发缺点是不灵活，无法实现一些面向对象所需的技术如多态性。
动态派发(dynamic dispatch/run-time dispatch/virtual method call/late binding)：当程序在运行时可以找到执行的函数。Java默认使用的是虚函数表(Vtable)派发，通过final修饰符可改成直接派发。虚函数表派发是有动态性的，一个类里会用表来存储类成员函数的指针，子类重写(Override)父类的函数会替代父类的函数，子类添加的函数会被加到这个表里。当程序运行时派发时会从这个表中找到对应的函数，这样就可以实现动态派发。面向对象的编程语言正是靠此机制实现了多态性(Polymorphic)。
消息机制(message passing)：通过消息传递来调用被执行的函数。这种机制是在运行时可以改变函数的行为，甚至函数可以未实现，也不会引发运行时错误。比如Objective-C中就是通过消息传递来调用被执行的函数，甚至可以在程序运行过程中实现热更新代码。
以上三种派发方式都有其优劣：比如静态派发的速度是最快的，但并不灵活。而动态派发虽然比较慢，但却可以实现面向对象多态的功能。消息机制是最灵活的方式，但性能也最差。&lt;/p>
&lt;h2 id="类型擦除">类型擦除&lt;/h2>
&lt;h2 id="虚函数表">虚函数表&lt;/h2>
&lt;h2 id="字典">字典&lt;/h2>
&lt;h2 id="单态化">单态化&lt;/h2>
&lt;h2 id="模版">模版&lt;/h2>
&lt;h2 id="蜡印">蜡印&lt;/h2>
&lt;h1 id="总结">总结&lt;/h1></content></item><item><title>Chaos Mesh上手</title><link>https://xujiajiadexiaokeai.github.io/2022-09-21/consistent-hashing/</link><pubDate>Wed, 21 Sep 2022 09:20:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-09-21/consistent-hashing/</guid><description>安装kind 注意科学上网
安装chaos-mesh 测试用 install.sh 需要指定k8s&amp;amp;&amp;amp;kind版本
安装kubernetes Dashboard Kubernetes Dashboard
base dashboard@2.6.1 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml
kubectl proxy http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
create an authentication token(RBAC)
访问Chaos Mesh Dashboard https://chaos-mesh.org/zh/docs/1.2.4/user_guides/dashboard/
访问 Chaos Dashboard 的典型方法是使用kubectl port-forward：
kubectl port-forward -n chaos-mesh --address localhost,...ip svc/chaos-dashboard 2333:2333 http://localhost:2333</description><content>&lt;h1 id="安装kind">安装kind&lt;/h1>
&lt;p>注意科学上网&lt;/p>
&lt;h1 id="安装chaos-mesh">安装chaos-mesh&lt;/h1>
&lt;p>测试用 install.sh
需要指定k8s&amp;amp;&amp;amp;kind版本&lt;/p>
&lt;h1 id="安装kubernetes-dashboard">安装kubernetes Dashboard&lt;/h1>
&lt;p>&lt;a href="https://github.com/kubernetes/dashboard">Kubernetes Dashboard&lt;/a>&lt;/p>
&lt;p>base &lt;a href="mailto:dashboard@2.6.1">dashboard@2.6.1&lt;/a>
kubectl apply -f &lt;a href="https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml">https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl proxy
&lt;/code>&lt;/pre>&lt;p>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&lt;/p>
&lt;p>create an authentication token(RBAC)&lt;/p>
&lt;h1 id="访问chaos-mesh-dashboard">访问Chaos Mesh Dashboard&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://chaos-mesh.org/zh/docs/1.2.4/user_guides/dashboard/">https://chaos-mesh.org/zh/docs/1.2.4/user_guides/dashboard/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>访问 Chaos Dashboard 的典型方法是使用kubectl port-forward：&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl port-forward -n chaos-mesh --address localhost,...ip svc/chaos-dashboard 2333:2333
&lt;/code>&lt;/pre>&lt;p>http://localhost:2333&lt;/p></content></item><item><title>漏桶算法</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/leaky-bucket/</link><pubDate>Sat, 20 Aug 2022 15:32:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/leaky-bucket/</guid><description>请求如何排队 delta = 当前时间t - last last = 当前时间t + (rate - delta)
type LeakyBucket struct { rate int64 // 处理请求的速率 capacity int64 // 桶的最大容量 last time.Time // 桶中最后一个排队请求被处理的时间 mu sync.Mutex } func (t *LeakyBucket) Limit(ctx context.Context) (time.Duration, error) { t.mu.Lock() defer t.mu.Unlock() now := time.Now().UnixNano() if now &amp;lt; t.last { // 说明已经有请求在排队了,那么新请求进来排队后被处理的时间就是rate后 t.last += t.rate } else { // 桶为空 var offset int64 // 代表等待处理该请求的时间需要等待多久 delta := now - state.</description><content>&lt;h1 id="请求如何排队">请求如何排队&lt;/h1>
&lt;p>delta = 当前时间t - last
last = 当前时间t + (rate - delta)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">LeakyBucket&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">rate&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 处理请求的速率
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">capacity&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 桶的最大容量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#75715e">// 桶中最后一个排队请求被处理的时间
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">mu&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Mutex&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">LeakyBucket&lt;/span>) &lt;span style="color:#a6e22e">Limit&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>) (&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">mu&lt;/span>.&lt;span style="color:#a6e22e">Lock&lt;/span>()
&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">mu&lt;/span>.&lt;span style="color:#a6e22e">Unlock&lt;/span>()
&lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>().&lt;span style="color:#a6e22e">UnixNano&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> {
&lt;span style="color:#75715e">// 说明已经有请求在排队了,那么新请求进来排队后被处理的时间就是rate后
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span>
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#75715e">// 桶为空
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">offset&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 代表等待处理该请求的时间需要等待多久
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">Last&lt;/span> &lt;span style="color:#75715e">// 代表当前时间距离上次处理请求的时间过了多久
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span> {
&lt;span style="color:#75715e">// 说明还没有到下次处理请求的时间, 还需要等待offset后才能到
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">offset&lt;/span> = &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span>
}
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> = &lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">offset&lt;/span>
}
&lt;span style="color:#a6e22e">wait&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">wait&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">capacity&lt;/span> { &lt;span style="color:#75715e">// 桶满了, 直接丢弃请求, 返回error
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> = &lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">offset&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>(&lt;span style="color:#a6e22e">wait&lt;/span>), &lt;span style="color:#a6e22e">ErrLimitExhausted&lt;/span>
}
&lt;span style="color:#75715e">// 排队成功, 返回要等待的时间给调用者, 让调用者sleep进行阻塞就能实现按rate速率处理请求了
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>(&lt;span style="color:#a6e22e">wait&lt;/span>), &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>LeakyBucket的核心思想是按固定的速率处理请求, 不支持突增的流量
基于计数原理的实现本质上就是按固定的处理速率计算该请求能够被处理的时间以及需要等待的时间&lt;/p></content></item><item><title>令牌桶</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/token-bucket/</link><pubDate>Sat, 20 Aug 2022 15:30:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/token-bucket/</guid><description>https://zhuanlan.zhihu.com/p/442218413
基本思想 令牌桶, 通过让请求被处理前先行获取令牌, 只有获取到令牌的请求才能被放行处理
按固定速率来产生令牌存入桶中, 如果令牌数量超过桶的最大容量则直接丢掉 当有请求时先从桶中获取令牌,获取到令牌后才能进行处理, 否则被直接丢弃或者等待获取令牌 令牌桶与漏桶的区别 令牌桶与漏桶的区别在于漏桶控制的是请求被处理的速率。即当有请求的时候，先进入桶中进行排队，按固定的速率流出被处理；而令牌桶控制的是令牌产生的速率。即当有请求的时候，先从令牌桶中获取令牌，只要能获取到令牌就能立即通过被处理，不限制请求被处理的速度，所以也就可以应对一定程度的突发流量
实现 time/rate包就是基于令牌桶实现的
func main() { // 构造限流器 limiter := NewLimiter(10, 5) for i := 0; i &amp;lt; 10; i++ { time.Sleep(time.Millisecond * 20) if !limiter.Allow() { fmt.Printf(&amp;#34;%d passed\n&amp;#34;, i) continue } // 说明请求通过Allow获取到了令牌, 继续处理 // todo } } time/rate实现原理 lazyload 直到有请求消费时才根据时间查更新Token数目 通过计数原理计算当前桶中已有的Token数量 Token的生成和消耗 以固定速率产生Token func NewLimiter(r Limit, b int) *Limiter { return &amp;amp;Limiter{ limit: r, // 每秒钟可以生成Token的数量 burst: b, } } lazyload 当有请求到来时，去桶中获取令牌的同时先计算一下从上次生成令牌到现在的这段时间应该添加多少个令牌，把增量的令牌数先加到总的令牌数据上即可，后面被取走的令牌再从总数中减去即可 type Limiter struct { limit Limit // QPS 一秒钟多少个token burst int // 桶的容量 tokens float64 // 当前的token数量 last time.</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/442218413">https://zhuanlan.zhihu.com/p/442218413&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="基本思想">基本思想&lt;/h1>
&lt;p>令牌桶, 通过让请求被处理前先行获取令牌, 只有获取到令牌的请求才能被放行处理&lt;/p>
&lt;ul>
&lt;li>按固定速率来产生令牌存入桶中, 如果令牌数量超过桶的最大容量则直接丢掉&lt;/li>
&lt;li>当有请求时先从桶中获取令牌,获取到令牌后才能进行处理, 否则被直接丢弃或者等待获取令牌&lt;/li>
&lt;/ul>
&lt;h1 id="令牌桶与漏桶的区别">令牌桶与漏桶的区别&lt;/h1>
&lt;p>令牌桶与漏桶的区别在于漏桶控制的是请求被处理的速率。即当有请求的时候，先进入桶中进行排队，按固定的速率流出被处理；而令牌桶控制的是令牌产生的速率。即当有请求的时候，先从令牌桶中获取令牌，只要能获取到令牌就能立即通过被处理，不限制请求被处理的速度，所以也就可以应对一定程度的突发流量&lt;/p>
&lt;h1 id="实现">实现&lt;/h1>
&lt;p>&lt;a href="https://pkg.go.dev/golang.org/x/time/rate">time/rate&lt;/a>包就是基于令牌桶实现的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// 构造限流器
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">limiter&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewLimiter&lt;/span>(&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Sleep&lt;/span>(&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Millisecond&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">limiter&lt;/span>.&lt;span style="color:#a6e22e">Allow&lt;/span>() {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d passed\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;span style="color:#66d9ef">continue&lt;/span>
}
&lt;span style="color:#75715e">// 说明请求通过Allow获取到了令牌, 继续处理
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// todo
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="timerate实现原理">time/rate实现原理&lt;/h2>
&lt;ul>
&lt;li>lazyload&lt;/li>
&lt;li>直到有请求消费时才根据时间查更新Token数目&lt;/li>
&lt;li>通过计数原理计算当前桶中已有的Token数量&lt;/li>
&lt;/ul>
&lt;h2 id="token的生成和消耗">Token的生成和消耗&lt;/h2>
&lt;ul>
&lt;li>以&lt;strong>固定速率&lt;/strong>产生Token&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewLimiter&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#a6e22e">Limit&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Limiter&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Limiter&lt;/span>{
&lt;span style="color:#a6e22e">limit&lt;/span>: &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#75715e">// 每秒钟可以生成Token的数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">burst&lt;/span>: &lt;span style="color:#a6e22e">b&lt;/span>,
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>lazyload
当有请求到来时，去桶中获取令牌的同时先计算一下从上次生成令牌到现在的这段时间应该添加多少个令牌，把增量的令牌数先加到总的令牌数据上即可，后面被取走的令牌再从总数中减去即可&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Limiter&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">limit&lt;/span> &lt;span style="color:#a6e22e">Limit&lt;/span> &lt;span style="color:#75715e">// QPS 一秒钟多少个token
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">burst&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#75715e">// 桶的容量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span> &lt;span style="color:#75715e">// 当前的token数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#75715e">// last代表最近一次更新token的时间
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以在请求到来时:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> (&lt;span style="color:#a6e22e">当前时间t&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">最近一次更新tokens的时间last&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">时间间隔&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="如何应对突发流量">如何应对突发流量&lt;/h2>
&lt;ul>
&lt;li>令牌桶缓存令牌&lt;/li>
&lt;li>令牌桶最大容量约束&lt;/li>
&lt;/ul>
&lt;h2 id="数值溢出问题">数值溢出问题&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go"> &lt;span style="color:#75715e">// elapsed表示最后一次更新tokens数量的时间到现在的时间差
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">elapsed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Sub&lt;/span>(&lt;span style="color:#a6e22e">last&lt;/span>)
&lt;span style="color:#75715e">// delta 具有数值溢出风险， 表示elapsed这段时间应该产生的令牌数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">elapsed&lt;/span>.&lt;span style="color:#a6e22e">Seconds&lt;/span>() &lt;span style="color:#f92672">*&lt;/span> float64(&lt;span style="color:#a6e22e">limit&lt;/span>)
&lt;span style="color:#75715e">//tokens 表示当前总的令牌数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">burst&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> float64(&lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">burst&lt;/span>); &lt;span style="color:#a6e22e">tokens&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">burst&lt;/span> {
&lt;span style="color:#a6e22e">tokens&lt;/span> = &lt;span style="color:#a6e22e">burst&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以为了防止delta溢出,应该对elapsed有最大值的约束, maxElapsed是可以计算得到的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go"> &lt;span style="color:#a6e22e">maxElapsed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">limit&lt;/span>.&lt;span style="color:#a6e22e">durationFromTokens&lt;/span>(float64(&lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">burst&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">tokens&lt;/span>)
&lt;span style="color:#a6e22e">elapsed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Sub&lt;/span>(&lt;span style="color:#a6e22e">last&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">elapsed&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">maxElapsed&lt;/span> {
&lt;span style="color:#a6e22e">elapsed&lt;/span> = &lt;span style="color:#a6e22e">maxElapsed&lt;/span>
}
&lt;span style="color:#a6e22e">delta&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">limit&lt;/span>.&lt;span style="color:#a6e22e">tokensFromDuration&lt;/span>(&lt;span style="color:#a6e22e">elapsed&lt;/span>)
&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">burst&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> float64(&lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">burst&lt;/span>); &lt;span style="color:#a6e22e">tokens&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">burst&lt;/span> {
&lt;span style="color:#a6e22e">tokens&lt;/span> = &lt;span style="color:#a6e22e">burst&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">limit&lt;/span> &lt;span style="color:#a6e22e">Limit&lt;/span>) &lt;span style="color:#a6e22e">tokensFromDuration&lt;/span>(&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>) &lt;span style="color:#66d9ef">float64&lt;/span> {
&lt;span style="color:#a6e22e">sec&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> float64(&lt;span style="color:#a6e22e">d&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> float64(&lt;span style="color:#a6e22e">limit&lt;/span>)
&lt;span style="color:#a6e22e">nsec&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> float64(&lt;span style="color:#a6e22e">d&lt;/span>&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> float64(&lt;span style="color:#a6e22e">limit&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">sec&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nsec&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1e9&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>TokenBucket是以固定的速率生成令牌，让获得令牌的请求才能通过被处理。令牌桶的限流方式可以应对一定的突发流量。在实现TokenBucket时需要注意在计算令牌总数时的数值溢出问题以及精度问题。&lt;/p></content></item><item><title>限流算法</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/current-limiting-algorithm/</link><pubDate>Sat, 20 Aug 2022 15:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/current-limiting-algorithm/</guid><description>固定窗口 滑动窗口 漏斗 令牌桶</description><content>&lt;h1 id="固定窗口">固定窗口&lt;/h1>
&lt;h1 id="滑动窗口">滑动窗口&lt;/h1>
&lt;h1 id="漏斗">漏斗&lt;/h1>
&lt;h1 id="令牌桶">令牌桶&lt;/h1></content></item><item><title>一致性哈希</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/consistent-hashing/</link><pubDate>Sat, 20 Aug 2022 09:20:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/consistent-hashing/</guid><description> https://www.zsythink.net/archives/1182 问题1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。
问题2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？
优点 服务器数量发生改变, 并不是所有缓存都会失效,是部分失效 问题 哈希环倾斜, 数据分配不均 解决方案 虚拟节点 优化 如果缓存服务器间性能存在较大差异,可考虑容器化? 均匀分配数据处理能力 sample实现 https://www.cnblogs.com/luxiaoxun/p/12573742.html
Chord环 https://zhuanlan.zhihu.com/p/129049724
Napster 使用中心服务器接收所有查询 问题: 中心服务器单点失效导致整个网络瘫痪 Gnutella 使用消息洪泛(message flooding)来定位数据 使用TTL来限制网络内转发消息的数量 问题: 消息数与节点数成线性关系,网络负载较重 SN SN保存网络中节点的索引信息,有多个SN Chord算法 实现原理 资源定位 查询步骤 路由表维护</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://www.zsythink.net/archives/1182">https://www.zsythink.net/archives/1182&lt;/a>
问题1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。&lt;/p>
&lt;/blockquote>
&lt;p>问题2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？&lt;/p>
&lt;h1 id="优点">优点&lt;/h1>
&lt;ul>
&lt;li>服务器数量发生改变, 并不是所有缓存都会失效,是部分失效&lt;/li>
&lt;/ul>
&lt;h1 id="问题">问题&lt;/h1>
&lt;ul>
&lt;li>哈希环倾斜, 数据分配不均&lt;/li>
&lt;/ul>
&lt;h1 id="解决方案">解决方案&lt;/h1>
&lt;ul>
&lt;li>虚拟节点&lt;/li>
&lt;/ul>
&lt;h1 id="优化">优化&lt;/h1>
&lt;ul>
&lt;li>如果缓存服务器间性能存在较大差异,可考虑容器化? 均匀分配数据处理能力&lt;/li>
&lt;/ul>
&lt;h1 id="sample实现">sample实现&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://www.cnblogs.com/luxiaoxun/p/12573742.html">https://www.cnblogs.com/luxiaoxun/p/12573742.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="chord环">Chord环&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/129049724">https://zhuanlan.zhihu.com/p/129049724&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>Napster&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>使用中心服务器接收所有查询&lt;/li>
&lt;li>问题: 中心服务器单点失效导致整个网络瘫痪&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>Gnutella&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>使用消息洪泛(message flooding)来定位数据&lt;/li>
&lt;li>使用TTL来限制网络内转发消息的数量&lt;/li>
&lt;li>问题: 消息数与节点数成线性关系,网络负载较重&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>SN&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>SN保存网络中节点的索引信息,有多个SN&lt;/li>
&lt;/ul>
&lt;h2 id="chord算法">Chord算法&lt;/h2>
&lt;h3 id="实现原理">实现原理&lt;/h3>
&lt;h3 id="资源定位">资源定位&lt;/h3>
&lt;h3 id="查询步骤">查询步骤&lt;/h3>
&lt;h3 id="路由表维护">路由表维护&lt;/h3></content></item><item><title>算法笔记</title><link>https://xujiajiadexiaokeai.github.io/2022-08-01/algorithm-notes/</link><pubDate>Mon, 01 Aug 2022 08:14:47 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-01/algorithm-notes/</guid><description>前缀和 https://oi-wiki.org/basic/prefix-sum
数据预处理 降低时间复杂度 数列前n项的和 思路 一维 recurrence: B[0] = A[0],对于i&amp;gt;=1,则B[i] = B[i-1] + A[i] 二维/多维 容斥原理 https://zh.m.wikipedia.org/zh-hans/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86
$$\left|\bigcap_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&amp;lt;a_{i+1}}\left|\bigcap_{i=1}^mS_{a_i}\right|$$
不定方程非负整数解计数
排列组合 https://oi-wiki.org/math/combinatorics/combination/
排列数 $$\mathrm A_n^m = n(n-1)(n-2) \cdots (n-m+1) = \frac{n!}{(n-m)!}$$
组合数 $$ \mathrm C_n^m = \frac{\mathrm A_n^m}{m!} = \frac{n!}{m!(n-m)!}$$
组合数也被称为「二项式系数」,$\displaystyle \binom{n}{m}$ 读作「n选m」
$$\displaystyle \mathrm C_n^m = \binom{n}{m}$$
特别地,规定当m &amp;gt; n时, $\mathrm A_n^m = \mathrm C_n^m = 0$
单调栈</description><content>&lt;h1 id="前缀和">前缀和&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://oi-wiki.org/basic/prefix-sum">https://oi-wiki.org/basic/prefix-sum&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>数据预处理&lt;/li>
&lt;li>降低时间复杂度&lt;/li>
&lt;li>数列前n项的和&lt;/li>
&lt;/ul>
&lt;h2 id="思路">思路&lt;/h2>
&lt;h3 id="一维">一维&lt;/h3>
&lt;pre tabindex="0">&lt;code>recurrence:
B[0] = A[0],对于i&amp;gt;=1,则B[i] = B[i-1] + A[i]
&lt;/code>&lt;/pre>&lt;h3 id="二维多维">二维/多维&lt;/h3>
&lt;ul>
&lt;li>容斥原理&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;a href="https://zh.m.wikipedia.org/zh-hans/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86">https://zh.m.wikipedia.org/zh-hans/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>$$\left|\bigcap_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&amp;lt;a_{i+1}}\left|\bigcap_{i=1}^mS_{a_i}\right|$$&lt;/p>
&lt;p>不定方程非负整数解计数&lt;/p>
&lt;h1 id="排列组合">排列组合&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://oi-wiki.org/math/combinatorics/combination/">https://oi-wiki.org/math/combinatorics/combination/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="排列数">排列数&lt;/h2>
&lt;p>$$\mathrm A_n^m = n(n-1)(n-2) \cdots (n-m+1) = \frac{n!}{(n-m)!}$$&lt;/p>
&lt;h2 id="组合数">组合数&lt;/h2>
&lt;p>$$ \mathrm C_n^m = \frac{\mathrm A_n^m}{m!} = \frac{n!}{m!(n-m)!}$$&lt;/p>
&lt;p>组合数也被称为「二项式系数」,$\displaystyle \binom{n}{m}$ 读作「n选m」&lt;/p>
&lt;p>$$\displaystyle \mathrm C_n^m = \binom{n}{m}$$&lt;/p>
&lt;p>特别地,规定当m &amp;gt; n时, $\mathrm A_n^m = \mathrm C_n^m = 0$&lt;/p>
&lt;h1 id="单调栈">单调栈&lt;/h1></content></item><item><title>Goroutine</title><link>https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/</link><pubDate>Wed, 13 Jul 2022 10:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/</guid><description>基本概念 进程 进程是应用程序的启动实例 有独立的内存空间 不同进程通过进程间通信的方式进行通信 线程 线程是cpu调度的基本单位 不同线程可以共享进程的资源 不同线程通过共享内存等线程间通信方式进行通信 协程 协程调度由用户程序提供,不直接受操作系统调度 协程调度器按照调度策略把协程调度到线程中执行 协程的优势 过多的线程会导致上下文切换的开销变大,而工作在用户态的协程则能大大减少上下文切换的开销 协程调度器把可运行的协程逐个调度到线程中执行,同时及时把阻塞的协程调度出线程 有效地避免了线程的频繁切换 实现了使用少量线程实现高并发的效果
多个协程分享操作系统分给线程的时间片 协程调度器决定了协程运行的顺序 线程运行调度器指派的协程,每一时刻只能运行一个协程
调度模型 线程模型 线程可分为用户线程和内核线程 用户线程由用户创建、同步合销毁 根据用户线程管理方式的不同,分为三种线程模型: N:1模型 N个用户线程运行在1个内核线程中,上下文切换较快 1:1模型 每个用户线程对应一个内核线程,上下文切换较慢 M:N模型 充分利用cpu且上下文切换较快,但调度算法较为复杂 Go GPM模型 G: goroutine,Go协程,每个go关键字都会创建一个goroutine P: processor,处理器(Go定义的一个概念,不是指cpu),包含运行Go代码的必要资源,也有调度goroutine的能力 M: machine,工作线程,由操作系统调度 M必须持有P才能运行代码 M会被系统调用阻塞
P的个数在程序启动时决定,默认等于CPU的核数,可以使用环境变量GOMAXPROCS或在程序中使用runtime.GOMAXPROCS()方法指定P的个数
export GOMAXPROC=80 runtime.GOMAXPROCS(80) M的个数通常稍大于P的个数,因为除了运行Go代码,还有其他内置任务需要处理.
调度策略 队列轮转 每个处理器P维护着一个协程G的队列, 处理器P依次将协程G调度到M中执行 P会周期性地查看全局队列中是否有G待运行,防止“饥饿” 全局队列中的G主要来自从系统调用中恢复的G
系统调用</description><content>&lt;h1 id="基本概念">基本概念&lt;/h1>
&lt;ol>
&lt;li>进程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>进程是应用程序的启动实例&lt;/li>
&lt;li>有独立的内存空间&lt;/li>
&lt;li>不同进程通过进程间通信的方式进行通信&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>线程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>线程是cpu调度的基本单位&lt;/li>
&lt;li>不同线程可以共享进程的资源&lt;/li>
&lt;li>不同线程通过共享内存等线程间通信方式进行通信&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>协程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>协程调度由用户程序提供,不直接受操作系统调度&lt;/li>
&lt;li>协程调度器按照调度策略把协程调度到线程中执行&lt;/li>
&lt;/ul>
&lt;h1 id="协程的优势">协程的优势&lt;/h1>
&lt;p>过多的线程会导致上下文切换的开销变大,而工作在用户态的协程则能大大减少上下文切换的开销
协程调度器把可运行的协程逐个调度到线程中执行,同时及时把阻塞的协程调度出线程
有效地避免了线程的频繁切换
实现了使用少量线程实现高并发的效果&lt;/p>
&lt;p>多个协程分享操作系统分给线程的时间片
协程调度器决定了协程运行的顺序
线程运行调度器指派的协程,每一时刻只能运行一个协程&lt;/p>
&lt;h1 id="调度模型">调度模型&lt;/h1>
&lt;ol>
&lt;li>线程模型
线程可分为用户线程和内核线程
用户线程由用户创建、同步合销毁
根据用户线程管理方式的不同,分为三种线程模型:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>N:1模型
N个用户线程运行在1个内核线程中,上下文切换较快&lt;/li>
&lt;li>1:1模型
每个用户线程对应一个内核线程,上下文切换较慢&lt;/li>
&lt;li>M:N模型
充分利用cpu且上下文切换较快,但调度算法较为复杂&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>Go GPM模型
G: goroutine,Go协程,每个&lt;code>go&lt;/code>关键字都会创建一个goroutine
P: processor,处理器(Go定义的一个概念,不是指cpu),包含运行Go代码的必要资源,也有调度goroutine的能力
M: machine,工作线程,由操作系统调度&lt;/li>
&lt;/ol>
&lt;p>M必须持有P才能运行代码
M会被系统调用阻塞&lt;/p>
&lt;p>P的个数在程序启动时决定,默认等于CPU的核数,可以使用环境变量GOMAXPROCS或在程序中使用runtime.GOMAXPROCS()方法指定P的个数&lt;/p>
&lt;pre tabindex="0">&lt;code>export GOMAXPROC=80
runtime.GOMAXPROCS(80)
&lt;/code>&lt;/pre>&lt;p>M的个数通常稍大于P的个数,因为除了运行Go代码,还有其他内置任务需要处理.&lt;/p>
&lt;h1 id="调度策略">调度策略&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>队列轮转
每个处理器P维护着一个协程G的队列, 处理器P依次将协程G调度到M中执行
P会周期性地查看全局队列中是否有G待运行,防止“饥饿”
全局队列中的G主要来自从系统调用中恢复的G&lt;/p>
&lt;/li>
&lt;li>
&lt;p>系统调用&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>P的个数默认等于CPU的核数, 每个M必须持有一个P才能执行G
一般情况下M的个数略大于P,多出来的M将会在G产生系统调用时发挥作用&lt;/p>
&lt;p>M池
当M运行的某个G产生系统调用时: // TODO&lt;/p>
&lt;ol start="3">
&lt;li>工作量窃取
通过&lt;code>go&lt;/code>关键字创建的协程通常会优先放到当前协程对应的多处理器队列中
可能有些协程自身会不断派生新协程,有些协程不会派生,导致多个P中维护的G队列是不均衡的&lt;/li>
&lt;/ol>
&lt;p>所以Go调度器提供了工作量窃取策略: 当某个P没有需要调度的协程时, 将从其他处理器中偷取协程&lt;/p>
&lt;p>发生窃取前,会查询全局队列,如果全局队列中没有需要调度的协程,才会从其他P中偷取,一次偷一半&lt;/p>
&lt;ol start="4">
&lt;li>抢占式调度
避免某个协程长时间执行,而阻碍其他协程被调度的机制&lt;/li>
&lt;/ol>
&lt;p>调度器会监控每个协程的执行时间, 一旦执行时间过程且有其他协程在等待时,会把当前协程暂停,转而调度等待的协程,类似&lt;code>时间片轮转&lt;/code>&lt;/p></content></item><item><title>Go Memory</title><link>https://xujiajiadexiaokeai.github.io/2022-07-13/go-memory/</link><pubDate>Wed, 13 Jul 2022 08:15:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-13/go-memory/</guid><description>内存分配 内存分配过程 针对待分配对象大小的不同有不同的分配逻辑:
(0, 16B)且不包含指针的对象: Tiny分配 (0, 16B)且包含指针的对象: 正常分配 [16B, 32KB] : 正常分配 (32KB, ∞): 大对象分配 以申请size为n的内存为例,分配步骤如下:
获取当前线程的私有缓存mcache 根据size计算出适合的class的ID 从mcache的alloc[class]链表中查询可用的span 如果macache没有可用的span, 则从mcentral申请一个新的span加入mcache 如果mcentral中也没有可用的span, 则从mheap中申请一个新的span加入mcentral 从该span中获取空闲对象地址并返回 小结 Go程序启动时申请一大块内存, 并划分成span、bitmap、arena区域 arena区域按页划分成一个个小块 span管理一个或多个页 mcentral管理多个span供线程申请使用 mcache作为线程私有资源, 资源来源于mcentral 垃圾回收 常见垃圾回收算法 引用计数 对每个对象维护一个引用计数, 当引用改对象的对象被销毁时,引用计数减1, 当引用计数器为0时回收改对象 优点: 对象可以很快被回收,不会出现内存耗尽或达到某个阈值时才回收 缺点: 不能很好地处理循环引用, 而且实时维护引用计数也有一定代价
标记-清除 从根变量开始遍历所有引用对象, 引用的对象标记为“被引用”, 没有标记的对象被回收 优点: 解决了引用计数的缺点 缺点: 需要”Stop The World“
分代收集 按照对象生命周期的长短划分不同的代空间, 生命周期长的放入老生代, 短的放入新生代, 不同代有不同的回收算法和回收频率 优点: 回收性能好 缺点: 算法复杂</description><content>&lt;h1 id="内存分配">内存分配&lt;/h1>
&lt;h2 id="内存分配过程">内存分配过程&lt;/h2>
&lt;p>针对待分配对象大小的不同有不同的分配逻辑:&lt;/p>
&lt;ul>
&lt;li>(0, 16B)且不包含指针的对象: Tiny分配&lt;/li>
&lt;li>(0, 16B)且包含指针的对象: 正常分配&lt;/li>
&lt;li>[16B, 32KB] : 正常分配&lt;/li>
&lt;li>(32KB, ∞): 大对象分配&lt;/li>
&lt;/ul>
&lt;p>以申请size为n的内存为例,分配步骤如下:&lt;/p>
&lt;ol>
&lt;li>获取当前线程的私有缓存mcache&lt;/li>
&lt;li>根据size计算出适合的class的ID&lt;/li>
&lt;li>从mcache的alloc[class]链表中查询可用的span&lt;/li>
&lt;li>如果macache没有可用的span, 则从mcentral申请一个新的span加入mcache&lt;/li>
&lt;li>如果mcentral中也没有可用的span, 则从mheap中申请一个新的span加入mcentral&lt;/li>
&lt;li>从该span中获取空闲对象地址并返回&lt;/li>
&lt;/ol>
&lt;h2 id="小结">小结&lt;/h2>
&lt;ul>
&lt;li>Go程序启动时申请一大块内存, 并划分成span、bitmap、arena区域&lt;/li>
&lt;li>arena区域按页划分成一个个小块&lt;/li>
&lt;li>span管理一个或多个页&lt;/li>
&lt;li>mcentral管理多个span供线程申请使用&lt;/li>
&lt;li>mcache作为线程私有资源, 资源来源于mcentral&lt;/li>
&lt;/ul>
&lt;h1 id="垃圾回收">垃圾回收&lt;/h1>
&lt;h2 id="常见垃圾回收算法">常见垃圾回收算法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>引用计数
对每个对象维护一个引用计数, 当引用改对象的对象被销毁时,引用计数减1, 当引用计数器为0时回收改对象
优点: 对象可以很快被回收,不会出现内存耗尽或达到某个阈值时才回收
缺点: 不能很好地处理循环引用, 而且实时维护引用计数也有一定代价&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标记-清除
从根变量开始遍历所有引用对象, 引用的对象标记为“被引用”, 没有标记的对象被回收
优点: 解决了引用计数的缺点
缺点: 需要”Stop The World“&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分代收集
按照对象生命周期的长短划分不同的代空间, 生命周期长的放入老生代, 短的放入新生代, 不同代有不同的回收算法和回收频率
优点: 回收性能好
缺点: 算法复杂&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="go垃圾回收">Go垃圾回收&lt;/h2>
&lt;h3 id="标记-清除算法原理">“标记-清除”算法原理&lt;/h3>
&lt;h3 id="内存标记">内存标记&lt;/h3>
&lt;p>在&lt;code>mspan&lt;/code>的数据结构中, bitmap&lt;code>allocBits&lt;/code>表示每个内存块的使用情况, bitmap&lt;code>gcmarkBits&lt;/code>用于标记内存块被引用的情况
在标记阶段对每块内存进行标记, 有对象引用的内存标记为1,没有引用的保持为0(default)
&lt;code>allocBits&lt;/code>和&lt;code>gcmarkBits&lt;/code>的数据结构完全一样, 标记结束后进行内存回收, 回收时将allocBits指向gcmarkBits, 代表标记过的内存才是存活的, gcmarkBits会在下次标记时重新分配内存&lt;/p>
&lt;h3 id="三色标记法">三色标记法&lt;/h3>
&lt;p>三色主要是为了对应gc过程中对象的三种状态:&lt;/p>
&lt;ul>
&lt;li>灰色: 对象还在标记队列中等待&lt;/li>
&lt;li>黑色: 对象已被标记, gcmarkBits对应的位为1(本次不会被清理)&lt;/li>
&lt;li>白色: 对象未被标记, gcmarkBits对应的位为0(本次会被清理)&lt;/li>
&lt;/ul>
&lt;h3 id="stop-the-world">Stop The World&lt;/h3>
&lt;p>在gc过程中, 需要控制内存的变化, 否则在回收过程中指针传递会引起内存引用关系变化
STW时间的长短直接影响了应用的执行&lt;/p>
&lt;h2 id="垃圾回收优化">垃圾回收优化&lt;/h2>
&lt;h3 id="写屏障write-barrier">写屏障(Write Barrier)&lt;/h3>
&lt;p>STW的目的是防止GC扫描时内存变化而停止goroutine, 而写屏障就是让goroutine与GC同时运行的手段.
虽然写屏障不能完全消除STW,但是可以大大缩短STW的时间&lt;/p>
&lt;h3 id="辅助gcmutator-assist">辅助GC(Mutator Assist)&lt;/h3>
&lt;p>在GC过程中, 如果goroutine需要分配内存, 那么改goroutine会参与以部分GC的工作&lt;/p>
&lt;h2 id="gc的触发时机">GC的触发时机&lt;/h2>
&lt;ol>
&lt;li>内存分配量达到阈值触发GC&lt;/li>
&lt;li>定期触发GC&lt;/li>
&lt;li>手动触发&lt;/li>
&lt;/ol>
&lt;h2 id="gc性能优化">GC性能优化&lt;/h2>
&lt;p>GC性能与对象数量负相关&lt;/p>
&lt;ul>
&lt;li>减少对象分配: 对象复用或使用大对象组合多个小对象&lt;/li>
&lt;li>内存逃逸也会加重GC负担&lt;/li>
&lt;/ul>
&lt;h1 id="逃逸分析">逃逸分析&lt;/h1>
&lt;p>逃逸分析(escape analysis)是指编译器决定内存分配的位置, 不需要程序员指定
在函数中申请一个新的对象:&lt;/p>
&lt;ul>
&lt;li>如果分配在栈中, 则函数执行结束后可自动将内存回收&lt;/li>
&lt;li>如果分配在堆中, 则函数执行结束后可交给GC处理&lt;/li>
&lt;/ul>
&lt;h2 id="逃逸策略">逃逸策略&lt;/h2>
&lt;p>在函数中申请一个闲的对象, 编译器会根据该对象是否被函数外部引用来决定是否逃逸:&lt;/p>
&lt;ul>
&lt;li>如果函数外部没有引用, 则优先放入栈中&lt;/li>
&lt;li>如果函数外部存在引用, 则优先放入堆中&lt;/li>
&lt;li>对于仅在函数内部使用的对象, 也有可能放到堆中, 比如内存过大超过栈的大小&lt;/li>
&lt;/ul>
&lt;h2 id="逃逸场景">逃逸场景&lt;/h2>
&lt;ol>
&lt;li>指针逃逸
Go返回了局部变量的指针&lt;/li>
&lt;li>栈空间不足
当栈空间不足以存放当前对象或无法判断当前切片长度时会将对象分配到堆中&lt;/li>
&lt;li>动态类型逃逸
如果函数中使用了动态类型参数, 编译期间很难确定参数类型, 也会产生逃逸&lt;/li>
&lt;li>闭包引用对象逃逸
闭包中的局部对象由于闭包的引用, 产生逃逸&lt;/li>
&lt;/ol>
&lt;h2 id="小结-1">小结&lt;/h2>
&lt;ul>
&lt;li>栈上分配内存比在堆中分配内存有更高的效率&lt;/li>
&lt;li>逃逸分析的目的是决定分配到栈还是堆&lt;/li>
&lt;li>逃逸分析在编译阶段完成&lt;/li>
&lt;/ul></content></item><item><title>Go Channel</title><link>https://xujiajiadexiaokeai.github.io/2022-07-12/go-channel/</link><pubDate>Tue, 12 Jul 2022 21:12:06 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-12/go-channel/</guid><description>读写nil管道均会阻塞 关闭的管道仍然可以读取数据 向关闭的管道写数据会触发panic
只有一个缓冲区的管道,写入数据 —&amp;gt; 加锁; 读出数据 -&amp;gt; 解锁
特性 初始化 变量声明 var ch chan int declare chan, value == nil make() ch1 := make(chan string) no-buffered chan ch2 := make(chan string, 5) buffered chan 管道操作 操作符: &amp;lt;- -&amp;gt; 默认为双向可读写,在函数传递间可使用操作符限制读写 func ChanParamR(ch &amp;lt;-chan int) { only can read from chan } func ChanParamW(ch chan&amp;lt;- int) { only can write to chan } 数据读写 协程读取管道时,阻塞的条件有: chan no-buffer chan buffer no data chan value == nil 协程写入管道时,阻塞的条件有: chan no-buffer chan buffer is full chan value == nil 实现原理 数据结构 https://cs.</description><content>&lt;p>读写nil管道均会阻塞
关闭的管道仍然可以读取数据
向关闭的管道写数据会触发panic&lt;/p>
&lt;p>只有一个缓冲区的管道,写入数据 —&amp;gt; 加锁; 读出数据 -&amp;gt; 解锁&lt;/p>
&lt;h1 id="特性">特性&lt;/h1>
&lt;h2 id="初始化">初始化&lt;/h2>
&lt;ul>
&lt;li>变量声明&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">declare&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>make()&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">ch1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#a6e22e">no&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">buffered&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
&lt;span style="color:#a6e22e">ch2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#a6e22e">buffered&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="管道操作">管道操作&lt;/h2>
&lt;ul>
&lt;li>操作符: &amp;lt;- -&amp;gt;
默认为双向可读写,在函数传递间可使用操作符限制读写&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">ChanParamR&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;span style="color:#a6e22e">only&lt;/span> &lt;span style="color:#a6e22e">can&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">ChanParamW&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>&lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;span style="color:#a6e22e">only&lt;/span> &lt;span style="color:#a6e22e">can&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>数据读写
协程读取管道时,阻塞的条件有:&lt;/li>
&lt;li>chan no-buffer&lt;/li>
&lt;li>chan buffer no data&lt;/li>
&lt;li>chan value == nil
协程写入管道时,阻塞的条件有:&lt;/li>
&lt;li>chan no-buffer&lt;/li>
&lt;li>chan buffer is full&lt;/li>
&lt;li>chan value == nil&lt;/li>
&lt;/ul>
&lt;h1 id="实现原理">实现原理&lt;/h1>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/runtime/chan.go">https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/runtime/chan.go&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">hchan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">qcount&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// total data in the queue
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">dataqsiz&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// size of the circular queue
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">buf&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span> &lt;span style="color:#75715e">// points to an array of dataqsiz elements
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">elemsize&lt;/span> &lt;span style="color:#66d9ef">uint16&lt;/span>
&lt;span style="color:#a6e22e">closed&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;span style="color:#a6e22e">elemtype&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#75715e">// element type
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">sendx&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// send index
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">recvx&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// receive index
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">recvq&lt;/span> &lt;span style="color:#a6e22e">waitq&lt;/span> &lt;span style="color:#75715e">// list of recv waiters
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">sendq&lt;/span> &lt;span style="color:#a6e22e">waitq&lt;/span> &lt;span style="color:#75715e">// list of send waiters
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// lock protects all fields in hchan, as well as several
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// fields in sudogs blocked on this channel.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Do not change another G&amp;#39;s status while holding this lock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// (in particular, do not ready a G), as this can deadlock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// with stack shrinking.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">lock&lt;/span> &lt;span style="color:#a6e22e">mutex&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>环形队列
chan内部实现了一个环形队列,队列长度在chan创建时指定
sendx: 队尾, 写入位
recvx: 队首, 读取位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等待队列&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>goroutine从chan读 -&amp;gt; buf为空或没有buf -&amp;gt; 当前goroutine阻塞 -&amp;gt; 加入recvq&lt;/li>
&lt;li>goroutine向chan写 -&amp;gt; buf已满或没有buf -&amp;gt; 当前goroutine阻塞 -&amp;gt; 加入sendq
处于等待队列中的协程会在其他协程操作管道时被唤醒:&lt;/li>
&lt;li>因读阻塞的协程会被向管道写入的协程唤醒&lt;/li>
&lt;li>因写阻塞的协程会被从管道读取的协程唤醒&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>Invariants:
At least one of c.sendq and c.recvq is empty,
except for the case of an unbuffered channel with a single goroutine
blocked on it for both sending and receiving using a select statement,
in which case the length of c.sendq and c.recvq is limited only by the
size of the select statement.
For buffered channels, also:
c.qcount &amp;gt; 0 implies that c.recvq is empty.
c.qcount &amp;lt; c.dataqsiz implies that c.sendq is empty.
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>类型信息&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>一个管道只能传递一种类型的值&lt;/li>
&lt;li>如果需要管道传递任意类型的数据,可以使用interface{}类型&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>互斥锁
一个管道同时仅允许被一个协程读写&lt;/li>
&lt;/ol>
&lt;h2 id="管道操作-1">管道操作&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>创建管道
创建管道 -&amp;gt; 初始化hchan结构&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写入管道
trick:
当接收队列recvq不为空时,说明缓冲区中没有数据但有协程在等待数据
会把数据直接传递给recvq队列中的第一个协程,而不必再写入缓冲区&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读出管道
trick:
当等待发送队列sendq不为空,且没有缓冲区,
那么此时将直接从sendq队列的第一个协程中获取数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关闭管道
关闭管道时会把recvq中的协程全部唤醒, 协程会获取对应类型的零值
同时会把sendq队列中的协程全部唤醒,协程会触发panic&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>会触发panic的操作还有:&lt;/p>
&lt;ul>
&lt;li>关闭值为nil的管道&lt;/li>
&lt;li>关闭已经被关闭的管道&lt;/li>
&lt;li>向已经关闭的管道写入数据&lt;/li>
&lt;/ul>
&lt;h2 id="常见用法">常见用法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>单向管道&lt;/p>
&lt;/li>
&lt;li>
&lt;p>select
使用select可以监控多个管道
select的case语句读管道时不会阻塞&lt;/p>
&lt;/li>
&lt;li>
&lt;p>for-range
for-range可以持续从管道中读出数据,当管道中没有数据时会阻塞当前协程&lt;/p>
&lt;/li>
&lt;/ul></content></item><item><title>Bloom Filter VS Ribbon Filter</title><link>https://xujiajiadexiaokeai.github.io/2022-07-01/bloomfilter-vs-ribbonfilter/</link><pubDate>Fri, 01 Jul 2022 10:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-01/bloomfilter-vs-ribbonfilter/</guid><description>https://developer.aliyun.com/article/980796
由于Bloom Filter只需要占用极小的空间，便可以给出”可能存在“和”肯定不存在“的存在性判断，因此可以提前过滤掉许多不必要的数据块，从而节省了大量的磁盘IO</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://developer.aliyun.com/article/980796">https://developer.aliyun.com/article/980796&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>由于Bloom Filter只需要占用极小的空间，便可以给出”可能存在“和”肯定不存在“的存在性判断，因此可以提前过滤掉许多不必要的数据块，从而节省了大量的磁盘IO&lt;/p></content></item><item><title>Red Black Tree</title><link>https://xujiajiadexiaokeai.github.io/2022-03-25/red-black-tree/</link><pubDate>Fri, 25 Mar 2022 22:06:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-03-25/red-black-tree/</guid><description>23333</description><content>&lt;p>23333&lt;/p></content></item><item><title>AVLTree</title><link>https://xujiajiadexiaokeai.github.io/2022-03-25/avl-tree/</link><pubDate>Fri, 25 Mar 2022 20:32:48 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-03-25/avl-tree/</guid><description>特征 · 左右子树的高度差小于等于1
· 每一个子树均为平衡二叉树
原理 监督机制 监督指标: 平衡因子(Balance Factor): 某个节点的左子树高度-右子树高度的差值
所以AVL树是一种所有节点的平衡因子的绝对值都不超过1的二叉树
高度 type Node struct { Data int Height int left *Node right *Node } 计算节点高度
func (n *Node) TreeHeight() int { if n == nil { return 0 } else { return max(treeHeight(n.left), treeHeight(n.right)) + 1 } } 在进行如下操作时,需要更新受影响的所有节点的高度
在插入节点时, 沿插入的路径更新节点的高度值
在删除节点时, 沿删除的路径更新节点的高度值
计算平衡因子
func (n *Node) treeBalanceFactor() { if n == nil { return 0 } else { return x.</description><content>&lt;h1 id="特征">特征&lt;/h1>
&lt;p>· 左右子树的高度差小于等于1&lt;/p>
&lt;p>· 每一个子树均为平衡二叉树&lt;/p>
&lt;h1 id="原理">原理&lt;/h1>
&lt;h2 id="监督机制">监督机制&lt;/h2>
&lt;h3 id="监督指标">监督指标:&lt;/h3>
&lt;p>&lt;strong>平衡因子&lt;/strong>(Balance Factor): 某个节点的左子树高度-右子树高度的差值&lt;/p>
&lt;p>所以AVL树是一种所有节点的平衡因子的绝对值都不超过1的二叉树&lt;/p>
&lt;h3 id="高度">高度&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Data&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;span style="color:#a6e22e">Height&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;span style="color:#a6e22e">left&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Node&lt;/span>
&lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Node&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>计算节点高度&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Node&lt;/span>) &lt;span style="color:#a6e22e">TreeHeight&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>(&lt;span style="color:#a6e22e">treeHeight&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span>.&lt;span style="color:#a6e22e">left&lt;/span>), &lt;span style="color:#a6e22e">treeHeight&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span>.&lt;span style="color:#a6e22e">right&lt;/span>)) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在进行如下操作时,需要更新受影响的所有节点的高度&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在插入节点时, 沿插入的路径更新节点的高度值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在删除节点时, 沿删除的路径更新节点的高度值&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>计算平衡因子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Node&lt;/span>) &lt;span style="color:#a6e22e">treeBalanceFactor&lt;/span>() {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>.&lt;span style="color:#a6e22e">left&lt;/span>.&lt;span style="color:#a6e22e">height&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>.&lt;span style="color:#a6e22e">right&lt;/span>.&lt;span style="color:#a6e22e">height&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="再平衡">再平衡&lt;/h2>
&lt;p>左旋和右旋&lt;/p>
&lt;p>在整个平衡化过程可能进行一次或多次,从失去平衡的最小子树根节点开始&lt;/p>
&lt;p>右旋:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Node&lt;/span>) &lt;span style="color:#a6e22e">treeRotateRight&lt;/span>() {
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>左旋&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Node&lt;/span>) &lt;span style="color:#a6e22e">treeRotateLeft&lt;/span>() {
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="需要平衡的四种情况">需要平衡的四种情况&lt;/h3>
&lt;ol>
&lt;li>LL&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312g482677e05394fcde6d8d0ff8553342f9?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY0ODgxNTcxMSwiaWF0IjoxNjQ4MjEwOTExLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmc0ODI2NzdlMDUzOTRmY2RlNmQ4ZDBmZjg1NTMzNDJmOSJ9.KVRPdEsaV4Vj5BLRVmHR3h0wpKwsW_zMh-s8HUdt3aU&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>RR&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LR&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312g335de979fb780cfd8a48c2348c1cc61f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY0ODgxNTcxMSwiaWF0IjoxNjQ4MjEwOTExLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmczMzVkZTk3OWZiNzgwY2ZkOGE0OGMyMzQ4YzFjYzYxZiJ9.88VeeegnYTUu9r94DBtMln21URc3Dus40r0lOQyvM6U&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;ol start="4">
&lt;li>RL&lt;/li>
&lt;/ol></content></item><item><title>My First Post</title><link>https://xujiajiadexiaokeai.github.io/posts/my-first-post/</link><pubDate>Sat, 12 Feb 2022 13:17:00 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/posts/my-first-post/</guid><description>111</description><content>&lt;p>111&lt;/p></content></item><item><title>Posts Archive</title><link>https://xujiajiadexiaokeai.github.io/archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xujiajiadexiaokeai.github.io/archive/</guid><description/><content/></item><item><title>为什么select仅能作用于管道?</title><link>https://xujiajiadexiaokeai.github.io/posts/go-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xujiajiadexiaokeai.github.io/posts/go-select/</guid><description>select的特性 case的执行 具体执行那个case,取决于函数传入的管道
管道没有缓冲区 有缓冲区并且还可以塞数据 有缓冲区但缓冲区已满 有缓冲区且已有部分数据 返回值 可以在case中声明变量并赋值
default default不能处理管道读写 当所有case被阻塞,执行default default是特殊的case
使用案例 永久阻塞 使用select阻塞main函数
func main() { server := webhooktesting.NewTestServer(nil) server.StartTLS() fmt.Println(&amp;#34;serving on&amp;#34;, server.URL) select {} // 没有case和default ,main()永久阻塞 } 快速检错 当使用管道来传输error时, 可以使用select快速检查管道中是否有error
errCh := make(chan error, active) jm.deleteJobPods(&amp;amp;job, activePods, errCh) // 传入chan用于记录error select { case manageJobErr = &amp;lt;-errCh: if manageJobErr != nil { break } default: // 没有error, 结束 } 限时等待 当使用管道管理函数上下文时, 可以使用select创建具有时效性的管道
func waitForStopOrTimeout(stopCh &amp;lt;-chan struct{}, timeout time.</description><content>&lt;h1 id="select的特性">select的特性&lt;/h1>
&lt;h2 id="case的执行">case的执行&lt;/h2>
&lt;p>具体执行那个case,取决于函数传入的管道&lt;/p>
&lt;ul>
&lt;li>管道没有缓冲区&lt;/li>
&lt;li>有缓冲区并且还可以塞数据&lt;/li>
&lt;li>有缓冲区但缓冲区已满&lt;/li>
&lt;li>有缓冲区且已有部分数据&lt;/li>
&lt;/ul>
&lt;h2 id="返回值">返回值&lt;/h2>
&lt;p>可以在case中声明变量并赋值&lt;/p>
&lt;h2 id="default">default&lt;/h2>
&lt;p>default不能处理管道读写
当所有case被阻塞,执行default
default是特殊的case&lt;/p>
&lt;h1 id="使用案例">使用案例&lt;/h1>
&lt;h2 id="永久阻塞">永久阻塞&lt;/h2>
&lt;p>使用select阻塞main函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">webhooktesting&lt;/span>.&lt;span style="color:#a6e22e">NewTestServer&lt;/span>(&lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">StartTLS&lt;/span>()
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;serving on&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">URL&lt;/span>)
&lt;span style="color:#66d9ef">select&lt;/span> {} &lt;span style="color:#75715e">// 没有case和default ,main()永久阻塞
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快速检错">快速检错&lt;/h2>
&lt;p>当使用管道来传输error时, 可以使用select快速检查管道中是否有error&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">errCh&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>, &lt;span style="color:#a6e22e">active&lt;/span>)
&lt;span style="color:#a6e22e">jm&lt;/span>.&lt;span style="color:#a6e22e">deleteJobPods&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">job&lt;/span>, &lt;span style="color:#a6e22e">activePods&lt;/span>, &lt;span style="color:#a6e22e">errCh&lt;/span>) &lt;span style="color:#75715e">// 传入chan用于记录error
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">select&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">manageJobErr&lt;/span> = &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">errCh&lt;/span>:
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">manageJobErr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">break&lt;/span>
}
&lt;span style="color:#66d9ef">default&lt;/span>: &lt;span style="color:#75715e">// 没有error, 结束
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="限时等待">限时等待&lt;/h2>
&lt;p>当使用管道管理函数上下文时, 可以使用select创建具有时效性的管道&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">waitForStopOrTimeout&lt;/span>(&lt;span style="color:#a6e22e">stopCh&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}, &lt;span style="color:#a6e22e">timeout&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>) &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{} {
&lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{})
&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;span style="color:#66d9ef">select&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">stopCh&lt;/span>:
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">After&lt;/span>(&lt;span style="color:#a6e22e">timeout&lt;/span>): &lt;span style="color:#75715e">// 管道会在指定时间内关闭
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
close(&lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span>)
}()
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="实现原理">实现原理&lt;/h1>
&lt;ul>
&lt;li>为什么每个case语句只能处理一个管道?&lt;/li>
&lt;li>为什么case语句执行顺序随机(多个case都就绪的情况下)?&lt;/li>
&lt;li>为什么case语句向值为nil的管道中写数据不会触发panic?&lt;/li>
&lt;/ul>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">scase&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">hchan&lt;/span> &lt;span style="color:#75715e">// 操作的管道
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">kind&lt;/span> &lt;span style="color:#a6e22e">unit16&lt;/span> &lt;span style="color:#75715e">// case类型
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">elem&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span> &lt;span style="color:#75715e">// 指向数据存放位置的指针
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">...&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>管道
因为每个scase中只有一个管道, 这决定了一个case只能处理一个管道
编译器在处理case语句时,如果case语句中没有管道操作(不能处理成scase对象),则会给出编译错误:&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>select case must be receive, send or assign recv
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>类型&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">const&lt;/span> (
&lt;span style="color:#a6e22e">caseNil&lt;/span> = &lt;span style="color:#66d9ef">iota&lt;/span>
&lt;span style="color:#a6e22e">caseRecv&lt;/span>
&lt;span style="color:#a6e22e">caseSend&lt;/span>
&lt;span style="color:#a6e22e">caseDefault&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>caseNil: 表示其操作的管道值为nil, 由于nil管道既不可读,也不可写,所以永远不会命中
所以在case语句中向值为nil的管道中写数据不会触发panic的原因&lt;/li>
&lt;li>caseRecv: 从管道中读数据&lt;/li>
&lt;li>caseSend: 向管道中写数据&lt;/li>
&lt;li>caseDeafult: 不会操作管道,每个select中仅可存在一个, 可出现在任意位置&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>数据
scase.elem表示数据存放的地址&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>caseRecv: 读出的数据存放的地址&lt;/li>
&lt;li>caseSend: 将写入管道的数据存放的地址&lt;/li>
&lt;/ul>
&lt;h2 id="实现逻辑">实现逻辑&lt;/h2>
&lt;p>&lt;code>selectgo()&lt;/code> 用于处理select语句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">selectgo&lt;/span>(&lt;span style="color:#a6e22e">cas0&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">scase&lt;/span>, &lt;span style="color:#a6e22e">order0&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">uint16&lt;/span>, &lt;span style="color:#a6e22e">ncases&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) (&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>selectgo()&lt;/code>函数会从一组case中挑选一个case,并返回命中case的下标,对于caseRecv的case,还会返回是否读取成功
当所有case都不可能就绪时,selectgo()陷入永久阻塞,此时函数不会返回&lt;/p>
&lt;h3 id="cas0">cas0&lt;/h3>
&lt;p>编译器会将select中的case语句存储在一个数组中,cas0保存这个数组的地址&lt;/p>
&lt;h3 id="ncases">ncases&lt;/h3>
&lt;p>ncases表示case的个数(包活default),即cas0数组的长度&lt;/p>
&lt;h3 id="order0">order0&lt;/h3>
&lt;p>order0 为一个整型数组的地址,其长度为case格式的2倍.
order0数组是&lt;strong>case执行随机性的关键&lt;/strong>&lt;/p>
&lt;p>order0数组被一分为二
前半部分存放case的随机顺序(pollorder),selectgo()会将原始的case顺序打乱,这样在检查每个case是否就绪时就会表现出随机性
后半部分存放管道加锁的顺序(lockorder),selectgo()会按照管道地址顺序对多个管道加锁,从而避免因重复加锁引发的死锁问题&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>selectgo()函数的实现包括以下要点:&lt;/p>
&lt;ul>
&lt;li>通过随机函数fastrandn()将原始的case顺序打乱,在遍历各个case时使用打乱后的顺序就会表现出随机性&lt;/li>
&lt;li>循环遍历各个case时,如果发现某个case就绪,则直接跳出循环操作管道并返回&lt;/li>
&lt;li>循环遍历各个case时,如果循环正常结束,说明所有case都没有就绪,有default直接跳default&lt;/li>
&lt;li>如果都没有就绪且没有default,selectgo()将阻塞等待所有管道,任一管道就绪后,都将开始新的循环&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;ul>
&lt;li>select仅能操作管道&lt;/li>
&lt;li>每个case仅能处理一个管道,要么读要么写&lt;/li>
&lt;li>多个case语句的执行顺序是随机的&lt;/li>
&lt;li>存在default,则select不会阻塞&lt;/li>
&lt;/ul></content></item><item><title>关于我</title><link>https://xujiajiadexiaokeai.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xujiajiadexiaokeai.github.io/about/</guid><description>姜文浩 个人信息 男 / 1997.11 本科 / 上海第二工业大学 / 软件工程 工作时间: 2年 联系方式: 15900544142 / whjiang1997@gmail.com 期望职位: Golang研发工程师(云原生方向) 专业技能 熟悉Golang/Node.js 1年B端SaaS研发经验,有大量排查问题经历 熟悉Kubernetes, 了解相关生态和技术 熟悉eBPF,了解eBPF运行机制和kprobe、uprobe的使用 熟悉分布式原理,了解Paxos、Raft等一致性算法 熟悉HTTP相关网络协议,知悉优劣,了解grpc 了解设计模式,DDD开发思想,混沌工程 工作经历 2022.10 - 2022.11 三度观测云(北京)科技有限责任公司 - 后端研发工程师 Tricorder Observability是一款开源云原生观测平台SaaS；基于eBPF、WASM，定义不改业务代码、自动数据采集零成本观测体验.
我主要负责基于eBPF的核心数据采集和部署模块的开发.作为初创公司的创始团队成员,还参与了研发相关流程的梳理和规范撰写,在知识库中保留了相关文档供新晋员工参考.
主要解决的问题:
基于eBPF的HTTP1.x流量解析模块 Kubernetes集群内eBPF Code的部署模块 收获:
从0到1的项目构建经验 2020.8 - 2021.8 阿里巴巴钉钉事业部Teambition团队(外包编制) - 后端研发工程师 Teambition私有云开发及维护
Teambition为自研团队协作工具,以项目和任务的可视化管理来支撑企业团队协作,有公有云和私有云两个版本,拥有大量用户.
我主要负责私有云线上问题的排查处理、公有云迁移值班OnCall和处理一些客户定制开发需求.累计参与数百项问题的定位和修复.
主要解决的问题:
推动刷库脚本&amp;quot;DryRun&amp;quot;及可回滚 推动对强依赖中间件添加健康检查 推动故障排查手册的维护和使用 收获:
大量的线上问题排查经验 大型SaaS微服务架构设计经验 优秀团队规范的coding风格和标准的CI&amp;amp;CD流程 2019.</description><content>&lt;h2 id="姜文浩">姜文浩&lt;/h2>
&lt;h2 id="个人信息">个人信息&lt;/h2>
&lt;ul>
&lt;li>男 / 1997.11&lt;/li>
&lt;li>本科 / 上海第二工业大学 / 软件工程&lt;/li>
&lt;li>工作时间: 2年&lt;/li>
&lt;li>联系方式: 15900544142 / &lt;a href="mailto:whjiang1997@gmail.com">whjiang1997@gmail.com&lt;/a>&lt;/li>
&lt;li>期望职位: &lt;em>Golang研发工程师(云原生方向)&lt;/em>&lt;/li>
&lt;/ul>
&lt;h2 id="专业技能">专业技能&lt;/h2>
&lt;ul>
&lt;li>熟悉Golang/Node.js&lt;/li>
&lt;li>1年B端SaaS研发经验,有大量排查问题经历&lt;/li>
&lt;li>熟悉Kubernetes, 了解相关生态和技术&lt;/li>
&lt;li>熟悉eBPF,了解eBPF运行机制和kprobe、uprobe的使用&lt;/li>
&lt;li>熟悉分布式原理,了解Paxos、Raft等一致性算法&lt;/li>
&lt;li>熟悉HTTP相关网络协议,知悉优劣,了解grpc&lt;/li>
&lt;li>了解设计模式,DDD开发思想,混沌工程&lt;/li>
&lt;/ul>
&lt;h2 id="工作经历">工作经历&lt;/h2>
&lt;h3 id="202210---202211-三度观测云北京科技有限责任公司---后端研发工程师">2022.10 - 2022.11 三度观测云(北京)科技有限责任公司 - 后端研发工程师&lt;/h3>
&lt;p>&lt;a href="https://tricorder.dev/">Tricorder Observability&lt;/a>是一款开源云原生观测平台SaaS；基于eBPF、WASM，定义&lt;strong>不改业务代码、自动数据采集&lt;/strong>零成本观测体验.&lt;/p>
&lt;p>我主要负责基于eBPF的核心数据采集和部署模块的开发.作为初创公司的创始团队成员,还参与了研发相关流程的梳理和规范撰写,在知识库中保留了相关文档供新晋员工参考.&lt;/p>
&lt;p>&lt;strong>主要解决的问题:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>基于eBPF的HTTP1.x流量解析模块&lt;/li>
&lt;li>Kubernetes集群内eBPF Code的部署模块&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>收获:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从0到1&lt;/strong>的项目构建经验&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="20208---20218-阿里巴巴钉钉事业部teambition团队外包编制---后端研发工程师">2020.8 - 2021.8 阿里巴巴钉钉事业部Teambition团队(外包编制) - 后端研发工程师&lt;/h3>
&lt;p>&lt;strong>Teambition私有云开发及维护&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.teambition.com/">Teambition&lt;/a>为自研团队协作工具,以项目和任务的可视化管理来支撑企业团队协作,有公有云和私有云两个版本,拥有大量用户.&lt;/p>
&lt;p>我主要负责私有云线上问题的排查处理、公有云迁移值班OnCall和处理一些客户定制开发需求.累计参与数百项问题的定位和修复.&lt;/p>
&lt;p>&lt;strong>主要解决的问题:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>推动刷库脚本&amp;quot;DryRun&amp;quot;及可回滚&lt;/li>
&lt;li>推动对强依赖中间件添加健康检查&lt;/li>
&lt;li>推动故障排查手册的维护和使用&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>收获:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>大量的线上问题排查经验&lt;/li>
&lt;li>大型SaaS微服务架构设计经验&lt;/li>
&lt;li>优秀团队规范的coding风格和标准的CI&amp;amp;CD流程&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="20194---20206-上海妙点网络科技有限公司---后端研发工程师">2019.4 - 2020.6 上海妙点网络科技有限公司 - 后端研发工程师&lt;/h3>
&lt;p>&lt;strong>聚合写作&lt;/strong>&lt;/p>
&lt;p>聚合写作为公司内部项目,从外部网站、接口爬取数据,再根据预编写的规则对数据进行加工,生成数据用于内容部门生产,实现了完整的ETL过程.有100+数据项目在线运行.&lt;/p>
&lt;p>我主要负责聚合写作项目的日常开发及维护.&lt;/p>
&lt;p>&lt;strong>主要解决的问题:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>基于BloomFilter的爬虫排重过滤器的开发&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>收获:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对Node.js的events、child_process、vm等模块有了更加详细的认识&lt;/li>
&lt;li>加深了对Node.js单线程、非阻塞IO等特性的理解&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>财经秘书&lt;/strong>&lt;/p>
&lt;p>财经秘书为公司C端产品,日活1万+.为用户提供90+细分行业每日经济资讯、行业数据；并有专业研究员为用户解答问题、提供投资建议和行业研报.&lt;/p>
&lt;p>我主要负责v3.0版本的接口设计与开发、后台管理系统改造和内容创作中心的开发.&lt;/p>
&lt;p>&lt;strong>主要解决的问题:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>多来源、多类型混合feed流的开发&lt;/li>
&lt;li>后台管理系统改造为开放平台,允许第三方接入&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>收获:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对NoSQL与SQL在使用和设计上的不同有了新的认识&lt;/li>
&lt;li>尝试使用缓存和队列来缓解服务器和数据库压力&lt;/li>
&lt;/ul>
&lt;h2 id="自我评价">自我评价&lt;/h2>
&lt;p>乐观开朗,承压能力强.具有良好的合作沟通能力,能够快速融入团队.技术上视野广阔,对新技术有着好奇心,喜欢钻研.日常喜欢烧菜,东北菜一绝.&lt;/p></content></item></channel></rss>