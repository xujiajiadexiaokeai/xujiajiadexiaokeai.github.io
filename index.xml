<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>xujiajiadexiaokeai</title><link>https://xujiajiadexiaokeai.github.io/</link><description>Recent content on xujiajiadexiaokeai</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2021-2023 xujiajiadexiaokeai</copyright><lastBuildDate>Fri, 07 Jul 2023 14:15:26 +0800</lastBuildDate><atom:link href="https://xujiajiadexiaokeai.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>关于离职后的这一年我做了什么</title><link>https://xujiajiadexiaokeai.github.io/2022-09-20/summary/</link><pubDate>Tue, 20 Sep 2022 22:14:47 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-09-20/summary/</guid><description>起子 其实这篇文章本可以叫做《未来的XX时间我要做什么》,用来指导关于技术上的学习计划.
可惜由于某些原因,我选择了离职来完成这部分学习计划.
也由于某些原因, 这部分计划的完成距我2021年8月20日离职至今已经近13个月的时间, 这大大超出了我的预期,对自己的生活也造成了一定的影响.
希望通过这篇文章对过去这13个月的时间进行总结和复盘.
我想要做什么? 重新梳理大学时期忽略的一些基础知识 尤其是在操作系统原理、计算机体系结构、编译原理、计算机网络等等应该进行大量实验,却统统上成了PPT式的背题考试课程,只知其然,不知其所以然.
所以当我看到南大jyy老师在操作系统这门课的课堂上给讲台下的同学用GDB一步一步调试内核代码的时候,我真的要哭了.他真的在教台下的同学,怎样去一点一点的阅读代码,什么是good practice,什么是bad practice.真的是我大学四年几乎未经历过的.2022的上半年在Bilibili上有幸看到了课程直播并跟着重新学习了一遍操作系统.(Update: 墙裂推荐! 2023春季开始啦!jyyYYDS!)
搭建自己的从“输入”到“输出”的知识管理工具体系 回顾自己在过去的学习中,确实也做了一些笔记,整理了一些东西,但是都只留在了纸面上.没有经常的整理、回顾、应用,慢慢也就都遗忘掉了.真的是学的多,记的少.回想大学时拿着php帮图书馆老师撸图书馆新生管理系统,到现在php的语法几乎都想不起来了&amp;hellip;
所以在过去的一年中我尝试在用博客来整理自己的知识,这样随时能打开翻一翻.这只是一小步,之后应该怎么做还需要继续探索.
之前在微博中看到了好多技术博主分享的微博,当时觉得不错就点了收藏.有很多不错的内容,过后想找出来再看一下,但是收藏的微博太多了,微博收藏又没有搜索的功能.所以写了个爬虫把收藏的微博都爬了下来,都已经收藏了1千多条了.之后考虑搞个前端页面,把这些内容都管理起来.(Update: 尝试接入chatGPT把核心内容直接提取出来,打上标签来管理)
为什么要这么做? 大学时没有好好的学习基础,过于专注于业务实现,东搞一点西搞一点.Java、php、React Native、Node.js都拿来写过七七八八的应用,但几乎没有碰过系统层面的东西.
大学时期上课清一色的Windows,Linux只是书本上提过的名词,当时因为好奇在笔记本上装了虚拟机,但是面对只有命令行的界面真的手足无措,至今还被女朋友嘲笑当时总是打开虚拟机敲一遍sudo apt update和sudo apt upgrade就关机.
工作后才开始正式在Linux上做开发,但一开始也就是一些CURD业务上的实现,也没碰到过系统层面的Debug.直到我加入了Teambition并开始负责私有云客户问题处理的时候,这个问题才正式暴露出来.在排查系统和网络层面上的问题时,经常对问题的出现摸不到头脑,要耗费大量的时间在上面,也会导致问题的延期.这让我感觉到困惑和恐惧,决定深入探究这方面的知识,彻底解决疑惑.
因为要随时响应客户问题,所以时间是特别碎片化的,下班后也经常需要和运维同学去搞升级.尤其前期知识层面的空白,学习起来也要耗费大量时间.后来就开始计划离职,这样可以全身心高效地投入,用较短的时间来重新搭建知识框架,重新出发.
这一年做了什么? 读完《DDIA》 读完《现代操作系统 原理与实现》 看了6.824 看了jyy的操作系统课 学了Golang 实现操作系统内核 实现TCP协议 实现Paxos 实现Kubernetes Operator 玩了PingCAP的tinyKV 玩Chaos Mesh 玩eBPF 总结 对自己没有清晰的认知,对生活的掌握是失控的
回想当时特别上头的去离职的决定,其实是有些后悔的,毕竟失去了工作就失去了经济来源.我一直留在出租屋内学习,一年的房租就要四万块,直接覆盖了我上班以来的存款.后面的日子多亏了老爸老妈的救济才撑下来.
当时设想的用大概半年时间完成上面的目标现在想想也十分可笑.确实是有大块的时间来学习了,但是人也懒散了,每天学学玩玩,也没有清晰的计划,偶尔熬个夜刷个剧,第二天睡到中午起,时间很快就过去了.到了半年的时间,想要学的东西才学了三分之一左右.女朋友开始建议我出去工作,家里人也开始关注我找工作的情况,但是我又真的想把这些东西都学完,搭建好知识框架,觉得这样也有助于之后的学习和工作.之后就这样一直拖着,偶尔假装在找工作,回家过了年然后又回到上海继续学习,正好又赶上上海封城,算救了我一把,直到现在才算有了一点成果.
回顾这一段时光,就像开头说的,对自己没有清晰的认知,对生活的掌握是失控的.计划的设定本身就是有问题的,但又一股脑的不考虑自身实际情况的去ALL IN,虽然到最后勉强取得了一些成果,但代价是巨大的.希望自己能在之后的生活和工作中,吸取教训.
最后,总算是推倒了之前摇摇晃晃的危楼,重新搭起了基本的知识结构.玩过内核,实现过协议,也勉强算是合格的计算机专业科班出身了&amp;hellip;
现在,就重新起航吧!</description><content>&lt;h1 id="起子">起子&lt;/h1>
&lt;p>其实这篇文章本可以叫做《未来的XX时间我要做什么》,用来指导关于技术上的学习计划.&lt;/p>
&lt;p>可惜由于某些原因,我选择了离职来完成这部分学习计划.&lt;/p>
&lt;p>也由于某些原因, 这部分计划的完成距我2021年8月20日离职至今已经近13个月的时间,
这大大超出了我的预期,对自己的生活也造成了一定的影响.&lt;/p>
&lt;p>希望通过这篇文章对过去这13个月的时间进行总结和复盘.&lt;/p>
&lt;h1 id="我想要做什么">我想要做什么?&lt;/h1>
&lt;ul>
&lt;li>重新梳理大学时期忽略的一些基础知识&lt;/li>
&lt;/ul>
&lt;p>尤其是在操作系统原理、计算机体系结构、编译原理、计算机网络等等应该进行大量实验,却统统上成了PPT式的背题考试课程,只知其然,不知其所以然.&lt;/p>
&lt;p>所以当我看到南大jyy老师在操作系统这门课的课堂上给讲台下的同学用GDB一步一步调试内核代码的时候,我真的要哭了.他真的在教台下的同学,怎样去一点一点的阅读代码,什么是good practice,什么是bad practice.真的是我大学四年几乎未经历过的.2022的上半年在Bilibili上有幸看到了课程直播并跟着重新学习了一遍操作系统.(&lt;strong>Update&lt;/strong>: 墙裂推荐! &lt;a href="https://jyywiki.cn/OS/2023/">2023春季&lt;/a>开始啦!jyyYYDS!)&lt;/p>
&lt;ul>
&lt;li>搭建自己的从“输入”到“输出”的知识管理工具体系&lt;/li>
&lt;/ul>
&lt;p>回顾自己在过去的学习中,确实也做了一些笔记,整理了一些东西,但是都只留在了纸面上.没有经常的整理、回顾、应用,慢慢也就都遗忘掉了.真的是学的多,记的少.回想大学时拿着php帮图书馆老师撸图书馆新生管理系统,到现在php的语法几乎都想不起来了&amp;hellip;&lt;/p>
&lt;p>所以在过去的一年中我尝试在用博客来整理自己的知识,这样随时能打开翻一翻.这只是一小步,之后应该怎么做还需要继续探索.&lt;/p>
&lt;p>之前在微博中看到了好多技术博主分享的微博,当时觉得不错就点了收藏.有很多不错的内容,过后想找出来再看一下,但是收藏的微博太多了,微博收藏又没有搜索的功能.所以写了个爬虫把收藏的微博都爬了下来,都已经收藏了1千多条了.之后考虑搞个前端页面,把这些内容都管理起来.(&lt;strong>Update&lt;/strong>: 尝试接入chatGPT把核心内容直接提取出来,打上标签来管理)&lt;/p>
&lt;h1 id="为什么要这么做">为什么要这么做?&lt;/h1>
&lt;p>大学时没有好好的学习基础,过于专注于业务实现,东搞一点西搞一点.Java、php、React Native、Node.js都拿来写过七七八八的应用,但几乎没有碰过系统层面的东西.&lt;/p>
&lt;p>大学时期上课清一色的Windows,Linux只是书本上提过的名词,当时因为好奇在笔记本上装了虚拟机,但是面对只有命令行的界面真的手足无措,至今还被女朋友嘲笑当时总是打开虚拟机敲一遍&lt;code>sudo apt update&lt;/code>和&lt;code>sudo apt upgrade&lt;/code>就关机.&lt;/p>
&lt;p>工作后才开始正式在Linux上做开发,但一开始也就是一些CURD业务上的实现,也没碰到过系统层面的Debug.直到我加入了Teambition并开始负责私有云客户问题处理的时候,这个问题才正式暴露出来.在排查系统和网络层面上的问题时,经常对问题的出现摸不到头脑,要耗费大量的时间在上面,也会导致问题的延期.这让我感觉到困惑和恐惧,决定深入探究这方面的知识,彻底解决疑惑.&lt;/p>
&lt;p>因为要随时响应客户问题,所以时间是特别碎片化的,下班后也经常需要和运维同学去搞升级.尤其前期知识层面的空白,学习起来也要耗费大量时间.后来就开始计划离职,这样可以全身心高效地投入,用较短的时间来重新搭建知识框架,重新出发.&lt;/p>
&lt;h1 id="这一年做了什么">这一年做了什么?&lt;/h1>
&lt;ul>
&lt;li>读完《DDIA》&lt;/li>
&lt;li>读完《现代操作系统 原理与实现》&lt;/li>
&lt;li>看了6.824&lt;/li>
&lt;li>看了jyy的操作系统课&lt;/li>
&lt;li>学了Golang&lt;/li>
&lt;li>实现操作系统内核&lt;/li>
&lt;li>实现TCP协议&lt;/li>
&lt;li>实现Paxos&lt;/li>
&lt;li>实现Kubernetes Operator&lt;/li>
&lt;li>玩了PingCAP的tinyKV&lt;/li>
&lt;li>玩Chaos Mesh&lt;/li>
&lt;li>玩eBPF&lt;/li>
&lt;/ul>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>&lt;strong>对自己没有清晰的认知,对生活的掌握是失控的&lt;/strong>&lt;/p>
&lt;p>回想当时特别上头的去离职的决定,其实是有些后悔的,毕竟失去了工作就失去了经济来源.我一直留在出租屋内学习,一年的房租就要四万块,直接覆盖了我上班以来的存款.后面的日子多亏了老爸老妈的救济才撑下来.&lt;/p>
&lt;p>当时设想的用大概半年时间完成上面的目标现在想想也十分可笑.确实是有大块的时间来学习了,但是人也懒散了,每天学学玩玩,也没有清晰的计划,偶尔熬个夜刷个剧,第二天睡到中午起,时间很快就过去了.到了半年的时间,想要学的东西才学了三分之一左右.女朋友开始建议我出去工作,家里人也开始关注我找工作的情况,但是我又真的想把这些东西都学完,搭建好知识框架,觉得这样也有助于之后的学习和工作.之后就这样一直拖着,偶尔假装在找工作,回家过了年然后又回到上海继续学习,正好又赶上上海封城,算救了我一把,直到现在才算有了一点成果.&lt;/p>
&lt;p>回顾这一段时光,就像开头说的,对自己没有清晰的认知,对生活的掌握是失控的.计划的设定本身就是有问题的,但又一股脑的不考虑自身实际情况的去ALL IN,虽然到最后勉强取得了一些成果,但代价是巨大的.希望自己能在之后的生活和工作中,吸取教训.&lt;/p>
&lt;p>最后,总算是推倒了之前摇摇晃晃的危楼,重新搭起了基本的知识结构.玩过内核,实现过协议,也勉强算是合格的计算机专业科班出身了&amp;hellip;&lt;/p>
&lt;p>现在,就重新起航吧!&lt;/p></content></item><item><title>[译]内核扩展验证是站不住脚的·HOTOS '23</title><link>https://xujiajiadexiaokeai.github.io/2023-07-07/kernel-extension-verfication/</link><pubDate>Fri, 07 Jul 2023 14:15:26 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2023-07-07/kernel-extension-verfication/</guid><description>[译]内核扩展验证是站不住脚的·HOTOS &amp;lsquo;23 本文翻译自2023年HOTOS Conference中的论文&amp;ndash;Kernel extension verification is untenable
译者水平有限,翻译纯属爱好.如遇到问题,烦请指出,不胜感激.
统一本文一些特定词汇翻译:
escape hatches - 逃逸漏洞 helper function - 辅助函数 verification - 验证器 摘要 经过验证的eBPF字节码的出现迎来了一个安全内核扩展的新时代。在本文中，我们论证eBPF的验证器——其安全保证的来源,已经逐渐成为了一个累赘。除了众所周知的源于内核内验证器的复杂性和特殊性质的错误和漏洞之外，我们还强调了一个令人担忧的趋势，即引入了不安全内核函数(以辅助函数的形式)的逃逸漏洞，以绕过验证器对表达性施加的限制，不幸的是也绕过了它的安全保证。我们提出安全的内核扩展框架，不仅使用静态技术，而且使用轻量级运行时技术。我们描述了一种在安全Rust中以内核扩展为中心的设计，它将消除对内核内验证器的需求，改善表达性，允许减少逃逸漏洞，并最终提高内核扩展的安全性。
1 介绍 Linux中以eBPF形式出现的流行安全内核扩展框架已经点燃了一个围绕系统级功能的行业，从跟踪和可观察性[21]一直到安全性[26]、网络[23]、存储[20,52]和共识[53]。其价值主张的核心是前所未有的对于安全的承诺。为此，eBPF程序被编译成受限制的字节码，内核在此基础上执行验证:一种符号执行形式，检查所有可能的程序路径并保证属性，包括内存安全、免于崩溃、适当的资源获取和释放以及终止。
不幸的是，当前的内核内eBPF验证方法并没有达到它所承诺的安全性。在社区中，越来越多的人开始质疑内核验证器的正确性，而内核验证器的复杂性也在不断增加。由验证器引入的内核bug，以及利用不安全扩展通过验证器验证但违反安全属性的漏洞，在不断报告(见2.1节)。人们正在努力通过模糊测试[41]、验证验证器[11]或用携带证明的代码重写验证器[39]来改进eBPF验证器。
然而，即使验证器是完美的，我们观察到被验证的代码只占扩展程序的一小部分。在eBPF中，经过验证的代码与一组不断增长的潜在复杂且未经验证的辅助函数交互，这些辅助函数充当“逃逸漏洞”，以弥补因验证所需在程序表达性的严重限制(参见图1)。事实上，通过使用辅助函数，经过验证的“安全”eBPF程序可能违反上述所有验证保证。因此，尽管扩展编写者为在内核验证器的约束下编程付出了沉重的代价，但他们并没有得到承诺的安全保证。
我们的立场是，目前仅依赖静态字节码验证的安全内核扩展的短视方法是站不住脚的。相反，我们主张采用一种更广泛的方法来实现安全的内核扩展，而不是静态字节码验证。受过去[10]和现在[12,37]在操作系统内核中使用语言安全的启发，我们的关键见解是，通过平衡语言安全、运行时保护以及检查安全性和执行内核职责之间的关注点分离，扩展框架可以在类似的安全性下更具表现力。增强的表达性减少了对危险的辅助函数的需求，从而产生更好、更实用的保证。
我们建议使用Rust编程语言编写内核扩展，因为它的安全方法——包括但不限于内存安全、未定义行为和资源所有权——已经在其他操作系统环境中进行了探索[9,12,31,37]，并被Linux所接受[8]。我们没有尝试检查内核中的安全属性，而是允许一个受信任的用户空间Rust工具链对扩展进行签名，并利用安全密钥引导机制在加载时验证签名。最后，我们建议使用轻量级运行时机制来补充Rust，以实现诸如程序终止之类的属性，这些属性不容易在不严重影响表现力的情况下静态地完成。
我们相信，转向安全的、富有表现力的基于语言的扩展是行业持续发展的关键一步，也是围绕安全内核扩展出现更复杂用例的关键一步。此外，作为一个用安全语言实现内核功能的新入口，我们相信安全的Rust扩展将成为响应安全实用的操作系统内核号召的重要工具[31]。
2 验证是不被保证的 尽管eBPF验证令人兴奋和充满希望，但内核扩展并没有实现人们所期望的安全特性。因此，内核社区对eBPF持谨慎态度，甚至拒绝允许非特权用户加载(经过验证的)内核扩展的用例[22]。在这里，我们提供有关验证器已知问题的更多细节，确定由辅助函数引起的对验证器保证的新挑战，并提出远离验证器的理由。
2.1 验证并不容易 众所周知，目前Linux中的eBPF验证器由于其日益增加的复杂性和不断的变化，以及健全和完整的静态分析的挑战，是存在漏洞和脆弱的[19,33,39,50]。在这里，我们强调了验证器的复杂性和错误的增长，以及它的成本。
**验证器的复杂性正在增长。**如图2所示，自2014年引入eBPF验证器以来，它的规模一直在增长，以支持新的功能检查。例如，随着bpf_spin_lock helper的引入，验证器开始检查eBPF程序一次是否只持有一个锁，并在任何执行结束之前释放该锁[48]。为了支持BPF-to-BPF调用，在验证器中添加了500行C代码[45]。同时，验证器一直在不断优化和重构，以减少验证时间和内存消耗。正在积极开发的大量新的验证器特性(例如，[18,49])表明eBPF尚未达到足够的表达性。我们预计这种增长在近期内不会放缓。
**验证存在bug。**不断增加的复杂性导致不断引入新的错误。表1显示了在过去两年中，在eBPF验证器中至少发现了22个bug。这些漏洞导致了两种类型的漏洞利用。
首先，有缺陷的验证器可能会接受不安全的恶意eBPF程序，从而允许诸如任意读写[2,4,5]、内核指针泄漏[3,13 - 15,32]和特权升级[2,4]等攻击。例如，在CVE-2022-23222[4]记录的最近的一个错误中，指针值的验证缺失允许非特权用户执行非法的指针算术，导致内核内存上的任意读写能力，最终导致特权升级。其次，验证器本身可能容易受到攻击，并被不安全的恶意eBPF程序利用。例如，最近的一次提交[54]修复了验证器的循环内联代码中的use-after-free错误。
此外，即使是完美编码的验证器也无法阻止恶意eBPF程序利用eBPF生态系统下游组件(如JIT编译器)中的漏洞[38]。例如，JIT编译器中最近的一个bug[1]允许恶意eBPF代码成功通过了验证器进而劫持内核控制流。
验证是昂贵的。验证既要耗费人力时间，也要耗费机器时间。众所周知，验证器经常误报，这不必要地迫使开发人员大量修改正确的eBPF代码以通过验证器[19,39,50]。一个更基本的问题是验证器的有限可伸缩性。由于验证者需要评估所有可能的执行路径，因此必须限制eBPF程序的大小和复杂性，以便及时完成验证。为了满足这些验证器的限制，开发人员在编写大型复杂程序时需要找到将程序分解成小块的方法[20]。其结果是可编程性降低，性能开销增加[29]。
2.2 验证代码需要辅助函数的帮助 即使使用正确实现的验证器，安全性的承诺仍然很难实现，因为验证代码以辅助函数的形式与不安全的内核代码交互。如图1所示，辅助函数(helpers)是普通的、未经验证的内核函数，通常提供对各种内核数据结构(例如套接字缓冲区)的读/写访问。因为复杂的逻辑或程序外的内存访问可能无法在eBPF中表达，也无法由内核验证器进行验证，所以辅助函数的存在为eBPF程序提供了逃逸漏洞，使其变得更加有用。另一方面，辅助函数为验证过的代码逃逸提供了一种直接的机制。
**辅助函数很复杂。**人们普遍认为，复杂的代码往往比简单的代码有更多的bug。为了度量辅助函数的复杂性并首先指出它们的潜在危险，我们静态地分析了Linux内核版本5.18，以计算每个辅助函数的调用图。图3显示了Linux-5.18.1中249个helper函数的调用图中唯一节点的数量。如图所示，helper函数的复杂程度各不相同。例如，获取当前任务的PID和TGID的bpf_get_current_pid_tgid不调用其他内核函数。另一方面，bpf_sys_bpf允许eBPF程序调用bpf系统调用的一个子集，它的callgraph中有4845个节点。具体来说，52.2%的辅助函数调用30多个其他内核函数，34.5%调用500多个其他函数。helper函数实现中的错误和漏洞是其复杂性的自然结果，如下所述，这些错误和漏洞可能被不安全或恶意的eBPF程序利用。
**辅助函数正在增长。**引入新的辅助函数的主要动机是提高eBPF程序的表达性和实用性。随着研究人员和实践者发明安全内核扩展的新用例，而不是在eBPF中实现这些新用例并将它们传递给验证器，他们正在引入新的辅助函数。图4显示了helper数量随时间的增长情况。大约每两年添加50个辅助函数。除了这些专门为eBPF程序开发和公开的辅助函数外，开发人员还引入了新的方法来公开现有的内部内核函数，供eBPF程序使用[16]。由于这些内部内核函数在编写时并没有考虑到eBPF的使用，因此eBPF程序使用它们更有可能导致违反安全规定。在这种趋势下，在未来十年中，辅助函数接口将与系统调用接口一样宽(或比系统调用接口更宽)，为经过验证的代码提供许多触发意外行为的机会。
**辅助函数可能会违反规则。**随着更多新helper的引入，各种helper函数中的错误和漏洞也不断被发现。如表1所示，在过去两年中，已经在Linux内核中发现并修复了至少18个与安全相关的bug。
这些结果表明，辅助函数远非安全，并且很容易违反验证者假设的属性。
为了具体地展示当今辅助函数的危险，我们检查验证器保证的两个不同属性——安全性和终止。
安全。验证器确保eBPF代码不能访问程序外部的内存，包括试图解引用NULL指针。但是，通过一个辅助函数，我们编写了使内核崩溃的eBPF程序。具体来说，我们发现了helper bpf_sys_bpf中的一个错误，并构造了一个eBPF程序，用一个包含NULL指针字段的联合指针参数调用helper。
由于验证器没有执行深入的参数检查，我们通过解引用联合内部的NULL指针来实现内核崩溃。我们报告了这个bug，很快就确定它是可利用的(允许任意内核读取)，并分配了一个CVE[5]。
**终止。**eBPF验证器应该保证终止，以防止由错误或恶意eBPF程序引起的内核锁定。然而，我们可以很容易地编写一个eBPF程序，它可以在持有RCU读锁的情况下运行几乎无限的时间，从而导致RCU停滞。
我们精心设计的eBPF代码使用对bpf_loop helper的嵌套调用来对eBPF映射对象执行随机读写。它给了我们对总运行时间的线性控制;
虽然我们已经连续运行了800秒(足以观察到RCU的停顿)，但我们计算出，如果有更多的嵌套循环和eBPF尾部调用[44]，我们可以制作一个可以运行数百万年的程序。
2.3 eBPF验证器需要退休 退一步说，目前的eBPF核查方法不充分的原因有两个:</description><content>&lt;h1 id="译内核扩展验证是站不住脚的hotos-23">[译]内核扩展验证是站不住脚的·HOTOS &amp;lsquo;23&lt;/h1>
&lt;p>本文翻译自2023年HOTOS Conference中的论文&amp;ndash;&lt;a href="https://dl.acm.org/doi/10.1145/3593856.3595892">Kernel extension verification is untenable&lt;/a>&lt;/p>
&lt;p>译者水平有限,翻译纯属爱好.如遇到问题,烦请指出,不胜感激.&lt;/p>
&lt;p>统一本文一些特定词汇翻译:&lt;/p>
&lt;ul>
&lt;li>escape hatches - 逃逸漏洞&lt;/li>
&lt;li>helper function - 辅助函数&lt;/li>
&lt;li>verification - 验证器&lt;/li>
&lt;/ul>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>经过验证的eBPF字节码的出现迎来了一个安全内核扩展的新时代。在本文中，我们论证eBPF的验证器——其安全保证的来源,已经逐渐成为了一个累赘。除了众所周知的源于内核内验证器的复杂性和特殊性质的错误和漏洞之外，我们还强调了一个令人担忧的趋势，即引入了不安全内核函数(以辅助函数的形式)的逃逸漏洞，以绕过验证器对表达性施加的限制，不幸的是也绕过了它的安全保证。我们提出安全的内核扩展框架，不仅使用静态技术，而且使用轻量级运行时技术。我们描述了一种在安全Rust中以内核扩展为中心的设计，它将消除对内核内验证器的需求，改善表达性，允许减少逃逸漏洞，并最终提高内核扩展的安全性。&lt;/p>
&lt;h2 id="1-介绍">1 介绍&lt;/h2>
&lt;p>Linux中以eBPF形式出现的流行安全内核扩展框架已经点燃了一个围绕系统级功能的行业，从跟踪和可观察性[21]一直到安全性[26]、网络[23]、存储[20,52]和共识[53]。其价值主张的核心是前所未有的对于安全的承诺。为此，eBPF程序被编译成受限制的字节码，内核在此基础上执行验证:一种符号执行形式，检查所有可能的程序路径并保证属性，包括内存安全、免于崩溃、适当的资源获取和释放以及终止。&lt;/p>
&lt;p>不幸的是，当前的内核内eBPF验证方法并没有达到它所承诺的安全性。在社区中，越来越多的人开始质疑内核验证器的正确性，而内核验证器的复杂性也在不断增加。由验证器引入的内核bug，以及利用不安全扩展通过验证器验证但违反安全属性的漏洞，在不断报告(见2.1节)。人们正在努力通过模糊测试[41]、验证验证器[11]或用携带证明的代码重写验证器[39]来改进eBPF验证器。&lt;/p>
&lt;p>然而，即使验证器是完美的，我们观察到被验证的代码只占扩展程序的一小部分。在eBPF中，经过验证的代码与一组不断增长的潜在复杂且未经验证的辅助函数交互，这些辅助函数充当“逃逸漏洞”，以弥补因验证所需在程序表达性的严重限制(参见图1)。事实上，通过使用辅助函数，经过验证的“安全”eBPF程序可能违反上述所有验证保证。因此，尽管扩展编写者为在内核验证器的约束下编程付出了沉重的代价，但他们并没有得到承诺的安全保证。&lt;/p>
&lt;p>&lt;img src="../../img/kernel-extension-verification-figure1.png" alt="Figure 1">&lt;/p>
&lt;p>我们的立场是，目前仅依赖静态字节码验证的安全内核扩展的短视方法是站不住脚的。相反，我们主张采用一种更广泛的方法来实现安全的内核扩展，而不是静态字节码验证。受过去[10]和现在[12,37]在操作系统内核中使用语言安全的启发，我们的&lt;strong>关键见解&lt;/strong>是，通过平衡语言安全、运行时保护以及检查安全性和执行内核职责之间的关注点分离，扩展框架可以在类似的安全性下更具表现力。增强的表达性减少了对危险的辅助函数的需求，从而产生更好、更实用的保证。&lt;/p>
&lt;p>我们建议使用Rust编程语言编写内核扩展，因为它的安全方法——包括但不限于内存安全、未定义行为和资源所有权——已经在其他操作系统环境中进行了探索[9,12,31,37]，并被Linux所接受[8]。我们没有尝试检查内核中的安全属性，而是允许一个受信任的用户空间Rust工具链对扩展进行签名，并利用安全密钥引导机制在加载时验证签名。最后，我们建议使用轻量级运行时机制来补充Rust，以实现诸如程序终止之类的属性，这些属性不容易在不严重影响表现力的情况下静态地完成。&lt;/p>
&lt;p>我们相信，转向安全的、富有表现力的基于语言的扩展是行业持续发展的关键一步，也是围绕安全内核扩展出现更复杂用例的关键一步。此外，作为一个用安全语言实现内核功能的新入口，我们相信安全的Rust扩展将成为响应安全实用的操作系统内核号召的重要工具[31]。&lt;/p>
&lt;h2 id="2-验证是不被保证的">2 验证是不被保证的&lt;/h2>
&lt;p>尽管eBPF验证令人兴奋和充满希望，但内核扩展并没有实现人们所期望的安全特性。因此，内核社区对eBPF持谨慎态度，甚至拒绝允许非特权用户加载(经过验证的)内核扩展的用例[22]。在这里，我们提供有关验证器已知问题的更多细节，确定由辅助函数引起的对验证器保证的新挑战，并提出远离验证器的理由。&lt;/p>
&lt;h3 id="21-验证并不容易">2.1 验证并不容易&lt;/h3>
&lt;p>众所周知，目前Linux中的eBPF验证器由于其日益增加的复杂性和不断的变化，以及健全和完整的静态分析的挑战，是存在漏洞和脆弱的[19,33,39,50]。在这里，我们强调了验证器的复杂性和错误的增长，以及它的成本。&lt;/p>
&lt;p>**验证器的复杂性正在增长。**如图2所示，自2014年引入eBPF验证器以来，它的规模一直在增长，以支持新的功能检查。例如，随着bpf_spin_lock helper的引入，验证器开始检查eBPF程序一次是否只持有一个锁，并在任何执行结束之前释放该锁[48]。为了支持BPF-to-BPF调用，在验证器中添加了500行C代码[45]。同时，验证器一直在不断优化和重构，以减少验证时间和内存消耗。正在积极开发的大量新的验证器特性(例如，[18,49])表明eBPF尚未达到足够的表达性。我们预计这种增长在近期内不会放缓。&lt;/p>
&lt;p>&lt;img src="../../img/kernel-extension-verification-figure2.png" alt="Figure 2">&lt;/p>
&lt;p>**验证存在bug。**不断增加的复杂性导致不断引入新的错误。表1显示了在过去两年中，在eBPF验证器中至少发现了22个bug。这些漏洞导致了两种类型的漏洞利用。&lt;/p>
&lt;p>&lt;img src="../../img/kernel-extension-verification-table1.png" alt="Table 1">&lt;/p>
&lt;p>首先，有缺陷的验证器可能会接受不安全的恶意eBPF程序，从而允许诸如任意读写[2,4,5]、内核指针泄漏[3,13 - 15,32]和特权升级[2,4]等攻击。例如，在CVE-2022-23222[4]记录的最近的一个错误中，指针值的验证缺失允许非特权用户执行非法的指针算术，导致内核内存上的任意读写能力，最终导致特权升级。其次，验证器本身可能容易受到攻击，并被不安全的恶意eBPF程序利用。例如，最近的一次提交[54]修复了验证器的循环内联代码中的use-after-free错误。&lt;/p>
&lt;p>此外，即使是完美编码的验证器也无法阻止恶意eBPF程序利用eBPF生态系统下游组件(如JIT编译器)中的漏洞[38]。例如，JIT编译器中最近的一个bug[1]允许恶意eBPF代码成功通过了验证器进而劫持内核控制流。&lt;/p>
&lt;p>验证是昂贵的。验证既要耗费人力时间，也要耗费机器时间。众所周知，验证器经常误报，这不必要地迫使开发人员大量修改正确的eBPF代码以通过验证器[19,39,50]。一个更基本的问题是验证器的有限可伸缩性。由于验证者需要评估所有可能的执行路径，因此必须限制eBPF程序的大小和复杂性，以便及时完成验证。为了满足这些验证器的限制，开发人员在编写大型复杂程序时需要找到将程序分解成小块的方法[20]。其结果是可编程性降低，性能开销增加[29]。&lt;/p>
&lt;h3 id="22-验证代码需要辅助函数的帮助">2.2 验证代码需要辅助函数的帮助&lt;/h3>
&lt;p>即使使用正确实现的验证器，安全性的承诺仍然很难实现，因为验证代码以辅助函数的形式与不安全的内核代码交互。如图1所示，辅助函数(helpers)是普通的、未经验证的内核函数，通常提供对各种内核数据结构(例如套接字缓冲区)的读/写访问。因为复杂的逻辑或程序外的内存访问可能无法在eBPF中表达，也无法由内核验证器进行验证，所以辅助函数的存在为eBPF程序提供了逃逸漏洞，使其变得更加有用。另一方面，辅助函数为验证过的代码逃逸提供了一种直接的机制。&lt;/p>
&lt;p>**辅助函数很复杂。**人们普遍认为，复杂的代码往往比简单的代码有更多的bug。为了度量辅助函数的复杂性并首先指出它们的潜在危险，我们静态地分析了Linux内核版本5.18，以计算每个辅助函数的调用图。图3显示了Linux-5.18.1中249个helper函数的调用图中唯一节点的数量。如图所示，helper函数的复杂程度各不相同。例如，获取当前任务的PID和TGID的bpf_get_current_pid_tgid不调用其他内核函数。另一方面，bpf_sys_bpf允许eBPF程序调用bpf系统调用的一个子集，它的callgraph中有4845个节点。具体来说，52.2%的辅助函数调用30多个其他内核函数，34.5%调用500多个其他函数。helper函数实现中的错误和漏洞是其复杂性的自然结果，如下所述，这些错误和漏洞可能被不安全或恶意的eBPF程序利用。&lt;/p>
&lt;p>&lt;img src="../../img/kernel-extension-verification-figure3.png" alt="Figure 3">&lt;/p>
&lt;p>**辅助函数正在增长。**引入新的辅助函数的主要动机是提高eBPF程序的表达性和实用性。随着研究人员和实践者发明安全内核扩展的新用例，而不是在eBPF中实现这些新用例并将它们传递给验证器，他们正在引入新的辅助函数。图4显示了helper数量随时间的增长情况。大约每两年添加50个辅助函数。除了这些专门为eBPF程序开发和公开的辅助函数外，开发人员还引入了新的方法来公开现有的内部内核函数，供eBPF程序使用[16]。由于这些内部内核函数在编写时并没有考虑到eBPF的使用，因此eBPF程序使用它们更有可能导致违反安全规定。在这种趋势下，在未来十年中，辅助函数接口将与系统调用接口一样宽(或比系统调用接口更宽)，为经过验证的代码提供许多触发意外行为的机会。&lt;/p>
&lt;p>&lt;img src="../../img/kernel-extension-verification-figure4.png" alt="Figure 4">&lt;/p>
&lt;p>**辅助函数可能会违反规则。**随着更多新helper的引入，各种helper函数中的错误和漏洞也不断被发现。如表1所示，在过去两年中，已经在Linux内核中发现并修复了至少18个与安全相关的bug。&lt;/p>
&lt;p>这些结果表明，辅助函数远非安全，并且很容易违反验证者假设的属性。&lt;/p>
&lt;p>为了具体地展示当今辅助函数的危险，我们检查验证器保证的两个不同属性——安全性和终止。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>安全。验证器确保eBPF代码不能访问程序外部的内存，包括试图解引用NULL指针。但是，通过一个辅助函数，我们编写了使内核崩溃的eBPF程序。具体来说，我们发现了helper bpf_sys_bpf中的一个错误，并构造了一个eBPF程序，用一个包含NULL指针字段的联合指针参数调用helper。&lt;/p>
&lt;p>由于验证器没有执行深入的参数检查，我们通过解引用联合内部的NULL指针来实现内核崩溃。我们报告了这个bug，很快就确定它是可利用的(允许任意内核读取)，并分配了一个CVE[5]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**终止。**eBPF验证器应该保证终止，以防止由错误或恶意eBPF程序引起的内核锁定。然而，我们可以很容易地编写一个eBPF程序，它可以在持有RCU读锁的情况下运行几乎无限的时间，从而导致RCU停滞。&lt;/p>
&lt;p>我们精心设计的eBPF代码使用对bpf_loop helper的嵌套调用来对eBPF映射对象执行随机读写。它给了我们对总运行时间的线性控制;&lt;/p>
&lt;p>虽然我们已经连续运行了800秒(足以观察到RCU的停顿)，但我们计算出，如果有更多的嵌套循环和eBPF尾部调用[44]，我们可以制作一个可以运行数百万年的程序。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="23-ebpf验证器需要退休">2.3 eBPF验证器需要退休&lt;/h3>
&lt;p>退一步说，目前的eBPF核查方法不充分的原因有两个:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>静态字节码验证具有可靠性和完整性问题，并且从根本上难以扩展，这不可避免地会产生不安全的代码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对扩展表达性的不合理约束导致以辅助函数的形式引入不安全的逃逸漏洞。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>到目前为止，社区主要通过改进验证器实现来关注第一个问题。使用抽象解释实现用户空间验证器[19]。模糊验证和形式化验证被提出来改进现有的验证器和JIT编译器[11,38,39,41,50,51]。通过携带证明的代码，人们正在探索从内核中解耦证明的负担[39]。&lt;/p>
&lt;p>不幸的是，据我们所知，不安全的辅助函数的问题被忽视了;我们预计，即使在验证方面取得了上述进展，辅助函数仍将继续破坏安全性。&lt;/p>
&lt;h2 id="3-beyond-verification">3 BEYOND VERIFICATION&lt;/h2>
&lt;p>与其继续沿着静态字节码验证的路径前进——这是无效的——我们对安全内核扩展的新方法提出以下建议:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>**扩展语言应该更具表现力。**更具表现力的安全语言可以消除对某些辅助函数的需求，并简化其他辅助函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>静态代码分析应该与内核解耦&lt;/strong>。利用在类型检查器和正式软件验证上工作的更广泛的(用户空间)社区，可以减少由于特殊实现而产生的错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**静态分析和运行时机制应该一起工作。**实现易于在运行时执行且有效的属性可以减少分析和/或验证的负担(及其复杂性)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在本节的其余部分中，我们将描述一种安全内核扩展的潜在体系结构，它不需要过于严格的验证，从而避免了它的缺陷。&lt;/p>
&lt;h3 id="31-一种基于rust的方法">3.1 一种基于Rust的方法&lt;/h3>
&lt;p>我们建议，安全的内核扩展不应该完全依赖于使用执行模拟的内核内静态字节码验证，而应该依赖于语言安全和轻量级运行时机制的组合。图5给出了提议的内核扩展框架的概述。&lt;/p>
&lt;p>&lt;img src="../../img/kernel-extension-verification-figure5.png" alt="Figure 5">&lt;/p>
&lt;p>**Rust的安全属性。**由于其轻量级抽象、有效消除未定义行为(例如内存错误或整数错误)和独特的内存所有权模型，Rust正在成为一种流行的系统编程语言，甚至适用于操作系统内核[9,12,31,37]。通过限制用户实现的扩展程序只使用安全的Rust(即，没有不安全的块)，Rust编译器扮演了验证者的角色，以确保代码可以安全运行。我们设想一个可信的“内核箱”，它提供扩展程序的安全Rust和内核之间的接口。&lt;/p>
&lt;p>除了内存和整数安全之外，Rust还可以强制执行与安全资源获取和释放相关的属性。例如，在eBPF中，验证器当前检查程序通过辅助函数获得的资源的正确释放(例如，从bpf_sk_lookup_tcp helper获得的引用计数和从bpf_spin_lock helper函数获得的自旋锁)，拒绝可能会使资源悬空的程序。在Rust中，资源获取即初始化(resource-acquisition-is-initialization, RAII)模式[7]可用于创建用户扩展代码必须使用的内核资源的抽象。当对象超出作用域时，该资源将在析构函数中自动释放，从而保证其正确释放。&lt;/p>
&lt;p>**解耦静态代码分析。**我们不是在加载时分析代码以确保内核内部一次性实现的安全性，而是利用完整的Rust社区、工具链和许多正在进行的Rust验证项目[40]来执行安全检查。通过捎带内核对签名内核模块(甚至签名eBPF程序[43])的支持，我们的体系结构包含一个可信任的编译器，该编译器可以检查和签名扩展程序(参见图5)。在加载时，内核检查签名以确保安全。内核可能需要在程序上执行一定数量的加载时修复，以解析辅助函数地址和其他重定位，但它不会产生检查安全属性的负担(和复杂性)。&lt;/p>
&lt;p>**运行时的保护。**作为一种通用编程语言，即使是使用Rust的安全子集的程序也会表现出不良行为，包括无限循环或死锁。虽然我们依赖Rust语言进行内存隔离和防止未定义行为，但我们使用像看门狗计时器、信号和堆栈保护等运行时机制来终止程序，而不是违反安全性。相关工作还探讨了在运行时使用硬件保护，包括轻量级页面保护键来增强语言安全性[27,30,33]。&lt;/p>
&lt;p>运行时机制提出的一个关键挑战是如何执行扩展程序的安全终止。任何分配的内核资源(例如，引用计数)在任何原因(看门狗超时，Rust自己的Panic)终止时释放是至关重要的。在用户空间中，Rust使用基于ABI的堆栈展开机制(例如，llvm- libwind)来处理异常并执行清理操作，但这种方法不适用于内核扩展:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>unwind过程中的失败在用户空间中是允许的，但在内核空间中是不能容忍的，因为不完整的清理意味着泄漏内核资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于ABI的展开通常需要动态分配，这给中断上下文中的扩展带来了挑战，其中分配器可能不可用[17]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>展开通常对堆栈上所有现有对象执行析构函数，但执行不可信的用户定义析构函数(通过Rust中的Drop特性)是不安全的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在我们的框架中，轻量级机制可以有效地清理内核资源。我们可以在程序执行期间实时记录分配的内核资源及其析构函数。当需要终止时，调用已分配资源的析构函数来释放资源。因为只有与内核资源接口的受信任的内核crate才负责实现上述析构函数，所以所有的清理代码都是受信任的，并保证不会失败。为了处理unwind上下文的动态分配，我们设想使用基于内存池的分配机制，或者避免动态分配，同时使用专用的每cpu存储区域。&lt;/p>
&lt;p>安全属性。表2总结了通常由验证器强制执行的主要安全属性，这些属性可以由提议的内核扩展框架通过语言安全和运行时保护来强制执行。与eBPF不同，它们不受循环和程序大小的限制。我们将在第四节中讨论其他已验证的性质。&lt;/p>
&lt;h3 id="32-没有逃逸漏洞的安全">3.2 没有逃逸漏洞的安全&lt;/h3>
&lt;p>与当前eBPF编程模型中C的受限子集相比，Rust是一种高级图灵完备语言，这一事实提供了更好的可编程性优势。在本节中，我们将讨论这类辅助函数，这些辅助函数可以通过利用Rust增强的表达性来完全消除，也可以通过在安全的Rust中重写函数的某些方面来简化和提高其安全性。&lt;/p>
&lt;p>首先，为弥补eBPF语言的表达性不足而引入的辅助函数可以退役。我们使用bpf_loop, bpf_strtol和bpf_strncmp作为三个代表性的例子:(1)bpf_strtol可以被Rust中内置的core::str::parse取代，(2)bpf_strncmp可以完全在安全的Rust中实现，而不需要在内核中调用不安全的C代码，(3)bpf_loop可以直接删除，因为它只是提供了一个循环机制。根据初步研究[33]，有16个辅助函数属于这一类，可能会被淘汰。&lt;/p>
&lt;p>其次，许多与内核对象和过程接口的辅助函数不能完全删除，但可以大大简化，用安全的Rust替换容易出错的C代码。表1显示了在两个辅助函数bpf_get_task_stack和bpf_sk_lookup[34,35]中导致引用计数泄漏的两个bug。使用Rust，可以使用所有权系统来防止此类漏洞。使用RAII模式，可以实现被引用对象的Rust抽象，以便在其生命周期内保持引用，从而在超出范围时有效地释放引用计数。另一个例子是整数运算。由于Rust通过运行时检查禁止由整数错误引起的未定义行为(例如overflow，如array map helper中的错误[36])，整数运算可以从helper移到安全的Rust中。当程序使用内核crate提供的接口调用这样的helper时，在Rust代码调用不安全内核实现之前执行整数操作，从而防止不安全代码中的整数错误。&lt;/p>
&lt;p>最后，通过在不安全代码之上实现一个安全接口，可以使辅助函数更安全。该接口可以为从未经处理的输入到验证器未能检查的辅助函数中出现的漏洞提供缓解。在表1中，当helper接收到一个空的task_struct指针时，bpf_task_storage_get有一个空指针解引用错误[42]。辅助函数可以用task_struct指针参数作为引用类型包装在Rust中——Rust编译器将确保程序始终必须从有效对象中借用引用，从而有效地防止此类漏洞。可以为bpf_sys_bpf实现相同的接口，从而减轻2.2节中讨论的漏洞。&lt;/p>
&lt;p>我们相信，将繁琐、复杂的辅助函数重构为一个简单、明确的接口，可以在很大程度上解决安全性和表达性之间的冲突，正如在其他上下文中所探讨的那样[24]。&lt;/p>
&lt;h2 id="4-开放问题和讨论">4 开放问题和讨论&lt;/h2>
&lt;p>**进一步核查保证。**大多数验证器保证都可以通过Rust或运行时机制实现。最近，验证器包含了拒绝/清理包含训练分支预测器或类似于促进瞬态执行侧通道攻击的小工具的程序的逻辑[46,47]。虽然类似的策略可以在Rust级别或二进制级别上应用，但是在增强扩展的表达性(这有助于减少不安全的辅助函数)和静态提供保证的程序信息的可用性之间存在一个基本的权衡。我们相信安全的Rust在当前的技术状态下提供了一个很好的平衡。此外，通过提供关于Rust的正式保证来弥合差距的努力正在进行中[6]。&lt;/p>
&lt;p>**动态内存分配。**现有的eBPF子系统不支持eBPF程序中的动态内存分配，这使得它们更容易验证[19]。使用Rust中提出的方法，可以为扩展程序集成内存分配框架。这样的框架可以使用预分配的内存池实现[17]，因为扩展程序经常在不可休眠的上下文中运行(例如，从内核中断)。动态分配极大地增强了内核扩展的可编程性，使它们能够支持更复杂的用例。当然，动态内存管理给安全性带来了挑战。即使用户编程接口可以在安全的Rust中实现，就像当前Rust标准库的情况一样，低级内存管理代码通常必须用不安全的Rust编写。&lt;/p>
&lt;p>**防止不安全代码。**单一地址空间系统的概念，其中语言安全提供进程之间的隔离[25]，从而消除了昂贵的硬件上下文切换的需要，最近在Rust上下文中被重新审视[12,37]。然而，对于内核扩展，将不安全代码错误地写入属于安全扩展的代码或数据的威胁是不可避免的。不安全代码用于调用辅助函数或在内核crate中实现低级系统例程;事实上，内核本身的大部分都是不安全的。轻量级硬件支持的内存保护[27,30,33]似乎是一种很有前途的技术，可以保护安全代码免受不安全代码的侵害，但也提出了一个有趣的问题:如果我们必须求助于硬件保护机制，那么语言安全或验证仍然是保护内核和扩展免受彼此侵害的必要条件吗?即使不是这样，使用安全语言也是朝着未来完全安全内核的可能性迈出的一步，可以实现以前的单地址空间系统的好处。&lt;/p>
&lt;h2 id="5-结论">5 结论&lt;/h2>
&lt;p>安全内核扩展的巨大潜力正受到内核内eBPF验证器限制的阻碍。远离验证器将获得一个更安全、更具表现力的内核扩展框架。关键是平衡静态分析技术和轻量级动态机制。Rust生态系统为这种平衡提供了理想的属性，同时也很好地利用了对程序验证的改进。同时，通过分离关注点，基于Rust的扩展框架可以利用越来越轻量级的硬件特性。最后，随着Rust扩展使越来越多的内核代码(例如，helper函数)迁移到安全的Rust，新的机会出现了，不仅对于内核扩展用例，而且对于重新实现关键的内核子系统，最终得到一个安全，值得信赖的操作系统内核。&lt;/p>
&lt;h2 id="致谢">致谢&lt;/h2>
&lt;p>我们感谢Md Sayeedul Islam 和 Wentao Zhang对该项目的早期参与。Williams的研究小组得到了NSF CNS-2236966基金的部分支持。Xu的研究小组得到了NSF CNS-1956007基金和英特尔公司的部分资助。&lt;/p>
&lt;h2 id="引用">引用&lt;/h2>
&lt;p>[1] CVE-2021-29154. &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-29154">https://nvd.nist.gov/vuln/detail/CVE-2021-29154&lt;/a>.&lt;/p>
&lt;p>[2] CVE-2021-31440. &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-31440">https://nvd.nist.gov/vuln/detail/CVE-2021-31440&lt;/a>.&lt;/p>
&lt;p>[3] CVE-2021-45402. &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45402">https://nvd.nist.gov/vuln/detail/CVE-2021-45402&lt;/a>.&lt;/p>
&lt;p>[4] CVE-2022-23222. &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23222">https://nvd.nist.gov/vuln/detail/CVE-2022-23222&lt;/a>.&lt;/p>
&lt;p>[5] CVE-2022-2785. &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2022-2785">https://nvd.nist.gov/vuln/detail/CVE-2022-2785&lt;/a>.&lt;/p>
&lt;p>[6] ERC Project &amp;ldquo;RustBelt&amp;rdquo;. &lt;a href="https://plv.mpi-sws.org/rustbelt/">https://plv.mpi-sws.org/rustbelt/&lt;/a>.&lt;/p>
&lt;p>[7] RAII - Rust By Example. &lt;a href="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/&lt;/a> scope/raii.html.&lt;/p>
&lt;p>[8] Rust for Linux - GitHub. &lt;a href="https://github.com/Rust-for-Linux">https://github.com/Rust-for-Linux&lt;/a>.&lt;/p>
&lt;p>[9] Balasubramanian, A., Baranowski, M. S., Burtsev, A., Panda, A., Rakamarić, Z., and Ryzhyk, L. System Programming in Rust: Beyond Safety. In Proceedings of the 16th Workshop on Hot Topics in Operating Systems (HotOS’17) (May 2017).&lt;/p>
&lt;p>[10] Bershad, B. N., Savage, S., Pardyak, P., Sirer, E. G., Fiuczynski, M. E., Becker, D., Chambers, C., and Eggers, S. Extensibility, Safety and Performance in the SPIN Operating System. In Proceedings of the 15th ACM Symposium on Operating Systems Principles (SOSP’15) (Dec. 1995).&lt;/p>
&lt;p>[11] Bhat, S., and Shacham, H. Formal Verification of the Linux Kernel eBPF Verifier Range Analysis. &lt;a href="https://sanjit-bhat.github.io/assets/pdf/">https://sanjit-bhat.github.io/assets/pdf/&lt;/a> ebpf-verifier-range-analysis22.pdf, May 2022.&lt;/p>
&lt;p>[12] Boos, K., Liyanage, N., Ijaz, R., and Zhong, L. Theseus: An Experiment in Operating System Structure and State Management. In Proceedings of the 14th USENIX Conference on Operating Systems Design and Implementation (OSDI’20) (Nov. 2020).&lt;/p>
&lt;p>[13] Borkmann, D. bpf: Fix kernel address leakage in atomic cmpxchg’s r0 aux reg. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a82fe085f344ef20b452cd5f481010ff96b5c4cd">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a82fe085f344ef20b452cd5f481010ff96b5c4cd&lt;/a>, Dec. 2021.&lt;/p>
&lt;p>[14] Borkmann, D. bpf: Fix kernel address leakage in atomic fetch. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7d3baf0afa3aa9102d6a521a8e4c41888bb79882">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7d3baf0afa3aa9102d6a521a8e4c41888bb79882&lt;/a>, Dec. 2021.&lt;/p>
&lt;p>[15] Borkmann, D. bpf: Fix insufficient bounds propagation from adjust_scalar_min_max_vals. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3844d153a41adea718202c10ae91dc96b37453b5">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3844d153a41adea718202c10ae91dc96b37453b5&lt;/a>, July 2022.&lt;/p>
&lt;p>[16] Corbet, J. Calling kernel functions from BPF. &lt;a href="https://lwn.net/Articles/">https://lwn.net/Articles/&lt;/a> 856005/, May 2021.&lt;/p>
&lt;p>[17] Corbet, J. A BPF-specific memory allocator. &lt;a href="https://lwn.net/Articles/">https://lwn.net/Articles/&lt;/a> 899274/, June 2022.&lt;/p>
&lt;p>[18] Corbet, J. The BPF panic function. &lt;a href="https://lwn.net/Articles/901284/">https://lwn.net/Articles/901284/&lt;/a>, July 2022.&lt;/p>
&lt;p>[19] Gershuni, E., Amit, N., Gurfinkel, A., Narodytska, N., Navas, J. A., Rinetzky, N., Ryzhyk, L., and Sagiv, M. Simple and Precise Static Analysis of Untrusted Linux Kernel Extensions. In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI’19) (June 2019).&lt;/p>
&lt;p>[20] Ghigoff, Y., Sopena, J., Lazri, K., Blin, A., and Muller, G. BMC: Accelerating Memcached using Safe In-kernel Caching and Pre-stack Processing. In Proceedings of the 18th USENIX Symposium on Networked Systems Design and Implementation (NSDI’21) (Apr. 2021).&lt;/p>
&lt;p>[21] Gregg, B. Linux Extended BPF (eBPF) Tracing Tools. https://www. brendangregg.com/ebpf.html.&lt;/p>
&lt;p>[22] Gupta, P. bpf: Disallow unprivileged bpf by default. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8a03e56b253e9691c90bc52ca199323d71b96204">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8a03e56b253e9691c90bc52ca199323d71b96204&lt;/a>, Oct. 2021.&lt;/p>
&lt;p>[23] Høiland-Jørgensen, T., Brouer, J. D., Borkmann, D., Fastabend, J., Herbert, T., Ahern, D., and Miller, D. The EXpress Data Path: Fast Programmable Packet Processing in the Operating System Kernel. In Proceedings of the 14th International Conference on Emerging Networking EXperiments and Technologies (CoNEXT ’18) (Dec. 2018).&lt;/p>
&lt;p>[24] Howell, J., Parno, B., and Douceur, J. R. Embassies: Radically Refactoring the Web. In Proceedings of the 10th USENIX Symposium on Networked Systems Design and Implementation (NSDI’13) (Apr. 2013).&lt;/p>
&lt;p>[25] Hunt, G. C., Larus, J. R., Abadi, M., Aiken, M., Barham, P., Fahndrich, M., Hawblitzel, C., Hodson, O., Levi, S., Murphy, N., Steensgaard, B., Tarditi, D., Wobber, T., and Zill, B. An Overview of the Singularity Project. Tech. Rep. MSR-TR-2005-135, Microsoft Research, Oct. 2005.&lt;/p>
&lt;p>[26] Jia, J., Zhu, Y., Williams, D., Arcangeli, A., Canella, C., Franke, H., Feldman-Fitzthum, T., Skarlatos, D., Gruss, D., and Xu, T. Programmable System Call Security with eBPF. arXiv:2302.10366 (Feb. 2023).&lt;/p>
&lt;p>[27] Kirth, P., Dickerson, M., Crane, S., Larsen, P., Dabrowski, A., Gens, D., Na, Y., Volckaert, S., and Franz, M. PKRU-Safe: Automatically Locking down the Heap between Safe and Unsafe Languages. In Proceedings of the 17th European Conference on Computer Systems (EuroSys’22) (Apr. 2022).&lt;/p>
&lt;p>[28] Kroah-Hartman, G. Cves are dead, long live the cve! &lt;a href="https://kernelrecipes.org/en/2019/talks/cves-are-dead-long-live-the-cve/">https://kernelrecipes.org/en/2019/talks/cves-are-dead-long-live-the-cve/&lt;/a>, Sept. 2019.&lt;/p>
&lt;p>[29] Kuo, H.-C., Chen, K.-H., Lu, Y., Williams, D., Mohan, S., and Xu, T. Verified Programs Can Party: Optimizing Kernel Extensions via PostVerification Merging. In Proceedings of the 17th European Conference on Computer Systems (EuroSys’22) (Apr. 2022).&lt;/p>
&lt;p>[30] Li, H., Gu, J., Xia, Y., Zang, B., and Chen, H. Memory Isolation Mechanism of eBPF Based on PKS Hardware Feature. In Journal of Software (China) (2022), pp. 1–18.&lt;/p>
&lt;p>[31] Li, J., Miller, S., Zhuo, D., Chen, A., Howell, J., and Anderson, T. An Incremental Path towards a Safer OS Kernel. In Proceedings of the 18th Workshop on Hot Topics in Operating Systems (HotOS’21) (June 2021).&lt;/p>
&lt;p>[32] Li, Y. bpf: Fix wrong reg type conversion in release_reference(). &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f1db20814af532f85e091231223e5e4818e8464b">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f1db20814af532f85e091231223e5e4818e8464b&lt;/a>, Nov. 2022.&lt;/p>
&lt;p>[33] Lu, H., Wang, S., Wu, Y., He, W., and Zhang, F. MOAT: Towards Safe BPF Kernel Extension. arXiv:2301.13421 (Mar. 2023).&lt;/p>
&lt;p>[34] Marchevsky, D. bpf: Refcount task stack in bpf_get_task_stack. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=06ab134ce8ecfa5a69e850f88f81c8a4c3fa91df">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=06ab134ce8ecfa5a69e850f88f81c8a4c3fa91df&lt;/a>, Mar. 2021.&lt;/p>
&lt;p>[35] Maxwell, J. bpf: Fix request_sock leak in sk lookup helpers. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3046a827316c0e55fc563b4fb78c93b9ca5c7c37">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3046a827316c0e55fc563b4fb78c93b9ca5c7c37&lt;/a>, June 2022.&lt;/p>
&lt;p>[36] Nakryiko, A. bpf: fix potential 32-bit overflow when accessing ARRAY map element. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=87ac0d600943994444e24382a87aa19acc4cd3d4">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=87ac0d600943994444e24382a87aa19acc4cd3d4&lt;/a>, July 2022.&lt;/p>
&lt;p>[37] Narayanan, V., Huang, T., Detweiler, D., Appel, D., Li, Z., Zellweger, G., and Burtsev, A. RedLeaf: Isolation and Communication in a Safe Operating System. In Proceedings of the 14th USENIX Conference on Operating Systems Design and Implementation (Nov. 2020).&lt;/p>
&lt;p>[38] Nelson, L., Van Geffen, J., Torlak, E., and Wang, X. Specification and Verification in the Field: Applying Formal Methods to BPF Just-inTime Compilers in the Linux Kernel. In Proceedings of the 14th USENIX Conference on Operating Systems Design and Implementation (OSDI’20) (Nov. 2020).&lt;/p>
&lt;p>[39] Nelson, L., Wang, X., and Torlak, E. A proof-carrying approach to building correct and flexible in-kernel verifiers. In Linux Plumbers Conference (Sept. 2021).&lt;/p>
&lt;p>[40] Reid, A. Automatic Rust verification tools (2021). &lt;a href="https://alastairreid.github.io/automatic-rust-verification-tools-2021/">https://alastairreid.github.io/automatic-rust-verification-tools-2021/&lt;/a>, June 2021.&lt;/p>
&lt;p>[41] Scannell, S. Fuzzing for ebpf jit bugs in the linux kernel. &lt;a href="https://scannell.io/posts/ebpf-fuzzing/">https://scannell.io/posts/ebpf-fuzzing/&lt;/a>, 2021.&lt;/p>
&lt;p>[42] Singh, K. bpf: Local storage helpers should check nullness of owner ptr passed. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1a9c72ad4c26821e215a396167c14959cf24a7f1">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1a9c72ad4c26821e215a396167c14959cf24a7f1&lt;/a>, Jan. 2021.&lt;/p>
&lt;p>[43] Singh, K. BPF Signing and IMA integration. &lt;a href="https://lpc.events/event/16/contributions/1357/">https://lpc.events/event/16/contributions/1357/&lt;/a>, Sept. 2022.&lt;/p>
&lt;p>[44] Starovoitov, A. bpf: allow bpf programs to tail-call other bpf programs. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=04fd61ab36ec065e194ab5e74ae34a5240d992bb">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=04fd61ab36ec065e194ab5e74ae34a5240d992bb&lt;/a>, May 2015.&lt;/p>
&lt;p>[45] Starovoitov, A. bpf: introduce function calls (verification). &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f4d7e40a5b7157e1329c3c5b10f60d8289fc2941">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f4d7e40a5b7157e1329c3c5b10f60d8289fc2941&lt;/a>, Dec. 2017.&lt;/p>
&lt;p>[46] Starovoitov, A. bpf: Prevent memory disambiguation attack. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=af86ca4e3088fe5eacf2f7e58c01fa68ca067672">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=af86ca4e3088fe5eacf2f7e58c01fa68ca067672&lt;/a>, May 2018.&lt;/p>
&lt;p>[47] Starovoitov, A. bpf: prevent out-of-bounds speculation. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b2157399cc9898260d6031c5bfe45fe137c1fbe7">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b2157399cc9898260d6031c5bfe45fe137c1fbe7&lt;/a>, Jan. 2018.&lt;/p>
&lt;p>[48] Starovoitov, A. bpf: introduce bpf_spin_lock. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d83525ca62cf8ebe3271d14c36fb900c294274a2">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d83525ca62cf8ebe3271d14c36fb900c294274a2&lt;/a>, Jan. 2019.&lt;/p>
&lt;p>[49] Vernet, D. Long-lived kernel pointers in BPF. &lt;a href="https://lwn.net/Articles/900749/">https://lwn.net/Articles/900749/&lt;/a>, July 2022.&lt;/p>
&lt;p>[50] Vishwanathan, H., Shachnai, M., Narayana, S., and Nagarakatte, S. Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers. In Proceedings of the 2022 IEEE Symposium on Code Generation and Optimization (CGO’22) (Apr. 2022).&lt;/p>
&lt;p>[51] Wang, X., Lazar, D., Zeldovich, N., Chlipala, A., and Tatlock., Z. Jitk: A trustworthy in-kernel interpreter infrastructure. In Proceedings of the 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI’14) (Oct. 2014).&lt;/p>
&lt;p>[52] Zhong, Y., Li, H., Wu, Y. J., Zarkadas, I., Tao, J., Mesterhazy, E., Makris, M., Yang, J., Tai, A., Stutsman, R., and Cidon, A. XRP: In-Kernel storage functions with eBPF. In Proceedings of 16th USENIX Symposium on Operating Systems Design and Implementation (OSDI’22) (July 2022).&lt;/p>
&lt;p>[53] Zhou, Y., Wang, Z., Dharanipragada, S., and Yu, M. Electrode: Accelerating Distributed Protocols with eBPF. In Proceedings of the 20th USENIX Symposium on Networked Systems Design and Implementation (NSDI’23) (Apr. 2023).&lt;/p>
&lt;p>[54] Zingerman, E. bpf: Fix for use-after-free bug in inline_bpf_loop. &lt;a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fb4e3b33e3e7f13befdf9ee232e34818c6cc5fb9">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fb4e3b33e3e7f13befdf9ee232e34818c6cc5fb9&lt;/a>, June 2022.&lt;/p></content></item><item><title>[NOTE] Go Profiling and Observability from Scratch</title><link>https://xujiajiadexiaokeai.github.io/2023-04-10/go-profiling-and-observability-from-scratch/</link><pubDate>Mon, 10 Apr 2023 14:25:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2023-04-10/go-profiling-and-observability-from-scratch/</guid><description>[NOTE] Go Profiling and Observability from Scratch Agenda Scheduling &amp;amp; Memory Management: A simple model Profiling: CPU, Memory, Mutex, Block, Goroutine + Overhead Benchmarks Tracing: Manually, Distributed, Runtime Metrics: Runtime Metrics 3rd party Tools: Linux perf, BPF, Delve,fgprof Scheduling &amp;amp; Memory Management Go&amp;rsquo;s primary job is to multiplex and abstract hardware resources Very similar to an operating system, - it&amp;rsquo;s turtles all the way down Following model recap for some, but perhaps more useful than more complex models usually presented.</description><content>&lt;h1 id="note-go-profiling-and-observability-from-scratch">[NOTE] Go Profiling and Observability from Scratch&lt;/h1>
&lt;h2 id="agenda">Agenda&lt;/h2>
&lt;ul>
&lt;li>Scheduling &amp;amp; Memory Management: A simple model&lt;/li>
&lt;li>Profiling: CPU, Memory, Mutex, Block, Goroutine + Overhead Benchmarks&lt;/li>
&lt;li>Tracing: Manually, Distributed, Runtime&lt;/li>
&lt;li>Metrics: Runtime Metrics&lt;/li>
&lt;li>3rd party Tools: Linux perf, BPF, Delve,fgprof&lt;/li>
&lt;/ul>
&lt;h2 id="scheduling--memory-management">Scheduling &amp;amp; Memory Management&lt;/h2>
&lt;ul>
&lt;li>Go&amp;rsquo;s primary job is to multiplex and abstract hardware resources&lt;/li>
&lt;li>Very similar to an operating system, - it&amp;rsquo;s turtles all the way down&lt;/li>
&lt;li>Following model recap for some, but perhaps more useful than more complex models usually presented.&lt;/li>
&lt;/ul>
&lt;h3 id="scheduling">Scheduling&lt;/h3>
&lt;ul>
&lt;li>Go schedules goroutines onto CPUs (OS Threads)&lt;/li>
&lt;li>Deeply integrated with networking, channels and mutexes&lt;/li>
&lt;li>Scalable to hundred of thousands of goroutines&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="../../img/image-20230410152956115.png" alt="image-20230410152956115">&lt;/p>
&lt;h3 id="memory-management">Memory Management&lt;/h3>
&lt;ul>
&lt;li>Small stack per goroutine (4kB+)&lt;/li>
&lt;li>Big heap, needed for shared data and other reasons&lt;/li>
&lt;li>Stack allocation is very cheap&lt;/li>
&lt;li>Heap allocation and GC is expensive (20%+ CPU Time common)&lt;/li>
&lt;li>Reduce: Turn heap into stack allocs or avoid completely&lt;/li>
&lt;li>Reuse: Reuse heap allocations like structs and buffers&lt;/li>
&lt;li>Recycle: Some GC work is inevitable, it&amp;rsquo;s okay&lt;/li>
&lt;li>Reducing heap allocs speed up unrelated code (GC thrashes CPU Caches)&lt;/li>
&lt;/ul>
&lt;h3 id="memory-management-heap">Memory Management: Heap&lt;/h3>
&lt;ul>
&lt;li>Referenced Allocation (In-Use)&lt;/li>
&lt;li>Unreferenced Allocation (Garbage)&lt;/li>
&lt;/ul>
&lt;h2 id="profiling">Profiling&lt;/h2>
&lt;h3 id="cpu-profiler">CPU Profiler&lt;/h3>
&lt;ul>
&lt;li>Captures: On-CPU time of your code by interrupting the process after every 10ms of CPU Time to take a stack trace.&lt;/li>
&lt;li>Profile Data: Sample count and time spent per stack trace&lt;/li>
&lt;li>Sample Rate: runtime.SetCPUProfileRate(hz)&lt;/li>
&lt;/ul>
&lt;h3 id="cpu-profiler-sigprof-for-every-10ms-of-cpu-time">CPU Profiler: SIGPROF for every 10ms of CPU Time&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// go 1.17.3 src/runtime/signal_unix.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">setProcessCPUPROFILER&lt;/span>(&lt;span style="color:#a6e22e">hz&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">hz&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#75715e">// Enable the Go signal handler if not enabled.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">atomic&lt;/span>.&lt;span style="color:#a6e22e">Cas&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">handlingSig&lt;/span>[&lt;span style="color:#a6e22e">_SIGPROF&lt;/span>], &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;span style="color:#a6e22e">atomic&lt;/span>.&lt;span style="color:#a6e22e">Storeuintptr&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">fwdSig&lt;/span>[&lt;span style="color:#a6e22e">_SIGPROF&lt;/span>], &lt;span style="color:#a6e22e">getsig&lt;/span>(&lt;span style="color:#a6e22e">_SIGPROF&lt;/span>))
&lt;span style="color:#a6e22e">setsig&lt;/span>(&lt;span style="color:#a6e22e">_SIGPROF&lt;/span>, &lt;span style="color:#a6e22e">funcPC&lt;/span>(&lt;span style="color:#a6e22e">sighandler&lt;/span>))
}
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">it&lt;/span> &lt;span style="color:#a6e22e">itimerval&lt;/span>
&lt;span style="color:#a6e22e">it&lt;/span>.&lt;span style="color:#a6e22e">it_interval&lt;/span>.&lt;span style="color:#a6e22e">tv_sec&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#a6e22e">it&lt;/span>.&lt;span style="color:#a6e22e">it_interval&lt;/span>.&lt;span style="color:#a6e22e">set_usec&lt;/span>(&lt;span style="color:#ae81ff">1000000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">hz&lt;/span>)
&lt;span style="color:#a6e22e">it&lt;/span>.&lt;span style="color:#a6e22e">it_value&lt;/span> = &lt;span style="color:#a6e22e">it&lt;/span>.&lt;span style="color:#a6e22e">it_interval&lt;/span>
&lt;span style="color:#a6e22e">setitimer&lt;/span>(&lt;span style="color:#a6e22e">_ITIMER_PROF&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">it&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
} &lt;span style="color:#66d9ef">else&lt;/span> {&lt;span style="color:#f92672">...&lt;/span>}
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sighandler&lt;/span>(&lt;span style="color:#a6e22e">sig&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>, &lt;span style="color:#a6e22e">info&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">siginfo&lt;/span>, &lt;span style="color:#a6e22e">ctxt&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>, &lt;span style="color:#a6e22e">gp&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">g&lt;/span>) {
&lt;span style="color:#a6e22e">_g_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">getg&lt;/span>()
&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sigctxt&lt;/span>{&lt;span style="color:#a6e22e">info&lt;/span>, &lt;span style="color:#a6e22e">ctxt&lt;/span>}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">sig&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">_SIGPROF&lt;/span> {
&lt;span style="color:#a6e22e">sigprof&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">sigpc&lt;/span>(), &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">sigsp&lt;/span>(), &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">siglr&lt;/span>(), &lt;span style="color:#a6e22e">gp&lt;/span>, &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span>
}
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cpu-profiler-add-stacktrace-to-profile">CPU Profiler: Add Stacktrace to Profile&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// go 1.17.3 src/runtime/proc.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">maxCPUProfStack&lt;/span> = &lt;span style="color:#ae81ff">64&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sigprof&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>, &lt;span style="color:#a6e22e">lr&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">gp&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">g&lt;/span>, &lt;span style="color:#a6e22e">mp&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">m&lt;/span>) {
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stk&lt;/span> [&lt;span style="color:#a6e22e">maxCPUProfStack&lt;/span>]&lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">gentraceback&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>, &lt;span style="color:#a6e22e">lr&lt;/span>, &lt;span style="color:#a6e22e">gp&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">stk&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>], len(&lt;span style="color:#a6e22e">stk&lt;/span>), &lt;span style="color:#f92672">...&lt;/span>)
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">cpuprof&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#a6e22e">gp&lt;/span>, &lt;span style="color:#a6e22e">stk&lt;/span>[:&lt;span style="color:#a6e22e">n&lt;/span>])
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cpu-profiler-waiting-for-go-118">CPU Profiler: Waiting for Go 1.18&lt;/h3>
&lt;ul>
&lt;li>setitimer(2) fails to deliver more than 250 signals per second, biases profile to underestimate CPU Spikes, see GH #35057&lt;/li>
&lt;li>Go 1.18 patch from Rhys Hiltner will fix this and thread bias issues such as GH #14434 by using timer_create(2)&lt;/li>
&lt;/ul>
&lt;h3 id="block-profiler">Block Profiler&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Captures: Off-CPU time waiting on channels and mutexes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>But not: Sleep, I/O, Syscalls, GC, etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Profile Data: Cumulative contentions and delays per stack trace&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">stack trace&lt;/th>
&lt;th style="text-align:center">contentions/count&lt;/th>
&lt;th style="text-align:center">delay/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">main; foo;runtime.chansend1&lt;/td>
&lt;td style="text-align:center">22820&lt;/td>
&lt;td style="text-align:center">867549417&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">main; foo;bar;tuntime.chanrecv1&lt;/td>
&lt;td style="text-align:center">22748&lt;/td>
&lt;td style="text-align:center">453510869&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">main;foobar;sync.(*Mutex).Lock&lt;/td>
&lt;td style="text-align:center">795&lt;/td>
&lt;td style="text-align:center">5351086&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>Sample Rate: runtime.SetBlockProfileRate(rate)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="mutex-profiler">Mutex Profiler&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Captures: Off-CPU time waiting on mutexes (not channels)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Profile data: Cumulative contentions and delays per stack trace&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">stack trace&lt;/th>
&lt;th style="text-align:center">contentions/count&lt;/th>
&lt;th style="text-align:center">delay/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">main; foo; sync.(*Mutex).Unlock&lt;/td>
&lt;td style="text-align:center">22820&lt;/td>
&lt;td style="text-align:center">867549417&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">main; foo;bar;sync.(*Mutex).Unlock&lt;/td>
&lt;td style="text-align:center">22748&lt;/td>
&lt;td style="text-align:center">453510869&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">main;foobar;sync.(*Mutex).Unlock&lt;/td>
&lt;td style="text-align:center">795&lt;/td>
&lt;td style="text-align:center">5351086&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>Rate: runtime.SetMutexProfileFraction(rate)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="block-vs-mutex">Block vs Mutex&lt;/h3>
&lt;ul>
&lt;li>Block seems like a superset of mutex profile, but it&amp;rsquo;s not:&lt;/li>
&lt;li>&lt;strong>Mutex profile&lt;/strong> shows what code is &lt;strong>doing the blocking&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Block profile&lt;/strong> show what code is &lt;strong>getting blocked&lt;/strong>&lt;/li>
&lt;li>Both perspectives are useful, so enable both profilers&lt;/li>
&lt;/ul>
&lt;h3 id="quick-note-on-time">Quick Note on Time&lt;/h3>
&lt;p>&lt;img src="../../img/image-20230410194639932.png" alt="image-20230410194639932">&lt;/p>
&lt;p>On-CPU Time &amp;gt; Real Time&lt;/p>
&lt;p>&lt;img src="../../img/image-20230410194928468.png" alt="image-20230410194928468">&lt;/p>
&lt;ul>
&lt;li>Goroutine Time: Cumulative (end - start) time of all goroutines&lt;/li>
&lt;li>CPU Time: CPU tiem circle can be larger than Real time circle&lt;/li>
&lt;li>Mutex Time&lt;/li>
&lt;li>Block Time: Block time is a superset of mutex time (but with different call stacks)&lt;/li>
&lt;li>Untracked Off-CPU Waiting Time: Profiling Blindspot!&lt;/li>
&lt;/ul>
&lt;h3 id="memory-profiling">Memory Profiling&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Profile Data: Cumulative allocs and inuse per stack trace&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>alloc_objects/count&lt;/th>
&lt;th>alloc_space/bytes&lt;/th>
&lt;th>inuse_objects/count&lt;/th>
&lt;th>inuse_space/bytes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main; foo&lt;/td>
&lt;td>5&lt;/td>
&lt;td>120&lt;/td>
&lt;td>2&lt;/td>
&lt;td>48&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foo;bar&lt;/td>
&lt;td>3&lt;/td>
&lt;td>768&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar&lt;/td>
&lt;td>4&lt;/td>
&lt;td>512&lt;/td>
&lt;td>1&lt;/td>
&lt;td>128&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>Samples captured every 512kB of malloc() and when those objects are free()&amp;rsquo;d by the GC later on (inuse = allocs - frees)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Sample Rate: runtime.memProfileRate = rate (default = 512kB)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;alice&amp;#34;&lt;/span>}
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;User: %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">user&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">LEAQ type.&amp;quot;&amp;quot;.User(SB), AX
PCDATA $1, $0
NOP
CALL runtime.newobject(SB)
MOVQ $5, 8(AX)
LEAQ go.string.&amp;quot;alice&amp;quot;(SB), CX
MOVQ CX, (AX)
&lt;/code>&lt;/pre>&lt;h3 id="goroutine-profiling">Goroutine Profiling&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Profile Data: Goroutine count per stack trace&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>goroutine/count&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main;foo&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main; foo;bar&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>O(N) &lt;strong>Stop-The-World&lt;/strong> where N is the total number of goroutines (cause tail latency)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>No Sampling Mechanism&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use Cases&lt;/strong>: Detect goroutine leaks and diagnose hanging programs(debug=2)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="tracing">Tracing&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Tracing&lt;/strong>: Recording of time-stamped events&lt;/p>
&lt;p>Distinction with logging can be muddy, depends on context&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Distributed Tracing&lt;/strong>: Tracing requests through multiple services&lt;/p>
&lt;p>Highly recommended to understand performance from system perspective&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Runtime Tracing&lt;/strong>: Go&amp;rsquo;s built-in tracer&lt;/p>
&lt;p>Can shine a light on profiling blindspots (e.g. I/O, Sleep, GC, Scheduler Backlog)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Tracing Profiler&lt;/strong>: Tracing every function call&lt;/p>
&lt;p>Doesn&amp;rsquo;t currently exist for Go&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="runtime-tracer">Runtime Tracer&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Traces Scheduler, GC, Contentions, Syscall, etc.&lt;/p>
&lt;p>see src/runtime/trace.go for a list of events&lt;/p>
&lt;/li>
&lt;li>
&lt;p>High-overhead firehose that produces a lot of data&lt;/p>
&lt;/li>
&lt;li>
&lt;p>But fantastic way to track down latency when nothing else seems to have the answer&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="profiling-and-tracing-overhead-analysis">Profiling and Tracing Overhead Analysis&lt;/h3>
&lt;ul>
&lt;li>Run different workloads in a loop for 1 minute with and without various profilers enabled, measure avg latency&lt;/li>
&lt;li>Repeat each experiment 5 times&lt;/li>
&lt;li>Performed on a AWS c5.4xlarge machine(6h total duration)&lt;/li>
&lt;li>This is hard! Early sneak peek, bad env, bad stats, naive workloads, do not trst too much!&lt;/li>
&lt;/ul>
&lt;h3 id="overhead-analysis-error-sources">Overhead Analysis: Error Sources&lt;/h3>
&lt;ul>
&lt;li>Dynamic frequency scaling (Turbo Boost)&lt;/li>
&lt;li>Noisy Nerghbors&lt;/li>
&lt;li>Human error&lt;/li>
&lt;li>Check for new results by the time you watch this&lt;/li>
&lt;li>But: Very low overhead for cpu, memory, mutex and block profiler for non-pathological workloads&lt;/li>
&lt;/ul>
&lt;h2 id="metrics">Metrics&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Use runtime/metrics (Go 1.16+), highlights: (*mB ~ 100mB)&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>metric&lt;/th>
&lt;th>description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>/gc/pauses:seconds&lt;/strong>&lt;/td>
&lt;td>Stop-the-world pause latency histogram&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>/sched/latencies:seconds&lt;/strong>&lt;/td>
&lt;td>Goroutines waiting in runnable state latency histogram&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/sched/goroutines:goroutines&lt;/td>
&lt;td>Number of live goroutines&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/memory/classes/heap/objects:bytes&lt;/td>
&lt;td>Current heap memory usage&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/memory/classes/heap/stacksbytes&lt;/td>
&lt;td>Current stack memory usage&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>/memory/classes/profiling/buckets:bytes&lt;/strong>&lt;/td>
&lt;td>Memory used by internal profiling hash maps&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>Recommendation: Capture all runtime/metrics&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="3rd-party-tools">3rd Party Tools&lt;/h2>
&lt;ul>
&lt;li>Linux Perf&lt;/li>
&lt;li>bpftrace&lt;/li>
&lt;li>delve&lt;/li>
&lt;li>fgprof&lt;/li>
&lt;/ul>
&lt;h2 id="scheduling--execution-observability">Scheduling / Execution Observability&lt;/h2>
&lt;ul>
&lt;li>Profilers: CPU, Block, Mutex, Goroutine&lt;/li>
&lt;li>Tracing: Runtime Execution Tracer, Distributed Tracing&lt;/li>
&lt;li>Metrics: Scheduler Latency, Goroutine Count&lt;/li>
&lt;li>Compile Time: Function Inlining (go build -gcflags='-m')&lt;/li>
&lt;/ul>
&lt;h2 id="memory-management-observability">Memory Management Observability&lt;/h2>
&lt;ul>
&lt;li>Profilers: Memory Profiler&lt;/li>
&lt;li>Tracing: Runtime Tracing (GC Events)&lt;/li>
&lt;li>Metrics: GC counters, GC pause times, Heap Stats, Stack Stats&lt;/li>
&lt;li>Compile Time: Escape Analysis (go build -gcflags='-m')&lt;/li>
&lt;/ul>
&lt;h2 id="recap">Recap&lt;/h2>
&lt;ul>
&lt;li>Go runtime offers great observability out of the box&lt;/li>
&lt;li>Most tools play nice with production workloads&lt;/li>
&lt;li>3rd party tools and custom instrumentation can close the gaps&lt;/li>
&lt;/ul>
&lt;h2 id="source">Source&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7hg4T2Qqowk">GopherCon 2021: Felix Geisendörfer - Go Profiling and Observability from Scratch&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>[NOTE] Building a Go profiler using Go</title><link>https://xujiajiadexiaokeai.github.io/2023-04-10/building-a-go-profiler-using-go/</link><pubDate>Mon, 10 Apr 2023 09:35:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2023-04-10/building-a-go-profiler-using-go/</guid><description>[NOTE] Building a Go profiler using Go What is profilling A form of dynamic program analysis that measures resource consumption
For example:
the space (memory) time complexity of a program (CPU) usage of instructions frequency and duration of function calls Why use profiling Profiling is about how do we know:
What&amp;rsquo;s worth optimizing? What needs optimization? How to profiling Tracing Recording each and every event constantly High costs Sampling Sample for a certain duration Eg.</description><content>&lt;h1 id="note-building-a-go-profiler-using-go">[NOTE] Building a Go profiler using Go&lt;/h1>
&lt;h2 id="what-is-profilling">What is profilling&lt;/h2>
&lt;p>A form of dynamic program analysis that &lt;strong>measures&lt;/strong> resource consumption&lt;/p>
&lt;p>For example:&lt;/p>
&lt;ul>
&lt;li>the &lt;strong>space&lt;/strong> (memory)&lt;/li>
&lt;li>&lt;strong>time complexity&lt;/strong> of a program (CPU)&lt;/li>
&lt;li>&lt;strong>usage of instructions&lt;/strong>&lt;/li>
&lt;li>&lt;strong>frequency&lt;/strong> and &lt;strong>duration&lt;/strong> of function calls&lt;/li>
&lt;/ul>
&lt;h2 id="why-use-profiling">Why use profiling&lt;/h2>
&lt;p>Profiling is about how do we know:&lt;/p>
&lt;ul>
&lt;li>What&amp;rsquo;s worth optimizing?&lt;/li>
&lt;li>What needs optimization?&lt;/li>
&lt;/ul>
&lt;h2 id="how-to-profiling">How to profiling&lt;/h2>
&lt;ul>
&lt;li>Tracing
&lt;ul>
&lt;li>Recording each and every event constantly&lt;/li>
&lt;li>High costs&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Sampling
&lt;ul>
&lt;li>Sample for a certain duration
&lt;ul>
&lt;li>Eg. 10 seconds&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Periodically observe function call stack
&lt;ul>
&lt;li>Eg. 100x per second&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Low overhead
&lt;ul>
&lt;li>&amp;lt;0.5% CPU&lt;/li>
&lt;li>~4MB memory&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="tiny-profiler">Tiny Profiler&lt;/h2>
&lt;ul>
&lt;li>A proof-of-concept profiler&lt;/li>
&lt;li>Profile all Go processes on a machine&lt;/li>
&lt;li>Produce pprof formatted profiles every 10s&lt;/li>
&lt;/ul>
&lt;h2 id="continuous-profiling">Continuous Profiling&lt;/h2>
&lt;ul>
&lt;li>pprof creates profile samples&lt;/li>
&lt;li>We want to sample every so often&lt;/li>
&lt;li>Little overhead due to sampling&lt;/li>
&lt;li>We hope to get profiles right before OOMs&lt;/li>
&lt;li>Automatically collect profiles rather than by hand&lt;/li>
&lt;/ul>
&lt;h2 id="source">Source&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=OlHQ6gkwqyA">GopherCon Europe 2022: Kemal Akkoyun - Building a Go Profiler Using Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36575.pdf">Google-Wide Profiling: A Continuous Profiling Infrastructure For Data Centers&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>[NOTE] Developing eBPF profiler for polyglot cloud-native applications</title><link>https://xujiajiadexiaokeai.github.io/2023-04-09/developing-ebpf-profiler-for-polyglot-cloud-native-applications/</link><pubDate>Sun, 09 Apr 2023 14:15:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2023-04-09/developing-ebpf-profiler-for-polyglot-cloud-native-applications/</guid><description>[NOTE] Developing eBPF profiler for polyglot cloud-native applications Agenda Infrastructure-wide profilers Low level ecosystem Stack unwinding/walking in the Linux Kernel Building profilers using BPF Walking user stacks(without frame pointers) Future work Profilers for the cloud native environment Discovery mechanism for the targets
-&amp;gt; Mechanism to collect stack traces(kernel, userspace)
-&amp;gt; Profile formats
-&amp;gt; Async symbolization &amp;amp; visualization
Low level ecosystem ELF and DWARF Executable Linkable format -ELF for obj file, executable program, shared object etc DWARF - widely used debugging format CIE - Common information Entry Tools to read ELF and/or DWARF information readily, objdump, elfutils, llvm-dwarfdump gcc also has -g option Stacktraces and x86_64 ABI What collection stack traces involve Kernel stacks Application stacks Direction of stack growth So what are stack pointers, where do they come form $rbp, $rsp &amp;amp; $rip registers $rbp: address of the base of the previous stack frame $rsp: Top of the stack, local variables Generally previous value of rsp is where FP is stored $rip: Holds the pc for the currently executing function Frame pointers are often disabled Increased binary size -&amp;gt; less i-cache hits 1 less rigister available Cons of disabling frame pointers Walking stack traces becomes more expensive Less accuracy Way more work ofr compiler / debugger / profiler developers This information is large The reality Frame pointer believers Golang &amp;gt;= 1.</description><content>&lt;h1 id="note-developing-ebpf-profiler-for-polyglot-cloud-native-applications">[NOTE] Developing eBPF profiler for polyglot cloud-native applications&lt;/h1>
&lt;h2 id="agenda">Agenda&lt;/h2>
&lt;ul>
&lt;li>Infrastructure-wide profilers&lt;/li>
&lt;li>Low level ecosystem&lt;/li>
&lt;li>Stack unwinding/walking in the Linux Kernel&lt;/li>
&lt;li>Building profilers using BPF&lt;/li>
&lt;li>Walking user stacks(without frame pointers)&lt;/li>
&lt;li>Future work&lt;/li>
&lt;/ul>
&lt;h2 id="profilers-for-the-cloud-native-environment">Profilers for the cloud native environment&lt;/h2>
&lt;p>Discovery mechanism for the targets&lt;/p>
&lt;p>-&amp;gt; Mechanism to collect stack traces(kernel, userspace)&lt;/p>
&lt;p>-&amp;gt; Profile formats&lt;/p>
&lt;p>-&amp;gt; Async symbolization &amp;amp; visualization&lt;/p>
&lt;h2 id="low-level-ecosystem">Low level ecosystem&lt;/h2>
&lt;h3 id="elf-and-dwarf">ELF and DWARF&lt;/h3>
&lt;ul>
&lt;li>Executable Linkable format -ELF
&lt;ul>
&lt;li>for obj file, executable program, shared object etc&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DWARF - widely used debugging format
&lt;ul>
&lt;li>CIE - Common information Entry&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Tools to read ELF and/or DWARF information
&lt;ul>
&lt;li>readily, objdump, elfutils, llvm-dwarfdump&lt;/li>
&lt;li>gcc also has -g option&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="stacktraces-and-x86_64-abi">Stacktraces and x86_64 ABI&lt;/h3>
&lt;ul>
&lt;li>What collection stack traces involve
&lt;ul>
&lt;li>Kernel stacks&lt;/li>
&lt;li>Application stacks&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Direction of stack growth&lt;/li>
&lt;li>So what are stack pointers, where do they come form&lt;/li>
&lt;/ul>
&lt;h3 id="rbp-rsp--rip-registers">$rbp, $rsp &amp;amp; $rip registers&lt;/h3>
&lt;ul>
&lt;li>$rbp: address of the base of the previous stack frame&lt;/li>
&lt;li>$rsp: Top of the stack, local variables
&lt;ul>
&lt;li>Generally previous value of rsp is where FP is stored&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>$rip: Holds the pc for the currently executing function&lt;/li>
&lt;/ul>
&lt;h3 id="frame-pointers-are-often-disabled">Frame pointers are often disabled&lt;/h3>
&lt;ul>
&lt;li>Increased binary size -&amp;gt; less i-cache hits&lt;/li>
&lt;li>1 less rigister available&lt;/li>
&lt;/ul>
&lt;h3 id="cons-of-disabling-frame-pointers">Cons of disabling frame pointers&lt;/h3>
&lt;ul>
&lt;li>Walking stack traces becomes more expensive&lt;/li>
&lt;li>Less accuracy&lt;/li>
&lt;li>Way more work ofr compiler / debugger / profiler developers&lt;/li>
&lt;li>This information is large&lt;/li>
&lt;/ul>
&lt;h3 id="the-reality">The reality&lt;/h3>
&lt;h3 id="frame-pointer-believers">Frame pointer believers&lt;/h3>
&lt;ul>
&lt;li>Golang &amp;gt;= 1.7&lt;/li>
&lt;li>MacOS&lt;/li>
&lt;li>The Linux Kernel(*):
&lt;ul>
&lt;li>CONFIG_UNWINDER_FRAME_POINTER and CONFIG_UNWINDER_ORC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="stack-unwinding-in-the-linux-kernel-wo-fp">Stack unwinding in the Linux kernel w/o fp&lt;/h3>
&lt;ul>
&lt;li>ORC (CONFIG_UNWINDER_ORC x86_64 only)&lt;/li>
&lt;li>Doesn&amp;rsquo;t rely on .debug_frame/.eh_frame&lt;/li>
&lt;li>Enabled by some of the major cloud vendors&lt;/li>
&lt;/ul>
&lt;h3 id="unwinding-the-stack-without-frame-pointers">Unwinding the stack without frame pointers&lt;/h3>
&lt;ul>
&lt;li>DWARF unwind information
&lt;ul>
&lt;li>.eh_frame&lt;/li>
&lt;li>.debug_frame&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Synthesizing them from object code&lt;/li>
&lt;li>Guessing which stack vlues are return addresses&lt;/li>
&lt;/ul>
&lt;h3 id="eh_frame---unwind-tables">.eh_frame - unwind tables&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ readelf -wF ./test_binary
&lt;/code>&lt;/pre>&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">LOC&lt;/th>
&lt;th style="text-align:center">CFA&lt;/th>
&lt;th style="text-align:center">rbp&lt;/th>
&lt;th style="text-align:center">ra&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">00000000004011f0&lt;/td>
&lt;td style="text-align:center">rsp+8&lt;/td>
&lt;td style="text-align:center">u&lt;/td>
&lt;td style="text-align:center">c-8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">00000000004011f1&lt;/td>
&lt;td style="text-align:center">rsp+16&lt;/td>
&lt;td style="text-align:center">c-16&lt;/td>
&lt;td style="text-align:center">c-8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">00000000004011f4&lt;/td>
&lt;td style="text-align:center">rbp+16&lt;/td>
&lt;td style="text-align:center">c-16&lt;/td>
&lt;td style="text-align:center">c-8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">0000000000401242&lt;/td>
&lt;td style="text-align:center">rsp+8&lt;/td>
&lt;td style="text-align:center">c-16&lt;/td>
&lt;td style="text-align:center">c-8&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="eh_frame---generating-unwind-tables">.eh_frame - generating unwind tables&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ readelf --debug-dump&lt;span style="color:#f92672">=&lt;/span>frames ./test_binary
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="stack-unwinding-with-ebpf">Stack unwinding with eBPF&lt;/h2>
&lt;h3 id="with-frame-pointers">With frame pointers&lt;/h3>
&lt;pre tabindex="0">&lt;code>user_stack = map&amp;lt;stack_id, array&amp;lt;addresses&amp;gt;&amp;gt;
add_stack bumps map&amp;lt;stack_id, count_t&amp;gt;
stack_id = bpd_get_stackid(ctx, &amp;amp;user_stacks, BPF_F_USER_STACK);
add_stack(stack_id);
&lt;/code>&lt;/pre>&lt;h3 id="without-frame-pointers">Without frame pointers&lt;/h3>
&lt;ul>
&lt;li>BPF code: ~250 lines of C&lt;/li>
&lt;li>DWARF unwind info parser and evaluator: &amp;gt;1k lines of Go&lt;/li>
&lt;/ul>
&lt;h3 id="unwinding-wo-frame-pointers---architecture">Unwinding w/o frame pointers - architecture&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;pre tabindex="0">&lt;code>struct unwind_row {
u64 program_counter;
type_t previous_rsp;
type_t previous_rbp;
}
&lt;/code>&lt;/pre>&lt;h3 id="unwinding-wo-frame-pointers---unwind-table-gen">Unwinding w/o frame pointers - unwind table gen&lt;/h3>
&lt;ul>
&lt;li>.eh_frame / .debug_frame
&lt;ul>
&lt;li>Parse&lt;/li>
&lt;li>Evaluate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="unwinding-wo-frame-pointers---bpf">Unwinding w/o frame pointers - BPF&lt;/h3>
&lt;ul>
&lt;li>Find the unwind table for the current process&lt;/li>
&lt;li>While main isn&amp;rsquo;t reached:
&lt;ul>
&lt;li>Append the program counter ($rip) to the walked stack&lt;/li>
&lt;li>Find the unwind row for the current program counter&lt;/li>
&lt;li>Restore registers for the provious frame
&lt;ul>
&lt;li>Return address $rip&lt;/li>
&lt;li>Stack pointer $rsp&lt;/li>
&lt;li>And $rbp, too&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Efficiently finding the unwind data for a program counter&lt;/li>
&lt;li>Fun to implement in BPF&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">find_offset_for_pc&lt;/span>(__u32 index, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>data) {
&lt;span style="color:#66d9ef">struct&lt;/span> callback_ctx &lt;span style="color:#f92672">*&lt;/span>ctx &lt;span style="color:#f92672">=&lt;/span> data;
&lt;span style="color:#66d9ef">if&lt;/span> (ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>left &lt;span style="color:#f92672">&amp;gt;=&lt;/span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>right) {
LOG(&lt;span style="color:#e6db74">&amp;#34;.done&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
u32 mid &lt;span style="color:#f92672">=&lt;/span> (ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>left &lt;span style="color:#f92672">+&lt;/span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>right) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#75715e">// Appease the verifier.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (mid &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> mid &lt;span style="color:#f92672">&amp;lt;=&lt;/span> MAX_UNWIND_TABLE_SIZE) {
LOG(&lt;span style="color:#e6db74">&amp;#34;.should never happen&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span> (ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>table&lt;span style="color:#f92672">-&lt;/span>rows[mid].pc &lt;span style="color:#f92672">&amp;lt;=&lt;/span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pc) {
ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>found &lt;span style="color:#f92672">=&lt;/span> mid;
ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>left &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
} &lt;span style="color:#66d9ef">else&lt;/span> {
ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>right &lt;span style="color:#f92672">=&lt;/span> mid;
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="unwinding-wo-frame-pointers---future-work">Unwinding w/o frame pointers - Future work&lt;/h3>
&lt;ul>
&lt;li>Testing more complex binaries&lt;/li>
&lt;li>arm64 support&lt;/li>
&lt;li>Static table size&lt;/li>
&lt;li>But we know we will hit limits&lt;/li>
&lt;li>Reduce minimum required kernel version&lt;/li>
&lt;li>Engage with various communities&lt;/li>
&lt;/ul>
&lt;h1 id="sources">Sources&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Gr1rrSzvqfg">https://www.youtube.com/watch?v=Gr1rrSzvqfg&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>[Note]Strong Consistency with Raft and SQLite</title><link>https://xujiajiadexiaokeai.github.io/2023-03-31/strong-consistency-with-raft-and-sqlite/</link><pubDate>Fri, 31 Mar 2023 10:30:15 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2023-03-31/strong-consistency-with-raft-and-sqlite/</guid><description>[Note]Strong Consistency with Raft and SQLite https://blog.sqlitecloud.io/strong-consistency-with-raft-and-sqlite
Central Database vs Distributed Database Central Database Advantage: It is consistent and up-to-date by default Only one source of truth Disadvantage: Single point of failure Become overwhelemd as the amount of data grows Performance issues Slower response times Distributed Database Advantage: Scalability High availability Localized access Improve response times and reduce network latency Lower cost Can be built using commodity hardware Challenge in Distributed Database maintain data consistency across multiple nodes</description><content>&lt;h1 id="notestrong-consistency-with-raft-and-sqlite">[Note]Strong Consistency with Raft and SQLite&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://blog.sqlitecloud.io/strong-consistency-with-raft-and-sqlite">https://blog.sqlitecloud.io/strong-consistency-with-raft-and-sqlite&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="central-database-vs-distributed-database">Central Database vs Distributed Database&lt;/h2>
&lt;h3 id="central-database">Central Database&lt;/h3>
&lt;ul>
&lt;li>Advantage:
&lt;ul>
&lt;li>It is consistent and up-to-date by default&lt;/li>
&lt;li>Only one source of truth&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Disadvantage:
&lt;ul>
&lt;li>Single point of failure&lt;/li>
&lt;li>Become overwhelemd as the amount of data grows&lt;/li>
&lt;li>Performance issues&lt;/li>
&lt;li>Slower response times&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="distributed-database">Distributed Database&lt;/h3>
&lt;ul>
&lt;li>Advantage:
&lt;ul>
&lt;li>Scalability&lt;/li>
&lt;li>High availability&lt;/li>
&lt;li>Localized access
Improve response times and reduce network latency&lt;/li>
&lt;li>Lower cost
Can be built using commodity hardware&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="challenge-in-distributed-database">Challenge in Distributed Database&lt;/h2>
&lt;p>&lt;strong>maintain data consistency across multiple nodes&lt;/strong>&lt;/p>
&lt;p>Must be use a strong consistency model&lt;/p>
&lt;p>SQLite Cloud guarantees strong consistency and uses the Raft consensus algorithm under the hood&lt;/p>
&lt;h2 id="raft">Raft&lt;/h2>
&lt;ul>
&lt;li>A distrubuted consensus algorithm&lt;/li>
&lt;li>Be designed to help manage replicated logs&lt;/li>
&lt;li>Works by ensuring that all nodes in a distributed system agree on the same log of commands or events&lt;/li>
&lt;/ul>
&lt;h2 id="how-does-raft-work">How does Raft work?&lt;/h2>
&lt;ul>
&lt;li>Leader manage all log
&lt;ul>
&lt;li>Works by electing a leader node that manages the replicated log&lt;/li>
&lt;li>Leader node receives commands and replicates them across all nodes&lt;/li>
&lt;li>Ensures that all nodes have the same log of commands by using a series of communication messages called &amp;ldquo;log entries&amp;rdquo;&lt;/li>
&lt;li>Each log entry contains a command or event that is appended to the log of each node&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Divide time into terms
&lt;ul>
&lt;li>Each term begins with a leader election&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Log replication
&lt;ul>
&lt;li>Leader sends log entries to all other nodes&lt;/li>
&lt;li>A majority vote(quorum)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="how-to-achieve-strong-consistency-with-raft">How To Achieve Strong Consistency with Raft?&lt;/h2>
&lt;ul>
&lt;li>Leader election&lt;/li>
&lt;li>Log replication&lt;/li>
&lt;li>Commit mechanisms
Ensure that log entries are executed in the same order on all nodes in the system&lt;/li>
&lt;/ul>
&lt;h2 id="what-to-distribute-with-sqlite">What to distribute with SQLite?&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Raw SQL statement
Some database engines distribute raw SQL statement.&lt;/p>
&lt;p>It will produce different outputs on different nodes by using &lt;strong>non-deterministic SQL&lt;/strong> functions.&lt;/p>
&lt;p>How to immune the side effects of non-deterministic SQL statements&lt;/p>
&lt;ul>
&lt;li>Use severe limitations&lt;/li>
&lt;li>Use complex SQL parsers&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ChangeSet
SQLite Cloud only distribute hte changeset derived from executing the SQL statement in one node&lt;/p>
&lt;p>They distribute the result of the statement (plus some other metadata)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;table&amp;#34;&lt;/span>: &lt;span style="color:#960050;background-color:#1e0010">foo&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;data&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;col1&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">8875612685081594789&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;col2&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10:57:34&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;col3&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2023-03-21&amp;#34;&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul></content></item><item><title>为什么select仅能作用于管道?</title><link>https://xujiajiadexiaokeai.github.io/2022-11-17/why-select-only-work-on-channel/</link><pubDate>Thu, 17 Nov 2022 19:15:45 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-11-17/why-select-only-work-on-channel/</guid><description>select的特性 case的执行 具体执行那个case,取决于函数传入的管道
管道没有缓冲区 有缓冲区并且还可以塞数据 有缓冲区但缓冲区已满 有缓冲区且已有部分数据 返回值 可以在case中声明变量并赋值
default default不能处理管道读写 当所有case被阻塞,执行default default是特殊的case
使用案例 永久阻塞 使用select阻塞main函数
func main() { server := webhooktesting.NewTestServer(nil) server.StartTLS() fmt.Println(&amp;#34;serving on&amp;#34;, server.URL) select {} // 没有case和default ,main()永久阻塞 } 快速检错 当使用管道来传输error时, 可以使用select快速检查管道中是否有error
errCh := make(chan error, active) jm.deleteJobPods(&amp;amp;job, activePods, errCh) // 传入chan用于记录error select { case manageJobErr = &amp;lt;-errCh: if manageJobErr != nil { break } default: // 没有error, 结束 } 限时等待 当使用管道管理函数上下文时, 可以使用select创建具有时效性的管道
func waitForStopOrTimeout(stopCh &amp;lt;-chan struct{}, timeout time.</description><content>&lt;h1 id="select的特性">select的特性&lt;/h1>
&lt;h2 id="case的执行">case的执行&lt;/h2>
&lt;p>具体执行那个case,取决于函数传入的管道&lt;/p>
&lt;ul>
&lt;li>管道没有缓冲区&lt;/li>
&lt;li>有缓冲区并且还可以塞数据&lt;/li>
&lt;li>有缓冲区但缓冲区已满&lt;/li>
&lt;li>有缓冲区且已有部分数据&lt;/li>
&lt;/ul>
&lt;h2 id="返回值">返回值&lt;/h2>
&lt;p>可以在case中声明变量并赋值&lt;/p>
&lt;h2 id="default">default&lt;/h2>
&lt;p>default不能处理管道读写
当所有case被阻塞,执行default
default是特殊的case&lt;/p>
&lt;h1 id="使用案例">使用案例&lt;/h1>
&lt;h2 id="永久阻塞">永久阻塞&lt;/h2>
&lt;p>使用select阻塞main函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">webhooktesting&lt;/span>.&lt;span style="color:#a6e22e">NewTestServer&lt;/span>(&lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">StartTLS&lt;/span>()
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;serving on&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">URL&lt;/span>)
&lt;span style="color:#66d9ef">select&lt;/span> {} &lt;span style="color:#75715e">// 没有case和default ,main()永久阻塞
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快速检错">快速检错&lt;/h2>
&lt;p>当使用管道来传输error时, 可以使用select快速检查管道中是否有error&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">errCh&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>, &lt;span style="color:#a6e22e">active&lt;/span>)
&lt;span style="color:#a6e22e">jm&lt;/span>.&lt;span style="color:#a6e22e">deleteJobPods&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">job&lt;/span>, &lt;span style="color:#a6e22e">activePods&lt;/span>, &lt;span style="color:#a6e22e">errCh&lt;/span>) &lt;span style="color:#75715e">// 传入chan用于记录error
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">select&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">manageJobErr&lt;/span> = &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">errCh&lt;/span>:
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">manageJobErr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">break&lt;/span>
}
&lt;span style="color:#66d9ef">default&lt;/span>: &lt;span style="color:#75715e">// 没有error, 结束
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="限时等待">限时等待&lt;/h2>
&lt;p>当使用管道管理函数上下文时, 可以使用select创建具有时效性的管道&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">waitForStopOrTimeout&lt;/span>(&lt;span style="color:#a6e22e">stopCh&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}, &lt;span style="color:#a6e22e">timeout&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>) &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{} {
&lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{})
&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;span style="color:#66d9ef">select&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">stopCh&lt;/span>:
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">After&lt;/span>(&lt;span style="color:#a6e22e">timeout&lt;/span>): &lt;span style="color:#75715e">// 管道会在指定时间内关闭
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
close(&lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span>)
}()
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="实现原理">实现原理&lt;/h1>
&lt;ul>
&lt;li>为什么每个case语句只能处理一个管道?&lt;/li>
&lt;li>为什么case语句执行顺序随机(多个case都就绪的情况下)?&lt;/li>
&lt;li>为什么case语句向值为nil的管道中写数据不会触发panic?&lt;/li>
&lt;/ul>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">scase&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">hchan&lt;/span> &lt;span style="color:#75715e">// 操作的管道
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">kind&lt;/span> &lt;span style="color:#a6e22e">unit16&lt;/span> &lt;span style="color:#75715e">// case类型
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">elem&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span> &lt;span style="color:#75715e">// 指向数据存放位置的指针
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">...&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>管道
因为每个scase中只有一个管道, 这决定了一个case只能处理一个管道
编译器在处理case语句时,如果case语句中没有管道操作(不能处理成scase对象),则会给出编译错误:&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>select case must be receive, send or assign recv
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>类型&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">const&lt;/span> (
&lt;span style="color:#a6e22e">caseNil&lt;/span> = &lt;span style="color:#66d9ef">iota&lt;/span>
&lt;span style="color:#a6e22e">caseRecv&lt;/span>
&lt;span style="color:#a6e22e">caseSend&lt;/span>
&lt;span style="color:#a6e22e">caseDefault&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>caseNil: 表示其操作的管道值为nil, 由于nil管道既不可读,也不可写,所以永远不会命中
所以在case语句中向值为nil的管道中写数据不会触发panic的原因&lt;/li>
&lt;li>caseRecv: 从管道中读数据&lt;/li>
&lt;li>caseSend: 向管道中写数据&lt;/li>
&lt;li>caseDeafult: 不会操作管道,每个select中仅可存在一个, 可出现在任意位置&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>数据
scase.elem表示数据存放的地址&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>caseRecv: 读出的数据存放的地址&lt;/li>
&lt;li>caseSend: 将写入管道的数据存放的地址&lt;/li>
&lt;/ul>
&lt;h2 id="实现逻辑">实现逻辑&lt;/h2>
&lt;p>&lt;code>selectgo()&lt;/code> 用于处理select语句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">selectgo&lt;/span>(&lt;span style="color:#a6e22e">cas0&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">scase&lt;/span>, &lt;span style="color:#a6e22e">order0&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">uint16&lt;/span>, &lt;span style="color:#a6e22e">ncases&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) (&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>selectgo()&lt;/code>函数会从一组case中挑选一个case,并返回命中case的下标,对于caseRecv的case,还会返回是否读取成功
当所有case都不可能就绪时,selectgo()陷入永久阻塞,此时函数不会返回&lt;/p>
&lt;h3 id="cas0">cas0&lt;/h3>
&lt;p>编译器会将select中的case语句存储在一个数组中,cas0保存这个数组的地址&lt;/p>
&lt;h3 id="ncases">ncases&lt;/h3>
&lt;p>ncases表示case的个数(包活default),即cas0数组的长度&lt;/p>
&lt;h3 id="order0">order0&lt;/h3>
&lt;p>order0 为一个整型数组的地址,其长度为case格式的2倍.
order0数组是&lt;strong>case执行随机性的关键&lt;/strong>&lt;/p>
&lt;p>order0数组被一分为二
前半部分存放case的随机顺序(pollorder),selectgo()会将原始的case顺序打乱,这样在检查每个case是否就绪时就会表现出随机性
后半部分存放管道加锁的顺序(lockorder),selectgo()会按照管道地址顺序对多个管道加锁,从而避免因重复加锁引发的死锁问题&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>selectgo()函数的实现包括以下要点:&lt;/p>
&lt;ul>
&lt;li>通过随机函数fastrandn()将原始的case顺序打乱,在遍历各个case时使用打乱后的顺序就会表现出随机性&lt;/li>
&lt;li>循环遍历各个case时,如果发现某个case就绪,则直接跳出循环操作管道并返回&lt;/li>
&lt;li>循环遍历各个case时,如果循环正常结束,说明所有case都没有就绪,有default直接跳default&lt;/li>
&lt;li>如果都没有就绪且没有default,selectgo()将阻塞等待所有管道,任一管道就绪后,都将开始新的循环&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;ul>
&lt;li>select仅能操作管道&lt;/li>
&lt;li>每个case仅能处理一个管道,要么读要么写&lt;/li>
&lt;li>多个case语句的执行顺序是随机的&lt;/li>
&lt;li>存在default,则select不会阻塞&lt;/li>
&lt;/ul></content></item><item><title>Go Generic</title><link>https://xujiajiadexiaokeai.github.io/2022-10-01/go-goroutine/</link><pubDate>Sat, 01 Oct 2022 15:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-10-01/go-goroutine/</guid><description>什么是泛型 类型系统 类型内存布局 类型检查 强类型、弱类型 静态检查、动态检查 静态检查: 编译阶段 动态检查: 运行时阶段 Go的类型检查发生在编译阶段
类型推导 编译器来做类型推导
非泛型突破类型的限制 手工复制 代码生成 genny
需要一些集成的手段去使用这些库，可能让代码构建变的更复杂。 增加了编译时间。 增加了二进制包的体积。 类型断言 通过将函数中的参数类型转换为根类型(interface{}),然后对根类型进行期望的类型断言
// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; ) func MaxNumber(s []interface{}) (interface{}, error) { // HL if len(s) == 0 { return nil, errors.New(&amp;#34;no values given&amp;#34;) } switch first := s[0].(type) { // HL case int: // HL max := first for _, rawV := range s[1:] { v := rawV.</description><content>&lt;h1 id="什么是泛型">什么是泛型&lt;/h1>
&lt;h1 id="类型系统">类型系统&lt;/h1>
&lt;h2 id="类型内存布局">类型内存布局&lt;/h2>
&lt;h2 id="类型检查">类型检查&lt;/h2>
&lt;ul>
&lt;li>强类型、弱类型&lt;/li>
&lt;li>静态检查、动态检查&lt;/li>
&lt;/ul>
&lt;p>静态检查: 编译阶段
动态检查: 运行时阶段
Go的类型检查发生在编译阶段&lt;/p>
&lt;ul>
&lt;li>类型推导&lt;/li>
&lt;/ul>
&lt;p>编译器来做类型推导&lt;/p>
&lt;h2 id="非泛型突破类型的限制">非泛型突破类型的限制&lt;/h2>
&lt;h3 id="手工复制">手工复制&lt;/h3>
&lt;h3 id="代码生成">代码生成&lt;/h3>
&lt;p>&lt;a href="https://github.com/cheekybits/genny">genny&lt;/a>&lt;/p>
&lt;ul>
&lt;li>需要一些集成的手段去使用这些库，可能让代码构建变的更复杂。&lt;/li>
&lt;li>增加了编译时间。&lt;/li>
&lt;li>增加了二进制包的体积。&lt;/li>
&lt;/ul>
&lt;h3 id="类型断言">类型断言&lt;/h3>
&lt;p>通过将函数中的参数类型转换为根类型(interface{}),然后对根类型进行期望的类型断言&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;errors&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#66d9ef">error&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">s&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;no values given&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].(&lt;span style="color:#66d9ef">type&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>: &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">rawV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rawV&lt;/span>.(&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span>
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span>: &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">rawV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rawV&lt;/span>.(&lt;span style="color:#66d9ef">float64&lt;/span>) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span>
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#66d9ef">default&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unsupported element type of given slice: %T&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">first&lt;/span>)
}
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">err1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">m2&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4.1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8.1&lt;/span>, &lt;span style="color:#ae81ff">15.1&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err1&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span>) &lt;span style="color:#75715e">// &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">m2&lt;/span>) &lt;span style="color:#75715e">// 15 15.1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>调用方需要将参数包装或转换成根类型。&lt;/li>
&lt;li>实现方代码中耦合了大量的类型断言代码。&lt;/li>
&lt;li>失去了编译器的类型安全保障。&lt;/li>
&lt;/ul>
&lt;h3 id="反射">反射&lt;/h3>
&lt;p>用反射的技术在运行时获取类型信息,通过对类型的枚举判断来实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;errors&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;reflect&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#66d9ef">error&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">s&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;no values given&amp;#34;&lt;/span>)
}
&lt;span style="color:#a6e22e">first&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">CanInt&lt;/span>() {
&lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">Int&lt;/span>()
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ifV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">ifV&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">CanInt&lt;/span>() {
&lt;span style="color:#a6e22e">intV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Int&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">intV&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">intV&lt;/span>
}
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">CanFloat&lt;/span>() {
&lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">Float&lt;/span>()
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ifV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">ifV&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">CanFloat&lt;/span>() {
&lt;span style="color:#a6e22e">intV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Float&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">intV&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">intV&lt;/span>
}
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unsupported element type of given slice: %T&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">err1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">m2&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4.1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8.1&lt;/span>, &lt;span style="color:#ae81ff">15.1&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err1&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span>) &lt;span style="color:#75715e">// &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">m2&lt;/span>) &lt;span style="color:#75715e">// 15 15.1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>可读性可能不太好，因为用到了复杂的反射技术。&lt;/li>
&lt;li>会导致运行时性能差。运行时反射要比直接的代码多了很多指令操作，所以性能要慢很多。&lt;/li>
&lt;li>失去了编译器的类型安全保障。&lt;/li>
&lt;/ul>
&lt;h3 id="接口">接口&lt;/h3>
&lt;p>SOLID设计模式中的依赖倒置原则（Dependency Inversion Principle）要求软件接口在设计中应该依赖抽象而不是具体。&lt;/p>
&lt;ul>
&lt;li>可能需要定义很多数据类型。&lt;/li>
&lt;/ul>
&lt;h1 id="实现泛型">实现泛型&lt;/h1>
&lt;p>通常意义下的泛型也叫参数多态，指的是声明与定义函数、复合类型、变量时不指定其具体的类型，而把这部分类型作为参数使用，使得该定义对各种具体类型都适用。参数化多态使得语言更具表达力，同时保持了完全的静态类型安全。这被称为泛化函数、泛化数据类型、泛型变量，形成了泛型编程的基础。&lt;/p>
&lt;blockquote>
&lt;p>编程语言理论(PLT)中多态(Polymorphism)包含三个主要方面：特设多态(Ad-hoc)，参数多态(Parametric)和子类型(Subtyping)。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Ad-hoc：也叫重载(Overloading)，允许具有相同名称的函数对不同类型执行不同的操作。例如，+运算符即可以将两个整数相加，也可以连接两个字符串。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Subtyping：也叫包容性多态(Inclusion)，是指通过基类指针和引用使用派生类的能力。&lt;/p>
&lt;/blockquote>
&lt;p>子类型多态(Subtyping)是面向对象编程(OOP)中很重要的一个概念，它也称为运行时多态性，因为编译器在编译时不定位函数的地址，而是在运行时动态调用函数。这也称为动态派发(Dynamic Dispatch)。&lt;/p>
&lt;p>派发目的是让程序运行时知道被执行的函数或方法所在的内存位置。派发分为：&lt;/p>
&lt;p>静态派发(Static dispatch/early binding)：当程序在编译时可以找到执行的函数。C++默认使用的是直接派发，加上virtual修饰符可以改成虚函数表(Vtable)派发。直接派发是最快的，原因是调用指令少，还可通过编译器进行内联等方式的优化。这种派发缺点是不灵活，无法实现一些面向对象所需的技术如多态性。
动态派发(dynamic dispatch/run-time dispatch/virtual method call/late binding)：当程序在运行时可以找到执行的函数。Java默认使用的是虚函数表(Vtable)派发，通过final修饰符可改成直接派发。虚函数表派发是有动态性的，一个类里会用表来存储类成员函数的指针，子类重写(Override)父类的函数会替代父类的函数，子类添加的函数会被加到这个表里。当程序运行时派发时会从这个表中找到对应的函数，这样就可以实现动态派发。面向对象的编程语言正是靠此机制实现了多态性(Polymorphic)。
消息机制(message passing)：通过消息传递来调用被执行的函数。这种机制是在运行时可以改变函数的行为，甚至函数可以未实现，也不会引发运行时错误。比如Objective-C中就是通过消息传递来调用被执行的函数，甚至可以在程序运行过程中实现热更新代码。
以上三种派发方式都有其优劣：比如静态派发的速度是最快的，但并不灵活。而动态派发虽然比较慢，但却可以实现面向对象多态的功能。消息机制是最灵活的方式，但性能也最差。&lt;/p>
&lt;h2 id="类型擦除">类型擦除&lt;/h2>
&lt;h2 id="虚函数表">虚函数表&lt;/h2>
&lt;h2 id="字典">字典&lt;/h2>
&lt;h2 id="单态化">单态化&lt;/h2>
&lt;h2 id="模版">模版&lt;/h2>
&lt;h2 id="蜡印">蜡印&lt;/h2>
&lt;h1 id="总结">总结&lt;/h1></content></item><item><title>Chaos Mesh上手</title><link>https://xujiajiadexiaokeai.github.io/2022-09-21/chaos-mesh-quick-start/</link><pubDate>Wed, 21 Sep 2022 09:20:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-09-21/chaos-mesh-quick-start/</guid><description>安装kind 注意科学上网
安装chaos-mesh 测试用 install.sh 需要指定k8s&amp;amp;&amp;amp;kind版本
安装kubernetes Dashboard Kubernetes Dashboard
base dashboard@2.6.1 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml
kubectl proxy http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
create an authentication token(RBAC)
访问Chaos Mesh Dashboard https://chaos-mesh.org/zh/docs/1.2.4/user_guides/dashboard/
访问 Chaos Dashboard 的典型方法是使用kubectl port-forward：
kubectl port-forward -n chaos-mesh --address localhost,...ip svc/chaos-dashboard 2333:2333 访问: http://localhost:2333</description><content>&lt;h1 id="安装kind">安装kind&lt;/h1>
&lt;p>注意科学上网&lt;/p>
&lt;h1 id="安装chaos-mesh">安装chaos-mesh&lt;/h1>
&lt;p>测试用 install.sh
需要指定k8s&amp;amp;&amp;amp;kind版本&lt;/p>
&lt;h1 id="安装kubernetes-dashboard">安装kubernetes Dashboard&lt;/h1>
&lt;p>&lt;a href="https://github.com/kubernetes/dashboard">Kubernetes Dashboard&lt;/a>&lt;/p>
&lt;p>base &lt;a href="mailto:dashboard@2.6.1">dashboard@2.6.1&lt;/a>
kubectl apply -f &lt;a href="https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml">https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl proxy
&lt;/code>&lt;/pre>&lt;p>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&lt;/p>
&lt;p>create an authentication token(RBAC)&lt;/p>
&lt;h1 id="访问chaos-mesh-dashboard">访问Chaos Mesh Dashboard&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://chaos-mesh.org/zh/docs/1.2.4/user_guides/dashboard/">https://chaos-mesh.org/zh/docs/1.2.4/user_guides/dashboard/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>访问 Chaos Dashboard 的典型方法是使用kubectl port-forward：&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl port-forward -n chaos-mesh --address localhost,...ip svc/chaos-dashboard 2333:2333
&lt;/code>&lt;/pre>&lt;p>访问: http://localhost:2333&lt;/p></content></item><item><title>漏桶算法</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/leaky-bucket/</link><pubDate>Sat, 20 Aug 2022 15:32:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/leaky-bucket/</guid><description>请求如何排队 delta = 当前时间t - last last = 当前时间t + (rate - delta)
type LeakyBucket struct { rate int64 // 处理请求的速率 capacity int64 // 桶的最大容量 last time.Time // 桶中最后一个排队请求被处理的时间 mu sync.Mutex } func (t *LeakyBucket) Limit(ctx context.Context) (time.Duration, error) { t.mu.Lock() defer t.mu.Unlock() now := time.Now().UnixNano() if now &amp;lt; t.last { // 说明已经有请求在排队了,那么新请求进来排队后被处理的时间就是rate后 t.last += t.rate } else { // 桶为空 var offset int64 // 代表等待处理该请求的时间需要等待多久 delta := now - state.</description><content>&lt;h1 id="请求如何排队">请求如何排队&lt;/h1>
&lt;p>delta = 当前时间t - last
last = 当前时间t + (rate - delta)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">LeakyBucket&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">rate&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 处理请求的速率
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">capacity&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 桶的最大容量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#75715e">// 桶中最后一个排队请求被处理的时间
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">mu&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Mutex&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">LeakyBucket&lt;/span>) &lt;span style="color:#a6e22e">Limit&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>) (&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">mu&lt;/span>.&lt;span style="color:#a6e22e">Lock&lt;/span>()
&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">mu&lt;/span>.&lt;span style="color:#a6e22e">Unlock&lt;/span>()
&lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>().&lt;span style="color:#a6e22e">UnixNano&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> {
&lt;span style="color:#75715e">// 说明已经有请求在排队了,那么新请求进来排队后被处理的时间就是rate后
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span>
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#75715e">// 桶为空
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">offset&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 代表等待处理该请求的时间需要等待多久
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">Last&lt;/span> &lt;span style="color:#75715e">// 代表当前时间距离上次处理请求的时间过了多久
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span> {
&lt;span style="color:#75715e">// 说明还没有到下次处理请求的时间, 还需要等待offset后才能到
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">offset&lt;/span> = &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span>
}
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> = &lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">offset&lt;/span>
}
&lt;span style="color:#a6e22e">wait&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">wait&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">capacity&lt;/span> { &lt;span style="color:#75715e">// 桶满了, 直接丢弃请求, 返回error
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> = &lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">offset&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>(&lt;span style="color:#a6e22e">wait&lt;/span>), &lt;span style="color:#a6e22e">ErrLimitExhausted&lt;/span>
}
&lt;span style="color:#75715e">// 排队成功, 返回要等待的时间给调用者, 让调用者sleep进行阻塞就能实现按rate速率处理请求了
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>(&lt;span style="color:#a6e22e">wait&lt;/span>), &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>LeakyBucket的核心思想是按固定的速率处理请求, 不支持突增的流量
基于计数原理的实现本质上就是按固定的处理速率计算该请求能够被处理的时间以及需要等待的时间&lt;/p></content></item><item><title>令牌桶</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/token-bucket/</link><pubDate>Sat, 20 Aug 2022 15:30:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/token-bucket/</guid><description>https://zhuanlan.zhihu.com/p/442218413
基本思想 令牌桶, 通过让请求被处理前先行获取令牌, 只有获取到令牌的请求才能被放行处理
按固定速率来产生令牌存入桶中, 如果令牌数量超过桶的最大容量则直接丢掉 当有请求时先从桶中获取令牌,获取到令牌后才能进行处理, 否则被直接丢弃或者等待获取令牌 令牌桶与漏桶的区别 令牌桶与漏桶的区别在于漏桶控制的是请求被处理的速率。即当有请求的时候，先进入桶中进行排队，按固定的速率流出被处理；而令牌桶控制的是令牌产生的速率。即当有请求的时候，先从令牌桶中获取令牌，只要能获取到令牌就能立即通过被处理，不限制请求被处理的速度，所以也就可以应对一定程度的突发流量
实现 time/rate包就是基于令牌桶实现的
func main() { // 构造限流器 limiter := NewLimiter(10, 5) for i := 0; i &amp;lt; 10; i++ { time.Sleep(time.Millisecond * 20) if !limiter.Allow() { fmt.Printf(&amp;#34;%d passed\n&amp;#34;, i) continue } // 说明请求通过Allow获取到了令牌, 继续处理 // todo } } time/rate实现原理 lazyload 直到有请求消费时才根据时间查更新Token数目 通过计数原理计算当前桶中已有的Token数量 Token的生成和消耗 以固定速率产生Token func NewLimiter(r Limit, b int) *Limiter { return &amp;amp;Limiter{ limit: r, // 每秒钟可以生成Token的数量 burst: b, } } lazyload 当有请求到来时，去桶中获取令牌的同时先计算一下从上次生成令牌到现在的这段时间应该添加多少个令牌，把增量的令牌数先加到总的令牌数据上即可，后面被取走的令牌再从总数中减去即可 type Limiter struct { limit Limit // QPS 一秒钟多少个token burst int // 桶的容量 tokens float64 // 当前的token数量 last time.</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/442218413">https://zhuanlan.zhihu.com/p/442218413&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="基本思想">基本思想&lt;/h1>
&lt;p>令牌桶, 通过让请求被处理前先行获取令牌, 只有获取到令牌的请求才能被放行处理&lt;/p>
&lt;ul>
&lt;li>按固定速率来产生令牌存入桶中, 如果令牌数量超过桶的最大容量则直接丢掉&lt;/li>
&lt;li>当有请求时先从桶中获取令牌,获取到令牌后才能进行处理, 否则被直接丢弃或者等待获取令牌&lt;/li>
&lt;/ul>
&lt;h1 id="令牌桶与漏桶的区别">令牌桶与漏桶的区别&lt;/h1>
&lt;p>令牌桶与漏桶的区别在于漏桶控制的是请求被处理的速率。即当有请求的时候，先进入桶中进行排队，按固定的速率流出被处理；而令牌桶控制的是令牌产生的速率。即当有请求的时候，先从令牌桶中获取令牌，只要能获取到令牌就能立即通过被处理，不限制请求被处理的速度，所以也就可以应对一定程度的突发流量&lt;/p>
&lt;h1 id="实现">实现&lt;/h1>
&lt;p>&lt;a href="https://pkg.go.dev/golang.org/x/time/rate">time/rate&lt;/a>包就是基于令牌桶实现的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// 构造限流器
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">limiter&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewLimiter&lt;/span>(&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Sleep&lt;/span>(&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Millisecond&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">limiter&lt;/span>.&lt;span style="color:#a6e22e">Allow&lt;/span>() {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d passed\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;span style="color:#66d9ef">continue&lt;/span>
}
&lt;span style="color:#75715e">// 说明请求通过Allow获取到了令牌, 继续处理
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// todo
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="timerate实现原理">time/rate实现原理&lt;/h2>
&lt;ul>
&lt;li>lazyload&lt;/li>
&lt;li>直到有请求消费时才根据时间查更新Token数目&lt;/li>
&lt;li>通过计数原理计算当前桶中已有的Token数量&lt;/li>
&lt;/ul>
&lt;h2 id="token的生成和消耗">Token的生成和消耗&lt;/h2>
&lt;ul>
&lt;li>以&lt;strong>固定速率&lt;/strong>产生Token&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewLimiter&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#a6e22e">Limit&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Limiter&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Limiter&lt;/span>{
&lt;span style="color:#a6e22e">limit&lt;/span>: &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#75715e">// 每秒钟可以生成Token的数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">burst&lt;/span>: &lt;span style="color:#a6e22e">b&lt;/span>,
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>lazyload
当有请求到来时，去桶中获取令牌的同时先计算一下从上次生成令牌到现在的这段时间应该添加多少个令牌，把增量的令牌数先加到总的令牌数据上即可，后面被取走的令牌再从总数中减去即可&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Limiter&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">limit&lt;/span> &lt;span style="color:#a6e22e">Limit&lt;/span> &lt;span style="color:#75715e">// QPS 一秒钟多少个token
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">burst&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#75715e">// 桶的容量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span> &lt;span style="color:#75715e">// 当前的token数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#75715e">// last代表最近一次更新token的时间
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以在请求到来时:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> (&lt;span style="color:#a6e22e">当前时间t&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">最近一次更新tokens的时间last&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">时间间隔&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="如何应对突发流量">如何应对突发流量&lt;/h2>
&lt;ul>
&lt;li>令牌桶缓存令牌&lt;/li>
&lt;li>令牌桶最大容量约束&lt;/li>
&lt;/ul>
&lt;h2 id="数值溢出问题">数值溢出问题&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go"> &lt;span style="color:#75715e">// elapsed表示最后一次更新tokens数量的时间到现在的时间差
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">elapsed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Sub&lt;/span>(&lt;span style="color:#a6e22e">last&lt;/span>)
&lt;span style="color:#75715e">// delta 具有数值溢出风险， 表示elapsed这段时间应该产生的令牌数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">elapsed&lt;/span>.&lt;span style="color:#a6e22e">Seconds&lt;/span>() &lt;span style="color:#f92672">*&lt;/span> float64(&lt;span style="color:#a6e22e">limit&lt;/span>)
&lt;span style="color:#75715e">//tokens 表示当前总的令牌数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">burst&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> float64(&lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">burst&lt;/span>); &lt;span style="color:#a6e22e">tokens&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">burst&lt;/span> {
&lt;span style="color:#a6e22e">tokens&lt;/span> = &lt;span style="color:#a6e22e">burst&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以为了防止delta溢出,应该对elapsed有最大值的约束, maxElapsed是可以计算得到的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go"> &lt;span style="color:#a6e22e">maxElapsed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">limit&lt;/span>.&lt;span style="color:#a6e22e">durationFromTokens&lt;/span>(float64(&lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">burst&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">tokens&lt;/span>)
&lt;span style="color:#a6e22e">elapsed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Sub&lt;/span>(&lt;span style="color:#a6e22e">last&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">elapsed&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">maxElapsed&lt;/span> {
&lt;span style="color:#a6e22e">elapsed&lt;/span> = &lt;span style="color:#a6e22e">maxElapsed&lt;/span>
}
&lt;span style="color:#a6e22e">delta&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">limit&lt;/span>.&lt;span style="color:#a6e22e">tokensFromDuration&lt;/span>(&lt;span style="color:#a6e22e">elapsed&lt;/span>)
&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">delta&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">burst&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> float64(&lt;span style="color:#a6e22e">lim&lt;/span>.&lt;span style="color:#a6e22e">burst&lt;/span>); &lt;span style="color:#a6e22e">tokens&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">burst&lt;/span> {
&lt;span style="color:#a6e22e">tokens&lt;/span> = &lt;span style="color:#a6e22e">burst&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">limit&lt;/span> &lt;span style="color:#a6e22e">Limit&lt;/span>) &lt;span style="color:#a6e22e">tokensFromDuration&lt;/span>(&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>) &lt;span style="color:#66d9ef">float64&lt;/span> {
&lt;span style="color:#a6e22e">sec&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> float64(&lt;span style="color:#a6e22e">d&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> float64(&lt;span style="color:#a6e22e">limit&lt;/span>)
&lt;span style="color:#a6e22e">nsec&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> float64(&lt;span style="color:#a6e22e">d&lt;/span>&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> float64(&lt;span style="color:#a6e22e">limit&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">sec&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nsec&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1e9&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>TokenBucket是以固定的速率生成令牌，让获得令牌的请求才能通过被处理。令牌桶的限流方式可以应对一定的突发流量。在实现TokenBucket时需要注意在计算令牌总数时的数值溢出问题以及精度问题。&lt;/p></content></item><item><title>限流算法</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/current-limiting-algorithm/</link><pubDate>Sat, 20 Aug 2022 15:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/current-limiting-algorithm/</guid><description>固定窗口 滑动窗口 漏斗 令牌桶</description><content>&lt;h1 id="固定窗口">固定窗口&lt;/h1>
&lt;h1 id="滑动窗口">滑动窗口&lt;/h1>
&lt;h1 id="漏斗">漏斗&lt;/h1>
&lt;h1 id="令牌桶">令牌桶&lt;/h1></content></item><item><title>一致性哈希</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/consistent-hashing/</link><pubDate>Sat, 20 Aug 2022 09:20:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/consistent-hashing/</guid><description> https://www.zsythink.net/archives/1182 问题1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。
问题2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？
优点 服务器数量发生改变, 并不是所有缓存都会失效,是部分失效 问题 哈希环倾斜, 数据分配不均 解决方案 虚拟节点 优化 如果缓存服务器间性能存在较大差异,可考虑容器化? 均匀分配数据处理能力 sample实现 https://www.cnblogs.com/luxiaoxun/p/12573742.html
Chord环 https://zhuanlan.zhihu.com/p/129049724
Napster 使用中心服务器接收所有查询 问题: 中心服务器单点失效导致整个网络瘫痪 Gnutella 使用消息洪泛(message flooding)来定位数据 使用TTL来限制网络内转发消息的数量 问题: 消息数与节点数成线性关系,网络负载较重 SN SN保存网络中节点的索引信息,有多个SN Chord算法 实现原理 资源定位 查询步骤 路由表维护</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://www.zsythink.net/archives/1182">https://www.zsythink.net/archives/1182&lt;/a>
问题1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。&lt;/p>
&lt;/blockquote>
&lt;p>问题2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？&lt;/p>
&lt;h1 id="优点">优点&lt;/h1>
&lt;ul>
&lt;li>服务器数量发生改变, 并不是所有缓存都会失效,是部分失效&lt;/li>
&lt;/ul>
&lt;h1 id="问题">问题&lt;/h1>
&lt;ul>
&lt;li>哈希环倾斜, 数据分配不均&lt;/li>
&lt;/ul>
&lt;h1 id="解决方案">解决方案&lt;/h1>
&lt;ul>
&lt;li>虚拟节点&lt;/li>
&lt;/ul>
&lt;h1 id="优化">优化&lt;/h1>
&lt;ul>
&lt;li>如果缓存服务器间性能存在较大差异,可考虑容器化? 均匀分配数据处理能力&lt;/li>
&lt;/ul>
&lt;h1 id="sample实现">sample实现&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://www.cnblogs.com/luxiaoxun/p/12573742.html">https://www.cnblogs.com/luxiaoxun/p/12573742.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="chord环">Chord环&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/129049724">https://zhuanlan.zhihu.com/p/129049724&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>Napster&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>使用中心服务器接收所有查询&lt;/li>
&lt;li>问题: 中心服务器单点失效导致整个网络瘫痪&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>Gnutella&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>使用消息洪泛(message flooding)来定位数据&lt;/li>
&lt;li>使用TTL来限制网络内转发消息的数量&lt;/li>
&lt;li>问题: 消息数与节点数成线性关系,网络负载较重&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>SN&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>SN保存网络中节点的索引信息,有多个SN&lt;/li>
&lt;/ul>
&lt;h2 id="chord算法">Chord算法&lt;/h2>
&lt;h3 id="实现原理">实现原理&lt;/h3>
&lt;h3 id="资源定位">资源定位&lt;/h3>
&lt;h3 id="查询步骤">查询步骤&lt;/h3>
&lt;h3 id="路由表维护">路由表维护&lt;/h3></content></item><item><title>算法笔记</title><link>https://xujiajiadexiaokeai.github.io/2022-08-01/algorithm-notes/</link><pubDate>Mon, 01 Aug 2022 08:14:47 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-01/algorithm-notes/</guid><description>前缀和 https://oi-wiki.org/basic/prefix-sum
数据预处理 降低时间复杂度 数列前n项的和 思路 一维 recurrence: B[0] = A[0],对于i&amp;gt;=1,则B[i] = B[i-1] + A[i] 二维/多维 容斥原理 https://zh.m.wikipedia.org/zh-hans/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86
$$\left|\bigcap_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&amp;lt;a_{i+1}}\left|\bigcap_{i=1}^mS_{a_i}\right|$$
不定方程非负整数解计数
排列组合 https://oi-wiki.org/math/combinatorics/combination/
排列数 $$\mathrm A_n^m = n(n-1)(n-2) \cdots (n-m+1) = \frac{n!}{(n-m)!}$$
组合数 $$ \mathrm C_n^m = \frac{\mathrm A_n^m}{m!} = \frac{n!}{m!(n-m)!}$$
组合数也被称为「二项式系数」,$\displaystyle \binom{n}{m}$ 读作「n选m」
$$\displaystyle \mathrm C_n^m = \binom{n}{m}$$
特别地,规定当m &amp;gt; n时, $\mathrm A_n^m = \mathrm C_n^m = 0$
单调栈 // TODO</description><content>&lt;h1 id="前缀和">前缀和&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://oi-wiki.org/basic/prefix-sum">https://oi-wiki.org/basic/prefix-sum&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>数据预处理&lt;/li>
&lt;li>降低时间复杂度&lt;/li>
&lt;li>数列前n项的和&lt;/li>
&lt;/ul>
&lt;h2 id="思路">思路&lt;/h2>
&lt;h3 id="一维">一维&lt;/h3>
&lt;pre tabindex="0">&lt;code>recurrence:
B[0] = A[0],对于i&amp;gt;=1,则B[i] = B[i-1] + A[i]
&lt;/code>&lt;/pre>&lt;h3 id="二维多维">二维/多维&lt;/h3>
&lt;ul>
&lt;li>容斥原理&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;a href="https://zh.m.wikipedia.org/zh-hans/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86">https://zh.m.wikipedia.org/zh-hans/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>$$\left|\bigcap_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&amp;lt;a_{i+1}}\left|\bigcap_{i=1}^mS_{a_i}\right|$$&lt;/p>
&lt;p>不定方程非负整数解计数&lt;/p>
&lt;h1 id="排列组合">排列组合&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://oi-wiki.org/math/combinatorics/combination/">https://oi-wiki.org/math/combinatorics/combination/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="排列数">排列数&lt;/h2>
&lt;p>$$\mathrm A_n^m = n(n-1)(n-2) \cdots (n-m+1) = \frac{n!}{(n-m)!}$$&lt;/p>
&lt;h2 id="组合数">组合数&lt;/h2>
&lt;p>$$ \mathrm C_n^m = \frac{\mathrm A_n^m}{m!} = \frac{n!}{m!(n-m)!}$$&lt;/p>
&lt;p>组合数也被称为「二项式系数」,$\displaystyle \binom{n}{m}$ 读作「n选m」&lt;/p>
&lt;p>$$\displaystyle \mathrm C_n^m = \binom{n}{m}$$&lt;/p>
&lt;p>特别地,规定当m &amp;gt; n时, $\mathrm A_n^m = \mathrm C_n^m = 0$&lt;/p>
&lt;h1 id="单调栈">单调栈&lt;/h1>
&lt;p>// TODO&lt;/p></content></item><item><title>gRPC concepts</title><link>https://xujiajiadexiaokeai.github.io/2022-07-13/grpc-concepts/</link><pubDate>Wed, 13 Jul 2022 19:15:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-13/grpc-concepts/</guid><description>Interface Definition Language(IDL) protocol buffers
Synchronous vs. asynchronous application-specific
RPC life cycle Unary RPC client -&amp;gt; server metadata method name deadline if applicable server -&amp;gt; client send back its own initial metadata (which must be sent before any response) straight away or wait for the client’s request message which happens first, is application-specific optional trailing metadata Server streaming RPC like unary RPC
Client streaming RPC like unary RPC</description><content>&lt;h1 id="interface-definition-languageidl">Interface Definition Language(IDL)&lt;/h1>
&lt;p>protocol buffers&lt;/p>
&lt;h1 id="synchronous-vs-asynchronous">Synchronous vs. asynchronous&lt;/h1>
&lt;p>&lt;strong>application-specific&lt;/strong>&lt;/p>
&lt;h1 id="rpc-life-cycle">RPC life cycle&lt;/h1>
&lt;h2 id="unary-rpc">Unary RPC&lt;/h2>
&lt;ol>
&lt;li>client -&amp;gt; server&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>metadata&lt;/li>
&lt;li>method name&lt;/li>
&lt;li>deadline if applicable&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>server -&amp;gt; client&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>send back its own initial metadata (which must be sent before any response) straight away&lt;/li>
&lt;li>or wait for the client’s request message&lt;/li>
&lt;li>which happens first, is &lt;strong>application-specific&lt;/strong>&lt;/li>
&lt;li>optional trailing metadata&lt;/li>
&lt;/ul>
&lt;h2 id="server-streaming-rpc">Server streaming RPC&lt;/h2>
&lt;p>like unary RPC&lt;/p>
&lt;h2 id="client-streaming-rpc">Client streaming RPC&lt;/h2>
&lt;p>like unary RPC&lt;/p>
&lt;h2 id="bidirectional-streaming-rpc">Bidirectional streaming RPC&lt;/h2>
&lt;ul>
&lt;li>the call is initiated by the client invoking the method and the server receiving the client metadata, method name, and deadline&lt;/li>
&lt;li>server can choose to send back its initial metadata or wait for the client to start streaming messages&lt;/li>
&lt;li>processing is application specific&lt;/li>
&lt;li>two streams are independent&lt;/li>
&lt;/ul>
&lt;h1 id="deadlinestimeouts">Deadlines/Timeouts&lt;/h1>
&lt;ul>
&lt;li>clients to specify&lt;/li>
&lt;li>server can query&lt;/li>
&lt;li>specifying a deadline or timeout &lt;strong>is language specific&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="rpc-termination">RPC termination&lt;/h1>
&lt;p>both the client and server make &lt;strong>independent&lt;/strong> and local determinations of the success of the call, and their conclusions may not match&lt;/p>
&lt;h1 id="cancelling-an-rpc">Cancelling an RPC&lt;/h1>
&lt;ul>
&lt;li>client and server either can cancel at any time&lt;/li>
&lt;li>changes made before a cancellation are not rolled back.&lt;/li>
&lt;/ul>
&lt;h1 id="metadata">Metadata&lt;/h1>
&lt;h1 id="channels">Channels&lt;/h1>
&lt;ul>
&lt;li>clients can specify channel arguments to modify gRPC’s default behavior(such as message compression)&lt;/li>
&lt;li>channels has state, including &lt;strong>connected&lt;/strong> and &lt;strong>idle&lt;/strong>&lt;/li>
&lt;li>closing a channel is &lt;strong>language dependent&lt;/strong>&lt;/li>
&lt;li>Some languages also permit querying channel state&lt;/li>
&lt;/ul></content></item><item><title>Goroutine</title><link>https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/</link><pubDate>Wed, 13 Jul 2022 10:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/</guid><description>基本概念 进程 进程是应用程序的启动实例 有独立的内存空间 不同进程通过进程间通信的方式进行通信 线程 线程是cpu调度的基本单位 不同线程可以共享进程的资源 不同线程通过共享内存等线程间通信方式进行通信 协程 协程调度由用户程序提供,不直接受操作系统调度 协程调度器按照调度策略把协程调度到线程中执行 协程的优势 过多的线程会导致上下文切换的开销变大,而工作在用户态的协程则能大大减少上下文切换的开销
协程调度器把可运行的协程逐个调度到线程中执行,同时及时把阻塞的协程调度出线程
有效地避免了线程的频繁切换
实现了使用少量线程实现高并发的效果
多个协程分享操作系统分给线程的时间片
协程调度器决定了协程运行的顺序
线程运行调度器指派的协程,每一时刻只能运行一个协程
调度模型 线程模型 线程可分为用户线程和内核线程 用户线程由用户创建、同步合销毁
根据用户线程管理方式的不同,分为三种线程模型:
N:1模型 N个用户线程运行在1个内核线程中,上下文切换较快 1:1模型 每个用户线程对应一个内核线程,上下文切换较慢 M:N模型 充分利用cpu且上下文切换较快,但调度算法较为复杂 Go GPM模型 G: goroutine,Go协程,每个go关键字都会创建一个goroutine
P: processor,处理器(Go定义的一个概念,不是指cpu),包含运行Go代码的必要资源,也有调度goroutine的能力
M: machine,工作线程,由操作系统调度
M必须持有P才能运行代码 M会被系统调用阻塞
P的个数在程序启动时决定,默认等于CPU的核数,可以使用环境变量GOMAXPROCS或在程序中使用runtime.GOMAXPROCS()方法指定P的个数
export GOMAXPROC=80 runtime.GOMAXPROCS(80) M的个数通常稍大于P的个数,因为除了运行Go代码,还有其他内置任务需要处理.
调度策略 队列轮转 每个处理器P维护着一个协程G的队列, 处理器P依次将协程G调度到M中执行 P会周期性地查看全局队列中是否有G待运行,防止“饥饿” 全局队列中的G主要来自从系统调用中恢复的G
系统调用</description><content>&lt;h1 id="基本概念">基本概念&lt;/h1>
&lt;ol>
&lt;li>进程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>进程是应用程序的启动实例&lt;/li>
&lt;li>有独立的内存空间&lt;/li>
&lt;li>不同进程通过进程间通信的方式进行通信&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>线程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>线程是cpu调度的基本单位&lt;/li>
&lt;li>不同线程可以共享进程的资源&lt;/li>
&lt;li>不同线程通过共享内存等线程间通信方式进行通信&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>协程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>协程调度由用户程序提供,不直接受操作系统调度&lt;/li>
&lt;li>协程调度器按照调度策略把协程调度到线程中执行&lt;/li>
&lt;/ul>
&lt;h1 id="协程的优势">协程的优势&lt;/h1>
&lt;p>过多的线程会导致上下文切换的开销变大,而工作在用户态的协程则能大大减少上下文切换的开销&lt;/p>
&lt;p>协程调度器把可运行的协程逐个调度到线程中执行,同时及时把阻塞的协程调度出线程&lt;/p>
&lt;p>有效地避免了线程的频繁切换&lt;/p>
&lt;p>实现了使用少量线程实现高并发的效果&lt;/p>
&lt;p>多个协程分享操作系统分给线程的时间片&lt;/p>
&lt;p>协程调度器决定了协程运行的顺序&lt;/p>
&lt;p>线程运行调度器指派的协程,每一时刻只能运行一个协程&lt;/p>
&lt;h1 id="调度模型">调度模型&lt;/h1>
&lt;ol>
&lt;li>线程模型
线程可分为用户线程和内核线程&lt;/li>
&lt;/ol>
&lt;p>用户线程由用户创建、同步合销毁&lt;/p>
&lt;p>根据用户线程管理方式的不同,分为三种线程模型:&lt;/p>
&lt;ul>
&lt;li>N:1模型
N个用户线程运行在1个内核线程中,上下文切换较快&lt;/li>
&lt;li>1:1模型
每个用户线程对应一个内核线程,上下文切换较慢&lt;/li>
&lt;li>M:N模型
充分利用cpu且上下文切换较快,但调度算法较为复杂&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>Go GPM模型&lt;/li>
&lt;/ol>
&lt;p>G: goroutine,Go协程,每个&lt;code>go&lt;/code>关键字都会创建一个goroutine&lt;/p>
&lt;p>P: processor,处理器(Go定义的一个概念,不是指cpu),包含运行Go代码的必要资源,也有调度goroutine的能力&lt;/p>
&lt;p>M: machine,工作线程,由操作系统调度&lt;/p>
&lt;p>M必须持有P才能运行代码
M会被系统调用阻塞&lt;/p>
&lt;p>P的个数在程序启动时决定,默认等于CPU的核数,可以使用环境变量GOMAXPROCS或在程序中使用runtime.GOMAXPROCS()方法指定P的个数&lt;/p>
&lt;pre tabindex="0">&lt;code>export GOMAXPROC=80
runtime.GOMAXPROCS(80)
&lt;/code>&lt;/pre>&lt;p>M的个数通常稍大于P的个数,因为除了运行Go代码,还有其他内置任务需要处理.&lt;/p>
&lt;h1 id="调度策略">调度策略&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>队列轮转
每个处理器P维护着一个协程G的队列, 处理器P依次将协程G调度到M中执行
P会周期性地查看全局队列中是否有G待运行,防止“饥饿”
全局队列中的G主要来自从系统调用中恢复的G&lt;/p>
&lt;/li>
&lt;li>
&lt;p>系统调用&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>P的个数默认等于CPU的核数, 每个M必须持有一个P才能执行G
一般情况下M的个数略大于P,多出来的M将会在G产生系统调用时发挥作用&lt;/p>
&lt;p>M池
当M运行的某个G产生系统调用时: // TODO&lt;/p>
&lt;ol start="3">
&lt;li>工作量窃取
通过&lt;code>go&lt;/code>关键字创建的协程通常会优先放到当前协程对应的多处理器队列中
可能有些协程自身会不断派生新协程,有些协程不会派生,导致多个P中维护的G队列是不均衡的&lt;/li>
&lt;/ol>
&lt;p>所以Go调度器提供了工作量窃取策略: 当某个P没有需要调度的协程时, 将从其他处理器中偷取协程&lt;/p>
&lt;p>发生窃取前,会查询全局队列,如果全局队列中没有需要调度的协程,才会从其他P中偷取,一次偷一半&lt;/p>
&lt;ol start="4">
&lt;li>抢占式调度
避免某个协程长时间执行,而阻碍其他协程被调度的机制&lt;/li>
&lt;/ol>
&lt;p>调度器会监控每个协程的执行时间, 一旦执行时间过程且有其他协程在等待时,会把当前协程暂停,转而调度等待的协程,类似&lt;code>时间片轮转&lt;/code>&lt;/p></content></item><item><title>Go Memory</title><link>https://xujiajiadexiaokeai.github.io/2022-07-13/go-memory/</link><pubDate>Wed, 13 Jul 2022 08:15:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-13/go-memory/</guid><description>内存分配 内存分配过程 针对待分配对象大小的不同有不同的分配逻辑:
(0, 16B)且不包含指针的对象: Tiny分配 (0, 16B)且包含指针的对象: 正常分配 [16B, 32KB] : 正常分配 (32KB, ∞): 大对象分配 以申请size为n的内存为例,分配步骤如下:
获取当前线程的私有缓存mcache 根据size计算出适合的class的ID 从mcache的alloc[class]链表中查询可用的span 如果macache没有可用的span, 则从mcentral申请一个新的span加入mcache 如果mcentral中也没有可用的span, 则从mheap中申请一个新的span加入mcentral 从该span中获取空闲对象地址并返回 小结 Go程序启动时申请一大块内存, 并划分成span、bitmap、arena区域 arena区域按页划分成一个个小块 span管理一个或多个页 mcentral管理多个span供线程申请使用 mcache作为线程私有资源, 资源来源于mcentral 垃圾回收 常见垃圾回收算法 引用计数 对每个对象维护一个引用计数, 当引用改对象的对象被销毁时,引用计数减1, 当引用计数器为0时回收改对象 优点: 对象可以很快被回收,不会出现内存耗尽或达到某个阈值时才回收 缺点: 不能很好地处理循环引用, 而且实时维护引用计数也有一定代价
标记-清除 从根变量开始遍历所有引用对象, 引用的对象标记为“被引用”, 没有标记的对象被回收 优点: 解决了引用计数的缺点 缺点: 需要”Stop The World“
分代收集 按照对象生命周期的长短划分不同的代空间, 生命周期长的放入老生代, 短的放入新生代, 不同代有不同的回收算法和回收频率 优点: 回收性能好 缺点: 算法复杂</description><content>&lt;h1 id="内存分配">内存分配&lt;/h1>
&lt;h2 id="内存分配过程">内存分配过程&lt;/h2>
&lt;p>针对待分配对象大小的不同有不同的分配逻辑:&lt;/p>
&lt;ul>
&lt;li>(0, 16B)且不包含指针的对象: Tiny分配&lt;/li>
&lt;li>(0, 16B)且包含指针的对象: 正常分配&lt;/li>
&lt;li>[16B, 32KB] : 正常分配&lt;/li>
&lt;li>(32KB, ∞): 大对象分配&lt;/li>
&lt;/ul>
&lt;p>以申请size为n的内存为例,分配步骤如下:&lt;/p>
&lt;ol>
&lt;li>获取当前线程的私有缓存mcache&lt;/li>
&lt;li>根据size计算出适合的class的ID&lt;/li>
&lt;li>从mcache的alloc[class]链表中查询可用的span&lt;/li>
&lt;li>如果macache没有可用的span, 则从mcentral申请一个新的span加入mcache&lt;/li>
&lt;li>如果mcentral中也没有可用的span, 则从mheap中申请一个新的span加入mcentral&lt;/li>
&lt;li>从该span中获取空闲对象地址并返回&lt;/li>
&lt;/ol>
&lt;h2 id="小结">小结&lt;/h2>
&lt;ul>
&lt;li>Go程序启动时申请一大块内存, 并划分成span、bitmap、arena区域&lt;/li>
&lt;li>arena区域按页划分成一个个小块&lt;/li>
&lt;li>span管理一个或多个页&lt;/li>
&lt;li>mcentral管理多个span供线程申请使用&lt;/li>
&lt;li>mcache作为线程私有资源, 资源来源于mcentral&lt;/li>
&lt;/ul>
&lt;h1 id="垃圾回收">垃圾回收&lt;/h1>
&lt;h2 id="常见垃圾回收算法">常见垃圾回收算法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>引用计数
对每个对象维护一个引用计数, 当引用改对象的对象被销毁时,引用计数减1, 当引用计数器为0时回收改对象
优点: 对象可以很快被回收,不会出现内存耗尽或达到某个阈值时才回收
缺点: 不能很好地处理循环引用, 而且实时维护引用计数也有一定代价&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标记-清除
从根变量开始遍历所有引用对象, 引用的对象标记为“被引用”, 没有标记的对象被回收
优点: 解决了引用计数的缺点
缺点: 需要”Stop The World“&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分代收集
按照对象生命周期的长短划分不同的代空间, 生命周期长的放入老生代, 短的放入新生代, 不同代有不同的回收算法和回收频率
优点: 回收性能好
缺点: 算法复杂&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="go垃圾回收">Go垃圾回收&lt;/h2>
&lt;h3 id="标记-清除算法原理">“标记-清除”算法原理&lt;/h3>
&lt;h3 id="内存标记">内存标记&lt;/h3>
&lt;p>在&lt;code>mspan&lt;/code>的数据结构中, bitmap&lt;code>allocBits&lt;/code>表示每个内存块的使用情况, bitmap&lt;code>gcmarkBits&lt;/code>用于标记内存块被引用的情况
在标记阶段对每块内存进行标记, 有对象引用的内存标记为1,没有引用的保持为0(default)
&lt;code>allocBits&lt;/code>和&lt;code>gcmarkBits&lt;/code>的数据结构完全一样, 标记结束后进行内存回收, 回收时将allocBits指向gcmarkBits, 代表标记过的内存才是存活的, gcmarkBits会在下次标记时重新分配内存&lt;/p>
&lt;h3 id="三色标记法">三色标记法&lt;/h3>
&lt;p>三色主要是为了对应gc过程中对象的三种状态:&lt;/p>
&lt;ul>
&lt;li>灰色: 对象还在标记队列中等待&lt;/li>
&lt;li>黑色: 对象已被标记, gcmarkBits对应的位为1(本次不会被清理)&lt;/li>
&lt;li>白色: 对象未被标记, gcmarkBits对应的位为0(本次会被清理)&lt;/li>
&lt;/ul>
&lt;h3 id="stop-the-world">Stop The World&lt;/h3>
&lt;p>在gc过程中, 需要控制内存的变化, 否则在回收过程中指针传递会引起内存引用关系变化
STW时间的长短直接影响了应用的执行&lt;/p>
&lt;h2 id="垃圾回收优化">垃圾回收优化&lt;/h2>
&lt;h3 id="写屏障write-barrier">写屏障(Write Barrier)&lt;/h3>
&lt;p>STW的目的是防止GC扫描时内存变化而停止goroutine, 而写屏障就是让goroutine与GC同时运行的手段.
虽然写屏障不能完全消除STW,但是可以大大缩短STW的时间&lt;/p>
&lt;h3 id="辅助gcmutator-assist">辅助GC(Mutator Assist)&lt;/h3>
&lt;p>在GC过程中, 如果goroutine需要分配内存, 那么改goroutine会参与以部分GC的工作&lt;/p>
&lt;h2 id="gc的触发时机">GC的触发时机&lt;/h2>
&lt;ol>
&lt;li>内存分配量达到阈值触发GC&lt;/li>
&lt;li>定期触发GC&lt;/li>
&lt;li>手动触发&lt;/li>
&lt;/ol>
&lt;h2 id="gc性能优化">GC性能优化&lt;/h2>
&lt;p>GC性能与对象数量负相关&lt;/p>
&lt;ul>
&lt;li>减少对象分配: 对象复用或使用大对象组合多个小对象&lt;/li>
&lt;li>内存逃逸也会加重GC负担&lt;/li>
&lt;/ul>
&lt;h1 id="逃逸分析">逃逸分析&lt;/h1>
&lt;p>逃逸分析(escape analysis)是指编译器决定内存分配的位置, 不需要程序员指定
在函数中申请一个新的对象:&lt;/p>
&lt;ul>
&lt;li>如果分配在栈中, 则函数执行结束后可自动将内存回收&lt;/li>
&lt;li>如果分配在堆中, 则函数执行结束后可交给GC处理&lt;/li>
&lt;/ul>
&lt;h2 id="逃逸策略">逃逸策略&lt;/h2>
&lt;p>在函数中申请一个闲的对象, 编译器会根据该对象是否被函数外部引用来决定是否逃逸:&lt;/p>
&lt;ul>
&lt;li>如果函数外部没有引用, 则优先放入栈中&lt;/li>
&lt;li>如果函数外部存在引用, 则优先放入堆中&lt;/li>
&lt;li>对于仅在函数内部使用的对象, 也有可能放到堆中, 比如内存过大超过栈的大小&lt;/li>
&lt;/ul>
&lt;h2 id="逃逸场景">逃逸场景&lt;/h2>
&lt;ol>
&lt;li>指针逃逸
Go返回了局部变量的指针&lt;/li>
&lt;li>栈空间不足
当栈空间不足以存放当前对象或无法判断当前切片长度时会将对象分配到堆中&lt;/li>
&lt;li>动态类型逃逸
如果函数中使用了动态类型参数, 编译期间很难确定参数类型, 也会产生逃逸&lt;/li>
&lt;li>闭包引用对象逃逸
闭包中的局部对象由于闭包的引用, 产生逃逸&lt;/li>
&lt;/ol>
&lt;h2 id="小结-1">小结&lt;/h2>
&lt;ul>
&lt;li>栈上分配内存比在堆中分配内存有更高的效率&lt;/li>
&lt;li>逃逸分析的目的是决定分配到栈还是堆&lt;/li>
&lt;li>逃逸分析在编译阶段完成&lt;/li>
&lt;/ul></content></item><item><title>Go Channel</title><link>https://xujiajiadexiaokeai.github.io/2022-07-12/go-channel/</link><pubDate>Tue, 12 Jul 2022 21:12:06 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-12/go-channel/</guid><description>读写nil管道均会阻塞 关闭的管道仍然可以读取数据 向关闭的管道写数据会触发panic
只有一个缓冲区的管道,写入数据 —&amp;gt; 加锁; 读出数据 -&amp;gt; 解锁
特性 初始化 变量声明 var ch chan int declare chan, value == nil make() ch1 := make(chan string) no-buffered chan ch2 := make(chan string, 5) buffered chan 管道操作 操作符: &amp;lt;- -&amp;gt; 默认为双向可读写,在函数传递间可使用操作符限制读写 func ChanParamR(ch &amp;lt;-chan int) { only can read from chan } func ChanParamW(ch chan&amp;lt;- int) { only can write to chan } 数据读写 协程读取管道时,阻塞的条件有: chan no-buffer chan buffer no data chan value == nil 协程写入管道时,阻塞的条件有: chan no-buffer chan buffer is full chan value == nil 实现原理 数据结构 https://cs.</description><content>&lt;p>读写nil管道均会阻塞
关闭的管道仍然可以读取数据
向关闭的管道写数据会触发panic&lt;/p>
&lt;p>只有一个缓冲区的管道,写入数据 —&amp;gt; 加锁; 读出数据 -&amp;gt; 解锁&lt;/p>
&lt;h1 id="特性">特性&lt;/h1>
&lt;h2 id="初始化">初始化&lt;/h2>
&lt;ul>
&lt;li>变量声明&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">declare&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>make()&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">ch1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#a6e22e">no&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">buffered&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
&lt;span style="color:#a6e22e">ch2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#a6e22e">buffered&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="管道操作">管道操作&lt;/h2>
&lt;ul>
&lt;li>操作符: &amp;lt;- -&amp;gt;
默认为双向可读写,在函数传递间可使用操作符限制读写&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">ChanParamR&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;span style="color:#a6e22e">only&lt;/span> &lt;span style="color:#a6e22e">can&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">ChanParamW&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>&lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;span style="color:#a6e22e">only&lt;/span> &lt;span style="color:#a6e22e">can&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>数据读写
协程读取管道时,阻塞的条件有:&lt;/li>
&lt;li>chan no-buffer&lt;/li>
&lt;li>chan buffer no data&lt;/li>
&lt;li>chan value == nil
协程写入管道时,阻塞的条件有:&lt;/li>
&lt;li>chan no-buffer&lt;/li>
&lt;li>chan buffer is full&lt;/li>
&lt;li>chan value == nil&lt;/li>
&lt;/ul>
&lt;h1 id="实现原理">实现原理&lt;/h1>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/runtime/chan.go">https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/runtime/chan.go&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">hchan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">qcount&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// total data in the queue
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">dataqsiz&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// size of the circular queue
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">buf&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span> &lt;span style="color:#75715e">// points to an array of dataqsiz elements
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">elemsize&lt;/span> &lt;span style="color:#66d9ef">uint16&lt;/span>
&lt;span style="color:#a6e22e">closed&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;span style="color:#a6e22e">elemtype&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#75715e">// element type
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">sendx&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// send index
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">recvx&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// receive index
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">recvq&lt;/span> &lt;span style="color:#a6e22e">waitq&lt;/span> &lt;span style="color:#75715e">// list of recv waiters
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">sendq&lt;/span> &lt;span style="color:#a6e22e">waitq&lt;/span> &lt;span style="color:#75715e">// list of send waiters
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// lock protects all fields in hchan, as well as several
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// fields in sudogs blocked on this channel.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Do not change another G&amp;#39;s status while holding this lock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// (in particular, do not ready a G), as this can deadlock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// with stack shrinking.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">lock&lt;/span> &lt;span style="color:#a6e22e">mutex&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>环形队列
chan内部实现了一个环形队列,队列长度在chan创建时指定
sendx: 队尾, 写入位
recvx: 队首, 读取位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等待队列&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>goroutine从chan读 -&amp;gt; buf为空或没有buf -&amp;gt; 当前goroutine阻塞 -&amp;gt; 加入recvq&lt;/li>
&lt;li>goroutine向chan写 -&amp;gt; buf已满或没有buf -&amp;gt; 当前goroutine阻塞 -&amp;gt; 加入sendq
处于等待队列中的协程会在其他协程操作管道时被唤醒:&lt;/li>
&lt;li>因读阻塞的协程会被向管道写入的协程唤醒&lt;/li>
&lt;li>因写阻塞的协程会被从管道读取的协程唤醒&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>Invariants:
At least one of c.sendq and c.recvq is empty,
except for the case of an unbuffered channel with a single goroutine
blocked on it for both sending and receiving using a select statement,
in which case the length of c.sendq and c.recvq is limited only by the
size of the select statement.
For buffered channels, also:
c.qcount &amp;gt; 0 implies that c.recvq is empty.
c.qcount &amp;lt; c.dataqsiz implies that c.sendq is empty.
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>类型信息&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>一个管道只能传递一种类型的值&lt;/li>
&lt;li>如果需要管道传递任意类型的数据,可以使用interface{}类型&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>互斥锁
一个管道同时仅允许被一个协程读写&lt;/li>
&lt;/ol>
&lt;h2 id="管道操作-1">管道操作&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>创建管道
创建管道 -&amp;gt; 初始化hchan结构&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写入管道
trick:
当接收队列recvq不为空时,说明缓冲区中没有数据但有协程在等待数据
会把数据直接传递给recvq队列中的第一个协程,而不必再写入缓冲区&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读出管道
trick:
当等待发送队列sendq不为空,且没有缓冲区,
那么此时将直接从sendq队列的第一个协程中获取数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关闭管道
关闭管道时会把recvq中的协程全部唤醒, 协程会获取对应类型的零值
同时会把sendq队列中的协程全部唤醒,协程会触发panic&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>会触发panic的操作还有:&lt;/p>
&lt;ul>
&lt;li>关闭值为nil的管道&lt;/li>
&lt;li>关闭已经被关闭的管道&lt;/li>
&lt;li>向已经关闭的管道写入数据&lt;/li>
&lt;/ul>
&lt;h2 id="常见用法">常见用法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>单向管道&lt;/p>
&lt;/li>
&lt;li>
&lt;p>select
使用select可以监控多个管道
select的case语句读管道时不会阻塞&lt;/p>
&lt;/li>
&lt;li>
&lt;p>for-range
for-range可以持续从管道中读出数据,当管道中没有数据时会阻塞当前协程&lt;/p>
&lt;/li>
&lt;/ul></content></item><item><title>Bloom Filter VS Ribbon Filter</title><link>https://xujiajiadexiaokeai.github.io/2022-07-01/bloomfilter-vs-ribbonfilter/</link><pubDate>Fri, 01 Jul 2022 10:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-01/bloomfilter-vs-ribbonfilter/</guid><description>https://developer.aliyun.com/article/980796
由于Bloom Filter只需要占用极小的空间，便可以给出”可能存在“和”肯定不存在“的存在性判断，因此可以提前过滤掉许多不必要的数据块，从而节省了大量的磁盘IO</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://developer.aliyun.com/article/980796">https://developer.aliyun.com/article/980796&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>由于Bloom Filter只需要占用极小的空间，便可以给出”可能存在“和”肯定不存在“的存在性判断，因此可以提前过滤掉许多不必要的数据块，从而节省了大量的磁盘IO&lt;/p></content></item><item><title>Linux Shell Notes</title><link>https://xujiajiadexiaokeai.github.io/2022-06-06/shell-notes/</link><pubDate>Mon, 06 Jun 2022 11:03:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-06-06/shell-notes/</guid><description>变量 变量名只能包含数字、字母、下划线
Shell 提示符 要显示提示符的当前格式，可以使用 echo 输出 PS1 和 PS2
echo $PS1 echo $PS2 下表展示了可以在 PS1 和 PS2 中使用的特殊字符。
字符 描述 \a 铃声字符 \d 格式为“日 月 年”的日期 \e ASCII转义字符 \h 本地主机名 \H 完全合格的限定域主机名 \j shell当前管理的作业数 \1 shell终端设备名的基本名称 \n ASCII换行字符 \r ASCII回车 \s shell的名称 \t 格式为“小时:分钟:秒”的24小时制的当前时间 \T 格式为“小时:分钟:秒”的12小时制的当前时间 @ 格式为am/pm的12小时制的当前时间 \u 当前用户的用户名 \v bash shell的版本 \V bash shell的发布级别 \w 当前工作目录 \W 当前工作目录的基本名称 !</description><content>&lt;h1 id="变量">变量&lt;/h1>
&lt;p>变量名只能包含数字、字母、下划线&lt;/p>
&lt;h2 id="shell-提示符">Shell 提示符&lt;/h2>
&lt;p>要显示提示符的当前格式，可以使用 echo 输出 PS1 和 PS2&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">echo $PS1
echo $PS2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下表展示了可以在 PS1 和 PS2 中使用的特殊字符。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字符&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>\a&lt;/td>
&lt;td>铃声字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\d&lt;/td>
&lt;td>格式为“日 月 年”的日期&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\e&lt;/td>
&lt;td>ASCII转义字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\h&lt;/td>
&lt;td>本地主机名&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\H&lt;/td>
&lt;td>完全合格的限定域主机名&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\j&lt;/td>
&lt;td>shell当前管理的作业数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\1&lt;/td>
&lt;td>shell终端设备名的基本名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\n&lt;/td>
&lt;td>ASCII换行字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\r&lt;/td>
&lt;td>ASCII回车&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\s&lt;/td>
&lt;td>shell的名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\t&lt;/td>
&lt;td>格式为“小时:分钟:秒”的24小时制的当前时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\T&lt;/td>
&lt;td>格式为“小时:分钟:秒”的12小时制的当前时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>@&lt;/td>
&lt;td>格式为am/pm的12小时制的当前时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\u&lt;/td>
&lt;td>当前用户的用户名&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\v&lt;/td>
&lt;td>bash shell的版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\V&lt;/td>
&lt;td>bash shell的发布级别&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\w&lt;/td>
&lt;td>当前工作目录&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\W&lt;/td>
&lt;td>当前工作目录的基本名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!&lt;/td>
&lt;td>该命令的bash shell历史数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>#&lt;/td>
&lt;td>该命令的命令数量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$&lt;/td>
&lt;td>如果是普通用户，则为美元符号$；如果超级用户（root 用户），则为井号#。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\nnn&lt;/td>
&lt;td>对应于八进制值 nnn 的字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>\&lt;/td>
&lt;td>斜杠&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[&lt;/td>
&lt;td>控制码序列的开头&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>]&lt;/td>
&lt;td>控制码序列的结尾&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>注意，所有的特殊字符均以反斜杠&lt;code>\&lt;/code>开头，目的是与普通字符区分开来。您可以在命令提示符中使用以上任何特殊字符的组合。&lt;/p>
&lt;h2 id="赋值">赋值&lt;/h2>
&lt;p>&lt;code>=&lt;/code> 周围不能有空格&lt;/p>
&lt;p>variable=&amp;lsquo;value&amp;rsquo;&lt;/p>
&lt;p>以单引号&lt;code>' '&lt;/code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。&lt;/p>
&lt;p>variable=&amp;ldquo;value&amp;rdquo;&lt;/p>
&lt;p>以双引号&amp;quot; &amp;ldquo;包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。&lt;/p>
&lt;h3 id="将命令的结果赋值给变量">将命令的结果赋值给变量&lt;/h3>
&lt;p>variable=&lt;code>command&lt;/code>&lt;/p>
&lt;p>variable=$(command) // 推荐使用这种&lt;/p>
&lt;h2 id="只读变量">只读变量&lt;/h2>
&lt;p>readonly a&lt;/p>
&lt;h2 id="删除变量">删除变量&lt;/h2>
&lt;p>unset a&lt;/p>
&lt;h2 id="变量类型">变量类型&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>局部变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>环境变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>shell变量&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="特殊变量">特殊变量&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>变量&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0&lt;/td>
&lt;td>当前脚本的文件名&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$n&lt;/td>
&lt;td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$#&lt;/td>
&lt;td>传递给脚本或函数的参数个数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$*&lt;/td>
&lt;td>传递给脚本或函数的所有参数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$@&lt;/td>
&lt;td>传递给脚本或函数的所有参数。被双引号(&amp;rdquo; &amp;ldquo;)包含时，与 $* 稍有不同&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$?&lt;/td>
&lt;td>上个命令的退出状态，或函数的返回值。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$$&lt;/td>
&lt;td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="命令替换">命令替换&lt;/h1>
&lt;p>语法: &lt;code>command&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">DATE=`date`
echo &amp;#34;Date is $DATE&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="变量替换">变量替换&lt;/h1>
&lt;p>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的&lt;/p>
&lt;p>可以使用的变量替换形式：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>形式&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>${var}&lt;/td>
&lt;td>变量本来的值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>${var:-word}&lt;/td>
&lt;td>如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>${var:=word}&lt;/td>
&lt;td>如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>${var:?message}&lt;/td>
&lt;td>如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>${var:+word}&lt;/td>
&lt;td>如果变量 var 被定义，那么返回 word，但不改变 var 的值。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="获取字符串长度">获取字符串长度&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">string=&amp;#34;abcd&amp;#34;
echo ${#string} #输出 4
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="提取子字符串">提取子字符串&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">string=&amp;#34;alibaba is a great company&amp;#34;
echo ${string:1:4} #输出liba
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="查找子字符串">查找子字符串&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">string=&amp;#34;alibaba is a great company&amp;#34;
echo `expr index &amp;#34;$string&amp;#34; is`
&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>MacOS用户快速上手Cilium eBPF</title><link>https://xujiajiadexiaokeai.github.io/2022-03-06/cilium-ebpf-quick-tutorial/</link><pubDate>Sun, 06 Mar 2022 20:41:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-03-06/cilium-ebpf-quick-tutorial/</guid><description>机器: Macbook Pro 13inch 2015款
系统: macOS Mojave 10.14.6
安装虚拟机 首先需要一个linux发行版,选择安装一个虚拟机来装Ubuntu,找到了multipass.
multipass是Ubuntu旗下一款虚拟机产品,适用个各个平台,可以在本地快速的开启一个虚拟机
Multipass orchestrates virtual Ubuntu instances
版本: 1.8.1+mac
multipass version 安装完成后,指定VirtualBox为vm driver
sudo multipass set local.driver=virtualbox Using VirtualBox in Multipass on macOS | Multipass documentation
快速启动一台当前最新LTS版的Ubuntu虚拟机并等待启动完成
$ multipass launch --name ubuntu 配置ssh 这一步主要是为了能够使用开发机上vscode来连接到虚拟机进行coding,毕竟如果不是很熟悉使用vim的开发者,在terminal内编程还是有点困难
multipass启动的虚拟机默认开放22端口,也内置了ssh server.但是,因为处于不同网段,如果想要公开这个端口供开发机连接,需要使用VirtualBox的端口转发功能,将22端口映射到宿主机的某个端口,这样就提供了外部访问的能力.在终端输入:
sudo VBoxManage controlvm &amp;#34;ubuntu&amp;#34; natpf1 &amp;#34;myservice,tcp,,22,,2222&amp;#34; 该命令为ubuntu实例(也就是虚拟机)在natpf1网卡上添加了一条转发规则,规则名叫做&amp;quot;myservice&amp;quot;,tcp协议,将所有到达宿主机2222端口的流量转发到实例的22端口上
局域网记得锁定ip
安装go sudo snap install go --classic 克隆cilium/ebpf项目 git clone https://github.com/cilium/ebpf.git 运行example cd ebpf/examples/ go run -exec sudo .</description><content>&lt;p>机器: Macbook Pro 13inch 2015款&lt;/p>
&lt;p>系统: macOS Mojave 10.14.6&lt;/p>
&lt;h1 id="安装虚拟机">安装虚拟机&lt;/h1>
&lt;p>首先需要一个linux发行版,选择安装一个虚拟机来装Ubuntu,找到了multipass.&lt;/p>
&lt;p>multipass是Ubuntu旗下一款虚拟机产品,适用个各个平台,可以在本地快速的开启一个虚拟机&lt;/p>
&lt;p>&lt;a href="https://multipass.run/">Multipass orchestrates virtual Ubuntu instances&lt;/a>&lt;/p>
&lt;p>版本: 1.8.1+mac&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">multipass version
&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装完成后,指定VirtualBox为vm driver&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">sudo multipass set local.driver=virtualbox
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://multipass.run/docs/using-virtualbox-in-multipass-macos">Using VirtualBox in Multipass on macOS | Multipass documentation&lt;/a>&lt;/p>
&lt;p>快速启动一台当前最新LTS版的Ubuntu虚拟机并等待启动完成&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">$ multipass launch --name ubuntu
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置ssh">配置ssh&lt;/h1>
&lt;p>这一步主要是为了能够使用开发机上vscode来连接到虚拟机进行coding,毕竟如果不是很熟悉使用vim的开发者,在terminal内编程还是有点困难&lt;/p>
&lt;p>multipass启动的虚拟机默认开放22端口,也内置了ssh server.但是,因为处于不同网段,如果想要公开这个端口供开发机连接,需要使用&lt;a href="https://www.virtualbox.org/manual/ch06.html#natforward">&lt;strong>VirtualBox的端口转发&lt;/strong>&lt;/a>功能,将22端口映射到宿主机的某个端口,这样就提供了外部访问的能力.在终端输入:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">sudo VBoxManage controlvm &amp;#34;ubuntu&amp;#34; natpf1 &amp;#34;myservice,tcp,,22,,2222&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>该命令为ubuntu实例(也就是虚拟机)在natpf1网卡上添加了一条转发规则,规则名叫做&amp;quot;myservice&amp;quot;,tcp协议,将所有到达宿主机2222端口的流量转发到实例的22端口上&lt;/p>
&lt;p>局域网记得锁定ip&lt;/p>
&lt;h1 id="安装go">安装go&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">sudo snap install go --classic
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="克隆ciliumebpf项目">克隆cilium/ebpf项目&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">git clone https://github.com/cilium/ebpf.git
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="运行example">运行example&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">cd ebpf/examples/
go run -exec sudo ./kprobe
&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>memory-management Notes</title><link>https://xujiajiadexiaokeai.github.io/2022-02-28/memory-management/</link><pubDate>Mon, 28 Feb 2022 17:07:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-02-28/memory-management/</guid><description>虚拟内存-&amp;gt;物理内存
虚拟存储器
虚拟存储器解决了三个根本需求:
确保可以运行存储空间需求比实际内存空间大的用户进程
确保为用户程序分配的内存空间是连续的
确保多个用户程序之间的内存空间互相隔离
虚拟存储器能力:
隔离性和连续性
内-外存空间交换能力
基于局部性原理实现的内-外存交换技术
时间局部性
空间局部性
是一种时间换空间策略
Swap交换分区
虚拟地址空间编址能力
虚拟地址空间隔离能力
页式管理
页不是程序独立模块对应的逻辑实体,所以处理、保护和共享都不及段来的方便.同时因为页要比段小的多,在进行交换时,不会出现段交换那般卡顿.所以页式存储管理方式会更加的收到欢迎,
页式存储在加载程序时,不需要一次性加载完全部程序,由操作系统调度.当CPU要读取特定的页,但却发现页的内容没有加载,会触发来自CPU的缺页错误.然后找到对应的页并加载到内存中.
通过这种方式可以运行远大于实例物理内存的程序,但相对的执行效率会下降
页表管理机制中有两个重要概念:
快表(TLB) 目的: 为了解决虚拟地址到物理地址的转换速度.
流程:
1. 根据虚拟地址中的页号查快表 1. 如果该页在快表中,直接从快表中读取相应的物理地址 1. 如果该页不再快表中,就访问内存中的页表,再从页表中得到物理地址,同时将页表中的该映射表项添加到快表中 1. 当快表填满后,又要登记新页时, 就按照一定的淘汰掉快表中的一个页 多级页表 目的: 为了避免把全部页表一直放在内存中占用过多空间
分页与分段的异同:
共同点:
分页和分段都是为了提高内存利用率,较少内存碎片
页和段都是离散存储的,所以两者都是离散分配内存的方式.但是每个页和段中的内存是连续的
区别:
页的大小是固定的,由操作系统决定;而段的大小不固定,取决于当前运行的程序
分页仅仅是为了满足操作系统内存管理的需求,而段是逻辑信息的单位,在程序中可以体现为代码段,数据段,能够更好满足用户的需要.
因为操作系统的虚拟地址空间大小都是一定的，整片虚拟地址空间被均匀分成了 N 个大小相同的内存页，所以内存页的大小最终会决定每个进程中页表项的层级结构和具体数量，虚拟页的大小越小，单个进程中的页表项和虚拟页也就越多。
一个完整的页表翻译和查找的过程叫作页表查询(Translation Table Walk), 页表查询的过程由硬件自动完成,但是页表的维护需要软件来完成
基于页表的虚实地址转换原理
段式管理 段页式管理</description><content>&lt;p>虚拟内存-&amp;gt;物理内存&lt;/p>
&lt;p>虚拟存储器&lt;/p>
&lt;p>虚拟存储器解决了三个根本需求:&lt;/p>
&lt;p>确保可以运行存储空间需求比实际内存空间大的用户进程&lt;/p>
&lt;p>确保为用户程序分配的内存空间是连续的&lt;/p>
&lt;p>确保多个用户程序之间的内存空间互相隔离&lt;/p>
&lt;p>虚拟存储器能力:&lt;/p>
&lt;p>&lt;strong>隔离性&lt;/strong>和&lt;strong>连续性&lt;/strong>&lt;/p>
&lt;p>&lt;strong>内-外存空间交换能力&lt;/strong>&lt;/p>
&lt;p>基于局部性原理实现的内-外存交换技术&lt;/p>
&lt;p>时间局部性&lt;/p>
&lt;p>空间局部性&lt;/p>
&lt;p>是一种时间换空间策略&lt;/p>
&lt;p>Swap交换分区&lt;/p>
&lt;p>&lt;strong>虚拟地址空间编址能力&lt;/strong>&lt;/p>
&lt;p>&lt;strong>虚拟地址空间隔离能力&lt;/strong>&lt;/p>
&lt;p>页式管理&lt;/p>
&lt;p>页不是程序独立模块对应的逻辑实体,所以处理、保护和共享都不及段来的方便.同时因为页要比段小的多,在进行交换时,不会出现段交换那般卡顿.所以页式存储管理方式会更加的收到欢迎,&lt;/p>
&lt;p>页式存储在加载程序时,不需要一次性加载完全部程序,由操作系统调度.当CPU要读取特定的页,但却发现页的内容没有加载,会触发来自CPU的缺页错误.然后找到对应的页并加载到内存中.&lt;/p>
&lt;p>通过这种方式可以运行远大于实例物理内存的程序,但相对的执行效率会下降&lt;/p>
&lt;p>页表管理机制中有两个重要概念:&lt;/p>
&lt;h3 id="快表tlb">快表(TLB)&lt;/h3>
&lt;p>目的: 为了解决虚拟地址到物理地址的转换速度.&lt;/p>
&lt;p>流程:&lt;/p>
&lt;pre>&lt;code>1. 根据虚拟地址中的页号查快表
1. 如果该页在快表中,直接从快表中读取相应的物理地址
1. 如果该页不再快表中,就访问内存中的页表,再从页表中得到物理地址,同时将页表中的该映射表项添加到快表中
1. 当快表填满后,又要登记新页时, 就按照一定的淘汰掉快表中的一个页
&lt;/code>&lt;/pre>
&lt;h3 id="多级页表">多级页表&lt;/h3>
&lt;p>目的: 为了避免把全部页表一直放在内存中占用过多空间&lt;/p>
&lt;p>分页与分段的异同:&lt;/p>
&lt;p>共同点:&lt;/p>
&lt;p>分页和分段都是为了提高内存利用率,较少内存碎片&lt;/p>
&lt;p>页和段都是离散存储的,所以两者都是离散分配内存的方式.但是每个页和段中的内存是连续的&lt;/p>
&lt;p>区别:&lt;/p>
&lt;p>页的大小是固定的,由操作系统决定;而段的大小不固定,取决于当前运行的程序&lt;/p>
&lt;p>分页仅仅是为了满足操作系统内存管理的需求,而段是逻辑信息的单位,在程序中可以体现为代码段,数据段,能够更好满足用户的需要.&lt;/p>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312f5c40cf69de4112c2471cf710bd622426?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3NzgyNTE1OSwiaWF0IjoxNjc3MjIwMzU5LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmY1YzQwY2Y2OWRlNDExMmMyNDcxY2Y3MTBiZDYyMjQyNiJ9.cQU2BY-HE-NC92QSshNfxpwF6YiCbXhK3p_gSVbUbCU&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;p>因为操作系统的虚拟地址空间大小都是一定的，整片虚拟地址空间被均匀分成了 N 个大小相同的内存页，所以内存页的大小最终会决定每个进程中页表项的层级结构和具体数量，虚拟页的大小越小，单个进程中的页表项和虚拟页也就越多。&lt;/p>
&lt;p>一个完整的页表翻译和查找的过程叫作页表查询(Translation Table Walk), 页表查询的过程由硬件自动完成,但是页表的维护需要软件来完成&lt;/p>
&lt;p>基于页表的虚实地址转换原理&lt;/p>
&lt;h1 id="段式管理">段式管理&lt;/h1>
&lt;h1 id="段页式管理">段页式管理&lt;/h1></content></item><item><title>Design Patterns Notes</title><link>https://xujiajiadexiaokeai.github.io/2022-01-15/design-patterns/</link><pubDate>Sat, 15 Jan 2022 03:06:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-01-15/design-patterns/</guid><description>创建型模式(Creational Pattern) 单例模式(Singleton Pattern) 主要用于保证一个类仅有一个实例,并提供一个访问它的全局访问点
(1) 限制调用者直接实例化该对象
(2) 为该对象的单例提供一个全局唯一的访问方法
package msgpool ... // 消息池 type messagePool struct { pool *sync.Pool } // 消息池单例 var msgPool = &amp;amp;messagePool { // 如果消息池里没有消息,则新建一个Count值为0的Message实例 pool: &amp;amp;sync.Pool{New: func() interface{} { return &amp;amp;Message{Count: 0}}, } // 访问消息池单例的唯一方法 func Instence() *messagePool { return msgPool } // 向消息池里添加消息 func (m *messagePool) AddMsg(msg *Message) { m.pool.Put(msg) } // 从消息池里获取消息 func (m *messagePool) GetMsg() *Message { return m.pool.Get().(*Message) } .</description><content>&lt;h1 id="创建型模式creational-pattern">创建型模式(Creational Pattern)&lt;/h1>
&lt;h3 id="单例模式singleton-pattern">单例模式(Singleton Pattern)&lt;/h3>
&lt;p>主要用于保证一个类仅有一个实例,并提供一个访问它的全局访问点&lt;/p>
&lt;p>(1) 限制调用者直接实例化该对象&lt;/p>
&lt;p>(2) 为该对象的单例提供一个全局唯一的访问方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">msgpool&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 消息池
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">messagePool&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">pool&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Pool&lt;/span>
}
&lt;span style="color:#75715e">// 消息池单例
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">msgPool&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">messagePool&lt;/span> {
&lt;span style="color:#75715e">// 如果消息池里没有消息,则新建一个Count值为0的Message实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pool&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Pool&lt;/span>{&lt;span style="color:#a6e22e">New&lt;/span>: &lt;span style="color:#66d9ef">func&lt;/span>() &lt;span style="color:#66d9ef">interface&lt;/span>{} { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span>{&lt;span style="color:#a6e22e">Count&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>}},
}
&lt;span style="color:#75715e">// 访问消息池单例的唯一方法
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Instence&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">messagePool&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">msgPool&lt;/span>
}
&lt;span style="color:#75715e">// 向消息池里添加消息
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">messagePool&lt;/span>) &lt;span style="color:#a6e22e">AddMsg&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span>) {
&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">pool&lt;/span>.&lt;span style="color:#a6e22e">Put&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
}
&lt;span style="color:#75715e">// 从消息池里获取消息
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">messagePool&lt;/span>) &lt;span style="color:#a6e22e">GetMsg&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">pool&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>().(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span>)
}
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMessagePool&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#a6e22e">msg0&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">msgpool&lt;/span>.&lt;span style="color:#a6e22e">Instance&lt;/span>().&lt;span style="color:#a6e22e">GetMsg&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">msg0&lt;/span>.&lt;span style="color:#a6e22e">Count&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expect msg count %d, but actual %d.&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">msg0&lt;/span>.&lt;span style="color:#a6e22e">Count&lt;/span>)
}
&lt;span style="color:#a6e22e">msg0&lt;/span>.&lt;span style="color:#a6e22e">Count&lt;/span> = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#a6e22e">msgpool&lt;/span>.&lt;span style="color:#a6e22e">Instance&lt;/span>().&lt;span style="color:#a6e22e">AddMsg&lt;/span>(&lt;span style="color:#a6e22e">msg0&lt;/span>)
&lt;span style="color:#a6e22e">msg1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">msgpool&lt;/span>.&lt;span style="color:#a6e22e">Instance&lt;/span>().&lt;span style="color:#a6e22e">GetMsg&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">msg1&lt;/span>.&lt;span style="color:#a6e22e">Count&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expect msg count %d, but actual %d.&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">msg1&lt;/span>.&lt;span style="color:#a6e22e">Count&lt;/span>)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>饿汉模式与懒汉模式&lt;/p>
&lt;p>懒汉模式会带来线程安全问题,可以通过普通加锁,或者双重检验锁来优化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// 单例模式的“懒汉模式”实现
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">msgpool&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">once&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Once&lt;/span>{}
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">msgPool&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">messagePool&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Instance&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">messagePool&lt;/span> {
&lt;span style="color:#75715e">// 在匿名函数中实现初始化逻辑,Go语言保证只会调用一次
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">once&lt;/span>.&lt;span style="color:#a6e22e">Do&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;span style="color:#a6e22e">msgPool&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">messagePool&lt;/span>{
&lt;span style="color:#75715e">// 如果消息池里没有消息, 则新建一个Count值为0的Message实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">pool&lt;/span>:&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Poll&lt;/span>{&lt;span style="color:#a6e22e">New&lt;/span>: &lt;span style="color:#66d9ef">func&lt;/span>() &lt;span style="color:#66d9ef">interface&lt;/span>{} {&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span>{&lt;span style="color:#a6e22e">Count&lt;/span>:&lt;span style="color:#ae81ff">0&lt;/span>} }},
}
})
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">msgPool&lt;/span>
}
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="建造者模式builder-pattern">建造者模式(Builder Pattern)&lt;/h3>
&lt;p>(1) 封装复杂对象的创建过程,使对象使用者不感知复杂的创建逻辑&lt;/p>
&lt;p>(2) 可以一步步按照顺序对成员进行赋值,或者创建嵌套对象,并最终完成目标对象的创建&lt;/p>
&lt;p>(3) 对多个对象复用同样的对象创建逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Header&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Header&lt;/span>
&lt;span style="color:#a6e22e">Body&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Body&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Header&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">SrcAddr&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">SrcPort&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;span style="color:#a6e22e">DestAddr&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">DestPort&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;span style="color:#a6e22e">Items&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>] &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Body&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Item&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// Message对象的Builder对象
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">builder&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">once&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Once&lt;/span>
&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span>
}
&lt;span style="color:#75715e">// 返回Builder对象
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Builder&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>{
&lt;span style="color:#a6e22e">once&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Once&lt;/span>{},
&lt;span style="color:#a6e22e">msg&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span>{&lt;span style="color:#a6e22e">Header&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Header&lt;/span>{}, &lt;span style="color:#a6e22e">Body&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Body&lt;/span>{}},
}
}
&lt;span style="color:#75715e">// 以下是对Message成员的构建方法
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>) &lt;span style="color:#a6e22e">WithSrcAddr&lt;/span>(&lt;span style="color:#a6e22e">srcAddr&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span> {
&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">SrcAddr&lt;/span> = &lt;span style="color:#a6e22e">srcAddr&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>) &lt;span style="color:#a6e22e">WithSrcPort&lt;/span>(&lt;span style="color:#a6e22e">srcPort&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span> {
&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">SrcPort&lt;/span> = &lt;span style="color:#a6e22e">srcPort&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>) &lt;span style="color:#a6e22e">WithDestAddr&lt;/span>(&lt;span style="color:#a6e22e">destAddr&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span> {
&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">DestAddr&lt;/span> = &lt;span style="color:#a6e22e">destAddr&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>) &lt;span style="color:#a6e22e">WithHeaderItem&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span> {
&lt;span style="color:#75715e">// 保证map只初始化一次
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">once&lt;/span>.&lt;span style="color:#a6e22e">Do&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span> = make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>)
})
&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>[&lt;span style="color:#a6e22e">key&lt;/span>] = &lt;span style="color:#a6e22e">value&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>) &lt;span style="color:#a6e22e">WithBodyItem&lt;/span>(&lt;span style="color:#a6e22e">record&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span> {
&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span> = append(&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>, &lt;span style="color:#a6e22e">record&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">builder&lt;/span>) &lt;span style="color:#a6e22e">Build&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">msg&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestMessageBuilder&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#75715e">// 使用消息建造者进行对象创建
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Builder&lt;/span>().
&lt;span style="color:#a6e22e">WithSrcAddr&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;192.168.0.1&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">WithSrcPost&lt;/span>(&lt;span style="color:#ae81ff">1234&lt;/span>).
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#a6e22e">Build&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">SrcAddr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;192.168.0.1&amp;#34;&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expect src address 192.168.0.1, but actual %d.&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">message&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">SrcAddr&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;record1&amp;#34;&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expect body item0 record1, but actual %s.&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">message&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="工厂方法模式factory-method-pattern">工厂方法模式(Factory Method Pattern)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">event&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Type&lt;/span> &lt;span style="color:#66d9ef">uint8&lt;/span>
&lt;span style="color:#75715e">// 事件类型定义
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> (
&lt;span style="color:#a6e22e">Start&lt;/span> &lt;span style="color:#a6e22e">Type&lt;/span> = &lt;span style="color:#66d9ef">iota&lt;/span>
&lt;span style="color:#a6e22e">End&lt;/span>
)
&lt;span style="color:#75715e">// 事件抽象接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Event&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">EventType&lt;/span>() &lt;span style="color:#a6e22e">Type&lt;/span>
&lt;span style="color:#a6e22e">Content&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#75715e">// 开始事件,实现了Event接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">StartEvent&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{
&lt;span style="color:#a6e22e">content&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 结束事件,实现了Event接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">EndEvent&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{
&lt;span style="color:#a6e22e">content&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">event&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 事件工厂对象
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Factory&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}
&lt;span style="color:#75715e">// 根据事件类型创建具体事件
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">e&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Factory&lt;/span>) &lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">etype&lt;/span> &lt;span style="color:#a6e22e">Type&lt;/span>) &lt;span style="color:#a6e22e">Event&lt;/span> {
&lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">etype&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">Start&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">StartEvent&lt;/span>{
&lt;span style="color:#a6e22e">content&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;this is start event&amp;#34;&lt;/span>,
}
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">End&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">EndEvent&lt;/span>{
&lt;span style="color:#a6e22e">content&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;this is end event&amp;#34;&lt;/span>,
}
&lt;span style="color:#66d9ef">default&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">event&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestEvent&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#a6e22e">e&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">OfStart&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EventType&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expect event.Start, but actual %v.&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EventType&lt;/span>())
}
&lt;span style="color:#a6e22e">e&lt;/span> = &lt;span style="color:#a6e22e">factory&lt;/span>.&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">End&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EventType&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">End&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;expect event.End, but actual %v.&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">e&lt;/span>.&lt;span style="color:#a6e22e">EventType&lt;/span>())
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="抽象工厂模式abstract-factory-pattern">抽象工厂模式(Abstract Factory Pattern)&lt;/h3>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312dac721ae2e5db5dfd73d0091ddfb92a9e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3NzgyNTE0NCwiaWF0IjoxNjc3MjIwMzQ0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmRhYzcyMWFlMmU1ZGI1ZGZkNzNkMDA5MWRkZmI5MmE5ZSJ9.hS5QO-KPxmoLc1gElEZACQdg8Z29DkGOyKs6l7Cnk0U&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312d15f97489776c7f78378dcfecc2069f7e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3NzgyNTE0NCwiaWF0IjoxNjc3MjIwMzQ0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmQxNWY5NzQ4OTc3NmM3Zjc4Mzc4ZGNmZWNjMjA2OWY3ZSJ9.kv-n_k3L1VhlA53YDLWF9IscPVfEJTmkmoU15NILWe0&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 插件抽象接口定义
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Plugin&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}
&lt;span style="color:#75715e">// 输入插件,用于接收消息
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Input&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Receive&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#75715e">// 过滤插件,用于处理消息
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Fliter&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#75715e">// 输出插件,用于发送消息
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Output&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Send&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>)
}
&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 消息管道的定义
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Pipeline&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Input&lt;/span>
&lt;span style="color:#a6e22e">filter&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Filter&lt;/span>
&lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Output&lt;/span>
}
&lt;span style="color:#75715e">// 一个消息的处理流程为 input -&amp;gt; filter -&amp;gt; output
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Pipeline&lt;/span>) &lt;span style="color:#a6e22e">Exec&lt;/span>() {
&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">intput&lt;/span>.&lt;span style="color:#a6e22e">Receive&lt;/span>()
&lt;span style="color:#a6e22e">msg&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">output&lt;/span>.&lt;span style="color:#a6e22e">Send&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// input插件名称与类型的映射关系,主要用于通过反射创建input对象
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">inputNames&lt;/span> = make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>)
&lt;span style="color:#75715e">// Hello input插件,接收”Hello World“消息
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">HelloInput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">h&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">HelloInput&lt;/span>) &lt;span style="color:#a6e22e">Receive&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>
}
&lt;span style="color:#75715e">// 初始化input插件映射关系表
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;span style="color:#a6e22e">inputNames&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>] = &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">TypeOf&lt;/span>(&lt;span style="color:#a6e22e">HelloInput&lt;/span>{})
}
&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// filter插件名称与类型的映射关系.主要用于通过反射创建filter对象
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">filterNames&lt;/span> = make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>)
&lt;span style="color:#75715e">// Upper filter插件,将消息全部字母转成大写
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UpperFilter&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">UpperFilter&lt;/span>) &lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">ToUpper&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
}
&lt;span style="color:#75715e">// 初始化filter插件映射关系表
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;span style="color:#a6e22e">filterNames&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;upper&amp;#34;&lt;/span>] = &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">TypeOf&lt;/span>(&lt;span style="color:#a6e22e">UpperFilter&lt;/span>{})
}
&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// output插件名称与类型的映射关系,主要用于通过反射创建output对象
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">outputNames&lt;/span> = make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>)
&lt;span style="color:#75715e">// Console output插件,将消息输出到控制台上
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ConsoleOutput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ConsoleOutput&lt;/span>) &lt;span style="color:#a6e22e">Send&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
}
&lt;span style="color:#75715e">// 初始化output插件映射关系表
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;span style="color:#a6e22e">outputNames&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;console&amp;#34;&lt;/span>] = &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">TypeOf&lt;/span>(&lt;span style="color:#a6e22e">ConsoleOutput&lt;/span>{})
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 插件工厂接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Factory&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span>) &lt;span style="color:#a6e22e">Plugin&lt;/span>
}
&lt;span style="color:#75715e">// input插件工厂对象,实现Factory接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">InputFactory&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}
&lt;span style="color:#75715e">// 读取配置,通过反射机制进行对象实例化
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">InputFactory&lt;/span>) &lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span>) &lt;span style="color:#a6e22e">Plugin&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">inputNames&lt;/span>[&lt;span style="color:#a6e22e">conf&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>]
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>).&lt;span style="color:#a6e22e">Interface&lt;/span>().(&lt;span style="color:#a6e22e">Plugin&lt;/span>)
}
&lt;span style="color:#75715e">// filter和output插件工厂实现类似
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FilterFactory&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FilterFactory&lt;/span>) &lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span>) &lt;span style="color:#a6e22e">Plugin&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">filterNames&lt;/span>[&lt;span style="color:#a6e22e">conf&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>]
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>).&lt;span style="color:#a6e22e">Interface&lt;/span>().(&lt;span style="color:#a6e22e">Plugin&lt;/span>)
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">OutputFactory&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">o&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">OutputFactory&lt;/span>) &lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span>) &lt;span style="color:#a6e22e">Plugin&lt;/span> {
&lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">outputNames&lt;/span>[&lt;span style="color:#a6e22e">conf&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>]
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>).&lt;span style="color:#a6e22e">Interface&lt;/span>().(&lt;span style="color:#a6e22e">Plugin&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 保存用于创建Plugin的工厂实例,其中map的key为插件类型,value为抽象工厂接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">pluginFactories&lt;/span> = make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>]&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Factory&lt;/span>)
&lt;span style="color:#75715e">// 根据plugin.Type返回对应Plugin类型的工厂实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">factoryOf&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>) &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Factory&lt;/span> {
&lt;span style="color:#a6e22e">factory&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pluginFactories&lt;/span>[&lt;span style="color:#a6e22e">t&lt;/span>]
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">factory&lt;/span>
}
&lt;span style="color:#75715e">// pipeline工厂方法,根据配置创建一个Pipeline实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Of&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Pipeline&lt;/span> {
&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Pipeline&lt;/span>{}
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">intput&lt;/span> = &lt;span style="color:#a6e22e">factoryOf&lt;/span>(&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">InputType&lt;/span>).&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span>.&lt;span style="color:#a6e22e">Input&lt;/span>).(&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Input&lt;/span>)
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span> = &lt;span style="color:#a6e22e">factoryOf&lt;/span>(&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">FilterType&lt;/span>).&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span>.&lt;span style="color:#a6e22e">Filter&lt;/span>).(&lt;span style="color:#a6e22e">pulgin&lt;/span>.&lt;span style="color:#a6e22e">Filter&lt;/span>)
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">output&lt;/span> = &lt;span style="color:#a6e22e">factoryOf&lt;/span>(&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">OutputType&lt;/span>).&lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span>.&lt;span style="color:#a6e22e">Output&lt;/span>).(&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Output&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>
)
&lt;span style="color:#75715e">// 初始化插件工厂对象
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;span style="color:#a6e22e">pluginFactories&lt;/span>[&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">InputType&lt;/span>] = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">InputFactory&lt;/span>{}
&lt;span style="color:#a6e22e">pluginFactories&lt;/span>[&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">FilterType&lt;/span>] = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">FilterFactory&lt;/span>{}
&lt;span style="color:#a6e22e">pluginFactories&lt;/span>[&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">OutputType&lt;/span>] = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">OutputFactory&lt;/span>{}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestPipeline&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#75715e">// 其中pipeline.DefaultConfig()的配置内容见[抽象工厂模式示例图]
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 消息处理流程为 HelloInput -&amp;gt; UpperFilter -&amp;gt; ConsoleOutput
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>.&lt;span style="color:#a6e22e">Of&lt;/span>(&lt;span style="color:#a6e22e">pipeline&lt;/span>.&lt;span style="color:#a6e22e">Deafult&lt;/span>.&lt;span style="color:#a6e22e">Config&lt;/span>())
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Exec&lt;/span>()
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="原型模式prototype-pattern">原型模式(Prototype Pattern)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">prototype&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 原型复制抽象接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Prototype&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">clone&lt;/span>() &lt;span style="color:#a6e22e">Prototype&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Header&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Header&lt;/span>
&lt;span style="color:#a6e22e">Body&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Body&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span>) &lt;span style="color:#a6e22e">clone&lt;/span>() &lt;span style="color:#a6e22e">Prototype&lt;/span> {
&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">m&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestPrototype&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Builder&lt;/span>().
&lt;span style="color:#a6e22e">WithSrcAddr&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;192.168.0.1&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">WithSrcPort&lt;/span>(&lt;span style="color:#ae81ff">1234&lt;/span>).
&lt;span style="color:#a6e22e">WithDestAddr&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;192.168.0.2&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">WithDestPort&lt;/span>(&lt;span style="color:#ae81ff">8080&lt;/span>).
&lt;span style="color:#a6e22e">WithHeaderItem&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;contents&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">WithBodyItem&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;record1&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">WithBodyItem&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;record2&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">Build&lt;/span>()
&lt;span style="color:#75715e">// 复制一份消息
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">newMessage&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>.&lt;span style="color:#a6e22e">Clone&lt;/span>().(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">newMessage&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">SrcAddr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">SrcAddr&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Clone Message failed.&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">newMessage&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Clone Message failed.&amp;#34;&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="结构型模式structural-pattern">结构型模式(Structural Pattern)&lt;/h1>
&lt;h3 id="组合模式composite-pattern">组合模式(Composite Pattern)&lt;/h3>
&lt;p>Go实现组合模式的方式有两种&lt;/p>
&lt;p>直接组合(Direct Composition)&lt;/p>
&lt;p>嵌入组合(Embedding Composition)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Header&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Header&lt;/span>
&lt;span style="color:#a6e22e">Body&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Body&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 插件运行状态
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span> &lt;span style="color:#66d9ef">uint8&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> (
&lt;span style="color:#a6e22e">Stopped&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span> = &lt;span style="color:#66d9ef">iota&lt;/span>
&lt;span style="color:#a6e22e">Started&lt;/span>
)
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Plugin&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#75715e">// 启动插件
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;span style="color:#75715e">// 停止插件
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Stop&lt;/span>()
&lt;span style="color:#75715e">// 返回插件当前的运行状态
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>() &lt;span style="color:#a6e22e">Status&lt;/span>
}
&lt;span style="color:#75715e">// 这里使用Message结构体替代了原来的string,使语义更清晰
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Input&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Receive&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Filter&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Output&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Send&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 一个Pipeline由input filter output三个Plugin组成
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Pipeline&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Status&lt;/span>
&lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Input&lt;/span>
&lt;span style="color:#a6e22e">filter&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Filter&lt;/span>
&lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Output&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Pipeline&lt;/span>) &lt;span style="color:#a6e22e">Exec&lt;/span>() {
&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">input&lt;/span>.&lt;span style="color:#a6e22e">Receive&lt;/span>()
&lt;span style="color:#a6e22e">msg&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">output&lt;/span>.&lt;span style="color:#a6e22e">Send&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
}
&lt;span style="color:#75715e">// 启动的顺序 output -&amp;gt; filter -&amp;gt; input
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Pipeline&lt;/span>) &lt;span style="color:#a6e22e">Start&lt;/span>() {
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">output&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">input&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> = &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Started&lt;/span>
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello input plugin started.&amp;#34;&lt;/span>)
}
&lt;span style="color:#75715e">// 停止的顺序 input -&amp;gt; filter -&amp;gt; output
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Pipeline&lt;/span>) &lt;span style="color:#a6e22e">Stop&lt;/span>() {
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">input&lt;/span>.&lt;span style="color:#a6e22e">Stop&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">Stop&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">output&lt;/span>.&lt;span style="color:#a6e22e">Stop&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> = &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Stopped&lt;/span>
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello input plugin stopped.&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Pipeline&lt;/span>) &lt;span style="color:#a6e22e">Status&lt;/span>() &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Status&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个&lt;code>Pipeline&lt;/code>由&lt;code>Input&lt;/code>、&lt;code>Filter&lt;/code>、&lt;code>Output&lt;/code>三类插件组成，形成了“部分-整体”的关系，而且它们都实现了&lt;code>Plugin&lt;/code>接口，这就是一个典型的组合模式的实现。Client无需显式地启动和停止&lt;code>Input&lt;/code>、&lt;code>Filter&lt;/code>和&lt;code>Output&lt;/code>插件，在调用&lt;code>Pipeline&lt;/code>对象的&lt;code>Start&lt;/code>和&lt;code>Stop&lt;/code>方法时，&lt;code>Pipeline&lt;/code>就已经帮你按顺序完成对应插件的启动和停止。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">HelloInput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">h&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">HelloInput&lt;/span>) &lt;span style="color:#a6e22e">Receive&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span> {
&lt;span style="color:#75715e">// 如果插件未启动,则返回nil
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">Started&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello input plugin is not running, input nothing.&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Builder&lt;/span>().
&lt;span style="color:#a6e22e">WithHeaderItem&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;content&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;text&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">WithBodyItem&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">Build&lt;/span>()
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">h&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">HelloInput&lt;/span>) &lt;span style="color:#a6e22e">start&lt;/span>() {
&lt;span style="color:#a6e22e">h&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> = &lt;span style="color:#a6e22e">Started&lt;/span>
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello input plugin started.&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">h&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">HelloInput&lt;/span>) &lt;span style="color:#a6e22e">Stop&lt;/span>() {
&lt;span style="color:#a6e22e">h&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> = &lt;span style="color:#a6e22e">Stopped&lt;/span>
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello input plugin stopped.&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">h&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">HelloInput&lt;/span>) &lt;span style="color:#a6e22e">Status&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">UpperFilter&lt;/span>) &lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">Started&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Upper filter plugin is not running, filter nothing.&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>
}
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span> {
&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] = &lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">ToUpper&lt;/span>(&lt;span style="color:#a6e22e">val&lt;/span>)
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">UpperFilter&lt;/span>) &lt;span style="color:#a6e22e">Start&lt;/span>() {
&lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> = &lt;span style="color:#a6e22e">Started&lt;/span>
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Upper filter plugin started.&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">UpperFilter&lt;/span>) &lt;span style="color:#a6e22e">Stop&lt;/span>() {
&lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> = &lt;span style="color:#a6e22e">Stopped&lt;/span>
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Upper filter plugin stopped.&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">UpperFilter&lt;/span>) &lt;span style="color:#a6e22e">Status&lt;/span>() &lt;span style="color:#a6e22e">Status&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span>
}
&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ConsoleOutput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ConsoleOutput&lt;/span>) &lt;span style="color:#a6e22e">Send&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">Started&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Console output is not running, output nothing.&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span>
}
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Output:\n\tHeader:%+v, Body:%+v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>, &lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>)
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ConsoleOutput&lt;/span>) &lt;span style="color:#a6e22e">Start&lt;/span>() {
&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> = &lt;span style="color:#a6e22e">Started&lt;/span>
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Console output plugin started.&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ConsoleOutput&lt;/span>) &lt;span style="color:#a6e22e">Stop&lt;/span>() {
&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> = &lt;span style="color:#a6e22e">Stopped&lt;/span>
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Console output plugin stopped.&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ConsoleOutput&lt;/span>) &lt;span style="color:#a6e22e">Status&lt;/span>() &lt;span style="color:#a6e22e">Status&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestPipeline&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>.&lt;span style="color:#a6e22e">Of&lt;/span>(&lt;span style="color:#a6e22e">pipeline&lt;/span>.&lt;span style="color:#a6e22e">DefaultConfig&lt;/span>())
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Exec&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Stop&lt;/span>()
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>组合模式的另一种实现,嵌入组合(Embedding Composition),是利用了Go的匿名成员特性,本质上跟直接组合是一致的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Header&lt;/span>
&lt;span style="color:#a6e22e">Body&lt;/span>
}
&lt;span style="color:#75715e">// 使用时,Message可以引用Header和Body的成员属性
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Message&lt;/span>{}
&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">SrcAddr&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;192.168.0.1&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="适配器模式adapter-pattern">适配器模式(Adapter Pattern)&lt;/h3>
&lt;p>适配器模式是最常用的结构型模式之一,它让原本因为接口不匹配而无法一起工作的两个对象能够一起工作.适配器模式所做的就是将一个接口Adaptee,通过适配器Adapter转换成Client所期望的另一个接口Target来使用,实现原理也很简单,就是Adapter通过实现Target接口,并在对应的方法中调用Adaptee的接口实现&lt;/p>
&lt;p>一个典型的应用场景是,系统中一个老的接口已经过时即将废弃,但因为历史包袱没法立即将老接口全部替换为新接口.可以新增一个适配器,将老的接口适配成新的接口来使用.适配器模式很好的践行了面向对象设计里的开闭原则(open/closed principle),新增一个接口时也无需修改老接口,只需多加一个适配器即可.&lt;/p>
&lt;p>假设需要给系统新增从kafka 消息队列中接收数据的功能,其中Kafka消费者的接口如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">kafka&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Records&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Items&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Consumer&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Poll&lt;/span>() &lt;span style="color:#a6e22e">Records&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于当前Pipeline设计时通过plugin.Input接口来进行数据接收,因此kafka.Consumer并不能直接集成到系统中.&lt;/p>
&lt;p>所以需要使用适配器模式&lt;/p>
&lt;p>为了能让Pipeline能够使用kafka.Consumer接口,我们需要定义一个适配器:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">KafkaInput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>
&lt;span style="color:#a6e22e">consumer&lt;/span> &lt;span style="color:#a6e22e">kafka&lt;/span>.&lt;span style="color:#a6e22e">Consumer&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">KafkaInput&lt;/span>) &lt;span style="color:#a6e22e">Receive&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span> {
&lt;span style="color:#a6e22e">records&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>.&lt;span style="color:#a6e22e">consumer&lt;/span>.&lt;span style="color:#a6e22e">Poll&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span>.&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">Started&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Kafka input plugin is not running, input nothing.&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Builder&lt;/span>().
&lt;span style="color:#a6e22e">WithHeaderItem&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;content&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;kafka&amp;#34;&lt;/span>).
&lt;span style="color:#a6e22e">WithBodyItem&lt;/span>(&lt;span style="color:#a6e22e">records&lt;/span>.&lt;span style="color:#a6e22e">Item&lt;/span>).
&lt;span style="color:#a6e22e">Build&lt;/span>()
}
&lt;span style="color:#75715e">// 在输入插件映射关系中加入kafka,用于通过反射创建input对象
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;span style="color:#a6e22e">inputNames&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>] = &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">TypeOf&lt;/span>(&lt;span style="color:#a6e22e">HelloInput&lt;/span>{})
&lt;span style="color:#a6e22e">inputNames&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;kafka&amp;#34;&lt;/span>] = &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">TypeOf&lt;/span>(&lt;span style="color:#a6e22e">KafkaInput&lt;/span>{})
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为Go语言没有构造函数,如果按照抽象工厂模式来创建KafkaInput,那么得到的实例中的consumer成员因为没有被初始化而会是nil.因此,需要给Plugin接口新增一个Init方法,用户定义插件的一些初始化操作,并在工厂返回实例前调用.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Plugin&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;span style="color:#a6e22e">Stop&lt;/span>()
&lt;span style="color:#a6e22e">Status&lt;/span>() &lt;span style="color:#a6e22e">Status&lt;/span>
&lt;span style="color:#75715e">// 新增初始化方法,在插件Init函数,完成相关初始化方法
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Init&lt;/span>()
}
&lt;span style="color:#75715e">// 修改后的插件工厂实现如下
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">InputFactory&lt;/span>) &lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#a6e22e">conf&lt;/span> &lt;span style="color:#a6e22e">Config&lt;/span>) &lt;span style="color:#a6e22e">Plugin&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">inputNames&lt;/span>[&lt;span style="color:#a6e22e">conf&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>]
&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>).&lt;span style="color:#a6e22e">Interface&lt;/span>().(&lt;span style="color:#a6e22e">Plugin&lt;/span>)
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Init&lt;/span>()
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>
}
&lt;span style="color:#75715e">// KafkaInput的Init函数实现
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">KafkaInput&lt;/span>) &lt;span style="color:#a6e22e">Init&lt;/span>() {
&lt;span style="color:#a6e22e">k&lt;/span>.&lt;span style="color:#a6e22e">consumer&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">kafka&lt;/span>.&lt;span style="color:#a6e22e">MockConsumer&lt;/span>{}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述代码中的kafka.MockConsumer为我们模拟Kafka消费者的一个实现,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">kafka&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MockConsumer&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">MockConsumer&lt;/span>) &lt;span style="color:#a6e22e">Poll&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Records&lt;/span> {
&lt;span style="color:#a6e22e">records&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Records&lt;/span>{}
&lt;span style="color:#a6e22e">records&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span> = append(&lt;span style="color:#a6e22e">records&lt;/span>.&lt;span style="color:#a6e22e">Items&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;i am mock consumer.&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">records&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestKafkaInputPipeline&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#a6e22e">config&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>.&lt;span style="color:#a6e22e">Config&lt;/span>{
&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;pipeline2&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Input&lt;/span>: &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Config&lt;/span>{
&lt;span style="color:#a6e22e">PluginType&lt;/span>: &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">InputType&lt;/span>,
&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;kafka&amp;#34;&lt;/span>,
},
&lt;span style="color:#a6e22e">Filter&lt;/span>: &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Config&lt;/span>{
&lt;span style="color:#a6e22e">PluginType&lt;/span>: &lt;span style="color:#a6e22e">plugiin&lt;/span>.&lt;span style="color:#a6e22e">FilterType&lt;/span>,
&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;upper&amp;#34;&lt;/span>,
},
&lt;span style="color:#a6e22e">Output&lt;/span>: &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Config&lt;/span>{
&lt;span style="color:#a6e22e">PluginType&lt;/span>: &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">OutputType&lt;/span>,
&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;console&amp;#34;&lt;/span>,
},
}
&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>.&lt;span style="color:#a6e22e">Of&lt;/span>(&lt;span style="color:#a6e22e">config&lt;/span>)
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Exec&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Stop&lt;/span>()
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="桥接模式bridge-pattern">桥接模式(Bridge Pattern)&lt;/h3>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312e6caaa50934bbfe2d273c2a6bc5be4942?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3NzgyNTE0NCwiaWF0IjoxNjc3MjIwMzQ0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmU2Y2FhYTUwOTM0YmJmZTJkMjczYzJhNmJjNWJlNDk0MiJ9.smGJmZZGv_HRw2QeywW6rpZCvL5nszKjkFvhjHM-M80&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;p>桥接模式主要用于将抽象部分和实现部分进行解耦,使得它们能够各自往独立的方向变化.&lt;/p>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312e7779775d739bfcb2507aff8539a09920?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3NzgyNTE0NCwiaWF0IjoxNjc3MjIwMzQ0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmU3Nzc5Nzc1ZDczOWJmY2IyNTA3YWZmODUzOWEwOTkyMCJ9.JYF6QyIagvBAxw4E3Y1apqCeglSjUK85gmycYHO1aXE&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;p>这个例子中,我们通过将形状和颜色抽象为一个接口,使产品不再依赖于具体的形状和颜色细节,从而达到了解耦的目的.桥接模式本质上就是面向接口编程,可以给系统带来很好的灵活性和可扩展性.如果一个对象存在多个变化的方向,而且每个变化方向都需要扩展,那么使用桥街模式进行设计比较合适.&lt;/p>
&lt;p>回到消息处理系统的例子,一个Pipeline对象主要由Input、Filter、Output三类插件组成(3个特征),因为是插件化的系统,不可避免的就要求支持多种Input、Filter、Output的实现,并能够灵活组合(有多个变化的方向).显然,Pipeline就非常适合使用桥街模式进行设计,实际上我们也这么做了.我们将Input、Filter、Output分别设计成一个抽象的接口,它们按照各自的方向去扩展.Pipeline只依赖的这3个抽象接口,并不感知具体实现的细节.&lt;/p>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312e5f292fba5d2a22c27489b1801ce8cd44?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3NzgyNTE0NCwiaWF0IjoxNjc3MjIwMzQ0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmU1ZjI5MmZiYTVkMmEyMmMyNzQ4OWIxODAxY2U4Y2Q0NCJ9.cQmR2A369OpQkwOoL_6-LQpwmaCHE9nJTiAmzu6AO8Q&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Input&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Receive&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Filter&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Output&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Plugin&lt;/span>
&lt;span style="color:#a6e22e">Send&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">Message&lt;/span>)
}
&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 一个Pipeline由input、filter、output三个Plugin组成
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Pipeline&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">status&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Status&lt;/span>
&lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Input&lt;/span>
&lt;span style="color:#a6e22e">filter&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Filter&lt;/span>
&lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#a6e22e">plugin&lt;/span>.&lt;span style="color:#a6e22e">Output&lt;/span>
}
&lt;span style="color:#75715e">// 通过抽象接口来使用,看不到底层的实现细节
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Pipeline&lt;/span>) &lt;span style="color:#a6e22e">Exec&lt;/span>() {
&lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">input&lt;/span>.&lt;span style="color:#a6e22e">Receive&lt;/span>()
&lt;span style="color:#a6e22e">msg&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">output&lt;/span>.&lt;span style="color:#a6e22e">Send&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestPipeline&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">pipeline&lt;/span>.&lt;span style="color:#a6e22e">Of&lt;/span>(&lt;span style="color:#a6e22e">pipeline&lt;/span>.&lt;span style="color:#a6e22e">DefaultConfig&lt;/span>())
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Exec&lt;/span>()
&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Stop&lt;/span>()
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>本文主要介绍了结构型模式中的组合模式、适配器模式和桥接模式。&lt;strong>组合模式&lt;/strong>主要解决代码复用的问题，相比于继承关系，组合模式可以避免继承层次过深导致的代码复杂问题，因此面向对象设计领域流传着&lt;strong>组合优于继承&lt;/strong>的原则，而Go语言的设计也很好实践了该原则；&lt;strong>适配器模式&lt;/strong>可以看作是两个不兼容接口之间的桥梁，可以将一个接口转换成client所希望的另外一个接口，解决了模块之间因为接口不兼容而无法一起工作的问题；&lt;strong>桥接模式&lt;/strong>将模块的抽象部分和实现部分进行分离，让它们能够往各自的方向扩展，从而达到解耦的目的。&lt;/p>
&lt;h3 id="代理模式proxy-pattern">代理模式(Proxy Pattern)&lt;/h3>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312e70565f8b57a77be711d582d86bc7de93?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3NzgyNTE0NCwiaWF0IjoxNjc3MjIwMzQ0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmU3MDU2NWY4YjU3YTc3YmU3MTFkNTgyZDg2YmM3ZGU5MyJ9.eFrV730KZWTn3ck9inoCnSlvJeJ5miaE1yezLMXyiWI&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;p>代理模式为一个对象提供一种代理以控制对该对象的访问&lt;/p>
&lt;p>// 当Client不方便直接访问一个对象时,提供一个代理对象控制该对象的访问&lt;/p>
&lt;p>代理模式分以下几种:&lt;/p>
&lt;p>&lt;strong>远程代理(remote proxy)&lt;/strong>: 远程代理适用于提供服务的对象处在远程的机器上,通过普通的函数调用无法使用服务,需要经过远程代理来完成.因此并不能直接访问本体对象,所有远程代理对象通常不会直接持有本体对象的引用,而是持有远端机器的地址,通过网络协议去访问本体对象&lt;/p>
&lt;p>&lt;strong>虚拟代理(virtual proxy)&lt;/strong>:对一些重量级的服务对象,如果一直持有该对象实例回非常消耗系统资源,这时可以通过虚拟代理来对该对象进行延迟初始化.&lt;/p>
&lt;p>&lt;strong>保护代理(protection proxy)&lt;/strong>:保护代理用于控制对本体对象的访问,常用于需要给Client的访问加上权限验证的场景.&lt;/p>
&lt;p>&lt;strong>缓存代理(cache proxy)&lt;/strong>:缓存代理主要在Client与本体对象之间加上一层缓存,用于加速本体对象的访问,常见于连接数据库的场景.&lt;/p>
&lt;p>&lt;strong>智能引用(smart reference)&lt;/strong>:智能引用为本体对象的访问提供了额外的动作,常见的实现为C++中智能指针,为对象的访问提供了计数功能,当访问对象的计数为0时销毁该对象.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// Key-Value数据库接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">KvDb&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#75715e">// 存储数据
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 其中reply为操作结果,存储成功为true, 否则为false
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 当连接数据库失败时返回error,成功则返回nil
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Save&lt;/span>(&lt;span style="color:#a6e22e">record&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>, &lt;span style="color:#a6e22e">reply&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span>
&lt;span style="color:#75715e">// 根据key获取value,其中value通过函数参数中指针类型返回
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 当连接数据库失败时返回error,成功则返回nil
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">Value&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>数据库是一个Key-Value数据库,使用map存储数据,下面为数据库的服务端实现,&lt;code>db.Server&lt;/code>实现了db.KvDb接口:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 数据库服务端实现
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Server&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#75715e">// 采用map存储key-value数据
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Server&lt;/span>) &lt;span style="color:#a6e22e">Save&lt;/span>(&lt;span style="color:#a6e22e">record&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>, &lt;span style="color:#a6e22e">reply&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span> = make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>)
}
&lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>[&lt;span style="color:#a6e22e">record&lt;/span>.&lt;span style="color:#a6e22e">Key&lt;/span>] = &lt;span style="color:#a6e22e">record&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reply&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Server&lt;/span>) &lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">reply&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;span style="color:#a6e22e">val&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>[&lt;span style="color:#a6e22e">key&lt;/span>]
&lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reply&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Db has no key &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span>)
}
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reply&lt;/span> = &lt;span style="color:#a6e22e">val&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>消息处理系统和数据库并不在同一台机器上,因此消息处理系统不能直接调用&lt;code>db.Server&lt;/code>的方法进行数据存储,需要使用远程代理的方式&lt;/p>
&lt;p>在远程代理中,最常见的一种实现是远程过程调用(Remote Procedure Call)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 启动数据库,对外提供RPC接口进行数据库的访问
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Start&lt;/span>() {
&lt;span style="color:#a6e22e">rpcServer&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rpc&lt;/span>.&lt;span style="color:#a6e22e">NewServer&lt;/span>()
&lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Server&lt;/span>{&lt;span style="color:#a6e22e">data&lt;/span>: &lt;span style="color:#a6e22e">make&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>}
&lt;span style="color:#75715e">// 将数据库接口注册到RPC服务器上
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rpc&lt;/span>.&lt;span style="color:#a6e22e">Server&lt;/span>.&lt;span style="color:#a6e22e">Register&lt;/span>(&lt;span style="color:#a6e22e">server&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Register Server to rpc failed, error: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span>
}
&lt;span style="color:#a6e22e">l&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">net&lt;/span>.&lt;span style="color:#a6e22e">Listen&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tcp&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;127.0.0.1:1234&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Listen tcp failed, error: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span>
}
&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">rpcServer&lt;/span>.&lt;span style="color:#a6e22e">Accept&lt;/span>(&lt;span style="color:#a6e22e">l&lt;/span>)
&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Sleep&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>)
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;RPC server start success.&amp;#34;&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面已经为数据库提供了对外访问的方式.现在,需要一个远程代理来连接数据库服务端,并进行相关的数据库的操作.对消息处理系统而言,它不需要,也不应该知道远程代理与数据库服务端交互的底层细节,这样可以减轻系统之间的耦合.因此,远程代理需要实现&lt;code>db.KvDb&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#75715e">// 数据库服务端远程代理,实现db.KvDb接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Client&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#75715e">// RPC客户端
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">cli&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rpc&lt;/span>.&lt;span style="color:#a6e22e">Client&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Client&lt;/span>) &lt;span style="color:#a6e22e">Save&lt;/span>(&lt;span style="color:#a6e22e">record&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>, &lt;span style="color:#a6e22e">Reply&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ret&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;span style="color:#75715e">// 通过RPC调用服务端的接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">cli&lt;/span>.&lt;span style="color:#a6e22e">Call&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Server.Save&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">record&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ret&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Call db Server.Save rpc failed, error: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reply&lt;/span> = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reply&lt;/span> = &lt;span style="color:#a6e22e">ret&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Client&lt;/span>) &lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">reply&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ret&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#75715e">// 通过RPC调用服务端的接口
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">cli&lt;/span>.&lt;span style="color:#a6e22e">Call&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Server.Get&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">record&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ret&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Call db Server.Get rpc failed, error: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reply&lt;/span> = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reply&lt;/span> = &lt;span style="color:#a6e22e">ret&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#75715e">// 工厂方法,返回远程代理实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">CreateClient&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Client&lt;/span> {
&lt;span style="color:#a6e22e">rpcCli&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rpc&lt;/span>.&lt;span style="color:#a6e22e">Dial&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tcp&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;127.0.0.1:1234&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Create rpc client failed, error: %v.&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Client&lt;/span>{&lt;span style="color:#a6e22e">cli&lt;/span>: &lt;span style="color:#a6e22e">rpcCli&lt;/span>}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>作为远程代理的db.Client并没有直接持有db.Server的引用,而是持有了它的&lt;code>ip:port&lt;/code>&lt;/p>
&lt;p>通过RPC客户端调用了它的方法&lt;/p>
&lt;h3 id="装饰模式decorator-pattern">装饰模式(Decorator Pattern)&lt;/h3>
&lt;p>&lt;img src="https://tcs.teambition.net/storage/312e9309f45180e9077336f18b2fe3f4bb44?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3NzgyNTE0NCwiaWF0IjoxNjc3MjIwMzQ0LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMmU5MzA5ZjQ1MTgwZTkwNzczMzZmMThiMmZlM2Y0YmI0NCJ9.Qv59p6umMZ66pWRG87aeRFDyybLoIrJHGLEpQS7ASIs&amp;amp;download=image.png" alt="" title="">&lt;/p>
&lt;p>装饰模式使用组合而非继承的方式,能够动态的为本体对象叠加新的行为&lt;/p>
&lt;p>装饰模式最经典的应用当属Java的I/O流体系,通过装饰模式,使用者可以动态地为原始的输入输出流添加功能,比如按照字符串输入输出,添加缓存等&lt;/p>
&lt;p>从结构上看,装饰模式和代理模式具有很高的相似性,但是两种所强调的点不一样.装饰模式强调的是为本体对象添加新的功能,代理模式强调的是对本体对象的访问控制&lt;/p>
&lt;p>行为型模式(Behavioral Pattern)&lt;/p></content></item><item><title>Concurrency Control</title><link>https://xujiajiadexiaokeai.github.io/2021-12-03/concurrency-control/</link><pubDate>Fri, 03 Dec 2021 21:55:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-12-03/concurrency-control/</guid><description>摘录自: https://draveness.me/database-concurrency-control/
并发控制机制 Pessimistic Optimistic Multiversion 悲观并发控制-Pessimistic Concurrency Control 在悲观并发控制中,数据库程序对于数据被修改持悲观态度,在数据处理的过程中都会被锁定,以此来解决竞争问题
读写锁 为了最大化数据库事务的并发能力,数据库中的锁被设计为两种模式,分别是共享锁和互斥锁.
当一个事务获得共享锁之后,只可以进行读操作,所以共享锁也叫读锁
当一个事务获得一行数据的互斥锁时,就可以对该行数据进行读和写操作,所以互斥锁也叫写锁
共享锁和互斥锁出了限制事务能够执行的读写操作之外,它们之间还有共享和互斥的关系,也就是多个事务可以同时获得某一行数据的共享锁,但是互斥锁和共享锁和其他的互斥锁并不兼容,我们可以很自然地理解这么设计的原因: 多个事务同时写入同一数据难免会发生诡异的问题
如果当前事务没有办法获取该行数据对应的锁时就会陷入等待的状态,直到其他事务将当前数据对应的锁释放才可以获得锁并执行相应的操作
两阶段锁协议 两阶段锁协议(2PL)是一种能够保证事务可串行化的协议,它将事务的获取锁和释放锁划分成了增长(Growing)和缩减(Shrinking)两个不同的阶段
在增长阶段,一个事务可以获得锁但不能释放锁;在缩减阶段,事务只能释放锁,不能获得锁
变种:
Strict 2PL: 事务持有的互斥锁必须在提交后再释放
Rigorous 2PL: 事务持有的所有锁必须在提交后再释放
问题:
两阶段锁的使用带来了另一个问题-死锁
死锁的处理 解决死锁大体上有两种方法:
从源头杜绝死锁的产生和出现
允许系统进入死锁的状态,但是在系统出现死锁时能够及时发现并且进行恢复
预防死锁
保证事务之间的等待不会出现环 有向无环图 抢占加事务回滚 时间戳 wait-die wound-wait 死锁检测和恢复 死锁检测 检测有向图中是否出现环
死锁恢复
Victim Rollback Starvation 锁的粒度 显式 explicit 隐式 implicit 意向共享锁 意向互斥锁 乐观并发控制-Optimistic Concurrency Control 基于时间戳的协议 保证事务并行执行的顺序与事务按照时间戳串行执行的效果完全相同</description><content>&lt;blockquote>
&lt;p>摘录自: &lt;a href="https://draveness.me/database-concurrency-control/">https://draveness.me/database-concurrency-control/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="并发控制机制">并发控制机制&lt;/h1>
&lt;ul>
&lt;li>Pessimistic&lt;/li>
&lt;li>Optimistic&lt;/li>
&lt;li>Multiversion&lt;/li>
&lt;/ul>
&lt;h2 id="悲观并发控制-pessimistic-concurrency-control">悲观并发控制-Pessimistic Concurrency Control&lt;/h2>
&lt;p>在悲观并发控制中,数据库程序对于数据被修改持悲观态度,在数据处理的过程中都会被锁定,以此来解决竞争问题&lt;/p>
&lt;h3 id="读写锁">读写锁&lt;/h3>
&lt;p>为了最大化数据库事务的并发能力,数据库中的锁被设计为两种模式,分别是共享锁和互斥锁.&lt;/p>
&lt;p>当一个事务获得共享锁之后,只可以进行读操作,所以共享锁也叫读锁&lt;/p>
&lt;p>当一个事务获得一行数据的互斥锁时,就可以对该行数据进行读和写操作,所以互斥锁也叫写锁&lt;/p>
&lt;p>共享锁和互斥锁出了限制事务能够执行的读写操作之外,它们之间还有共享和互斥的关系,也就是多个事务可以同时获得某一行数据的共享锁,但是互斥锁和共享锁和其他的互斥锁并不兼容,我们可以很自然地理解这么设计的原因: 多个事务同时写入同一数据难免会发生诡异的问题&lt;/p>
&lt;p>如果当前事务没有办法获取该行数据对应的锁时就会陷入等待的状态,直到其他事务将当前数据对应的锁释放才可以获得锁并执行相应的操作&lt;/p>
&lt;h3 id="两阶段锁协议">两阶段锁协议&lt;/h3>
&lt;p>两阶段锁协议(2PL)是一种能够保证事务可串行化的协议,它将事务的获取锁和释放锁划分成了增长(Growing)和缩减(Shrinking)两个不同的阶段&lt;/p>
&lt;p>在增长阶段,一个事务可以获得锁但不能释放锁;在缩减阶段,事务只能释放锁,不能获得锁&lt;/p>
&lt;p>变种:&lt;/p>
&lt;p>Strict 2PL: 事务持有的互斥锁必须在提交后再释放&lt;/p>
&lt;p>Rigorous 2PL: 事务持有的所有锁必须在提交后再释放&lt;/p>
&lt;p>问题:&lt;/p>
&lt;p>两阶段锁的使用带来了另一个问题-死锁&lt;/p>
&lt;h3 id="死锁的处理">死锁的处理&lt;/h3>
&lt;p>解决死锁大体上有两种方法:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从源头杜绝死锁的产生和出现&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许系统进入死锁的状态,但是在系统出现死锁时能够及时发现并且进行恢复&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>预防死锁&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>保证事务之间的等待不会出现环 有向无环图&lt;/li>
&lt;li>抢占加事务回滚 时间戳
&lt;ul>
&lt;li>wait-die&lt;/li>
&lt;li>wound-wait&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="死锁检测和恢复">死锁检测和恢复&lt;/h3>
&lt;p>&lt;strong>死锁检测&lt;/strong>
检测有向图中是否出现环&lt;/p>
&lt;p>&lt;strong>死锁恢复&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Victim&lt;/li>
&lt;li>Rollback&lt;/li>
&lt;li>Starvation&lt;/li>
&lt;/ul>
&lt;h3 id="锁的粒度">锁的粒度&lt;/h3>
&lt;ul>
&lt;li>显式 explicit&lt;/li>
&lt;li>隐式 implicit&lt;/li>
&lt;li>意向共享锁&lt;/li>
&lt;li>意向互斥锁&lt;/li>
&lt;/ul>
&lt;h2 id="乐观并发控制-optimistic-concurrency-control">乐观并发控制-Optimistic Concurrency Control&lt;/h2>
&lt;h3 id="基于时间戳的协议">基于时间戳的协议&lt;/h3>
&lt;p>保证事务并行执行的顺序与事务按照时间戳串行执行的效果完全相同&lt;/p>
&lt;p>每一个数据项都有两个时间戳: 读时间戳和写时间戳&lt;/p>
&lt;p>该协议能够保证所有冲突的读写从左都能按照时间戳的大小串行执行&lt;/p>
&lt;h3 id="基于验证的协议">基于验证的协议&lt;/h3>
&lt;p>根据事务的只读或者更新将所有事务的执行分为两到三个阶段:&lt;/p>
&lt;ul>
&lt;li>Read Phase&lt;/li>
&lt;li>Validation Phase&lt;/li>
&lt;li>Write Phase&lt;/li>
&lt;/ul>
&lt;h2 id="多版本并发控制--multi-version-concurrency-control">多版本并发控制- Multi-Version Concurrency Control&lt;/h2>
&lt;p>每一个写操作都会创建一个新版本的数据, 读操作会从有限多个版本的数据中挑选最合适的版本返回&lt;/p></content></item><item><title>data-link-layer Notes</title><link>https://xujiajiadexiaokeai.github.io/2021-11-23/data-link-layer/</link><pubDate>Tue, 23 Nov 2021 15:49:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-11-23/data-link-layer/</guid><description>数据链路层将比特合成帧为单位进行传输 可以在出错时只重发出错的帧,而不用重发全部数据,提高了效率
组帧: 封装成帧 主要解决 帧定界、帧同步、帧传输
组帧要加首部、尾部 网络中以帧为最小单位进行传输,而分组(即IP数据报)仅仅是包含在帧的数据部分,不需要尾部
字符计数法(脆弱) 在帧头部使用一个计数字段来标明帧内字符数,可以确定帧结束位置 计数字段的字节数包含自身
如果计数字段出错,则后续将无法确认帧结束位和开始位
字符填充的首尾定界符法(复杂 不兼容) 开始: DLE STX
结束: DLE ETX
如果在数据段出现DLE字符,发送方在每个DLE字符前再插入一个DLE,接收方会自己删除DLE,数据仍不变
比特填充的首尾标志法 01111110 来标识一帧的开始与结束
发送方 每5个连续的1会自动在后面插入一个0
接收方 每5个连续的1会删除后面的0
容易用硬件实现 性能优于字符填充
违规编码法 曼彻斯特编码法: 1 : 高-低电平 0: 低-高电平
高-高 低-低是违规编码 可以用于标识首尾 局域网IEEE 802采用这种方法编码
不采用任何填充技术
只适用采用冗余编码的特殊编码环境
差错控制 传输中的差错都是由噪声引起的.
噪声分成两类: 信道固有的,持续存在的热噪声: 可通过提高信噪比来减少或避免
外界特定原因所造成的冲击噪声: 需要利用编码技术来进行差错控制
差错控制: 自动重传请求(ARQ)-检错编码、前向纠错(FEC)-纠错编码 ARQ: 接收端通知发送端重发,直到正确 FEC: 接收端发现差错,并可以确定错误位置,加以纠正 检错编码 奇偶校验码
通过增加冗余位来使码字中 1 的个数保持为奇数或偶数的编码方法.
只能发现奇数个比特的错误
循环冗余校验码
假设一个帧有m位,其对应的多项式为G(x),则计算冗余码的步骤如下:
加0: 假设G(x)的阶为r,在帧的低位端加上r个0
模2除: 利用模2除法,用G(x)对应的数据串去除1)中计算出的数据串,得到的余数为冗余码(共r位,前导0不可去除)</description><content>&lt;h1 id="数据链路层将比特合成帧为单位进行传输">数据链路层将比特合成帧为单位进行传输&lt;/h1>
&lt;p>可以在出错时只重发出错的帧,而不用重发全部数据,提高了效率&lt;/p>
&lt;p>组帧: 封装成帧 主要解决 帧定界、帧同步、帧传输&lt;/p>
&lt;h2 id="组帧要加首部尾部">组帧要加首部、尾部&lt;/h2>
&lt;p>网络中以帧为最小单位进行传输,而分组(即IP数据报)仅仅是包含在帧的数据部分,不需要尾部&lt;/p>
&lt;h3 id="字符计数法脆弱">字符计数法(脆弱)&lt;/h3>
&lt;p>在帧头部使用一个计数字段来标明帧内字符数,可以确定帧结束位置 计数字段的字节数包含自身&lt;/p>
&lt;p>如果计数字段出错,则后续将无法确认帧结束位和开始位&lt;/p>
&lt;h3 id="字符填充的首尾定界符法复杂-不兼容">字符填充的首尾定界符法(复杂 不兼容)&lt;/h3>
&lt;p>开始: DLE STX&lt;/p>
&lt;p>结束: DLE ETX&lt;/p>
&lt;p>如果在数据段出现DLE字符,发送方在每个DLE字符前再插入一个DLE,接收方会自己删除DLE,数据仍不变&lt;/p>
&lt;h3 id="比特填充的首尾标志法">比特填充的首尾标志法&lt;/h3>
&lt;p>01111110 来标识一帧的开始与结束&lt;/p>
&lt;p>发送方 每5个连续的1会自动在后面插入一个0&lt;/p>
&lt;p>接收方 每5个连续的1会删除后面的0&lt;/p>
&lt;p>容易用硬件实现 性能优于字符填充&lt;/p>
&lt;h3 id="违规编码法">违规编码法&lt;/h3>
&lt;p>曼彻斯特编码法: 1 : 高-低电平 0: 低-高电平&lt;/p>
&lt;p>高-高 低-低是违规编码 可以用于标识首尾 局域网IEEE 802采用这种方法编码&lt;/p>
&lt;p>不采用任何填充技术&lt;/p>
&lt;p>只适用采用冗余编码的特殊编码环境&lt;/p>
&lt;h1 id="差错控制">差错控制&lt;/h1>
&lt;p>传输中的差错都是由噪声引起的.&lt;/p>
&lt;h3 id="噪声分成两类">噪声分成两类:&lt;/h3>
&lt;p>信道固有的,持续存在的热噪声: 可通过提高信噪比来减少或避免&lt;/p>
&lt;p>外界特定原因所造成的冲击噪声: 需要利用编码技术来进行差错控制&lt;/p>
&lt;h3 id="差错控制-自动重传请求arq-检错编码前向纠错fec-纠错编码">差错控制: 自动重传请求(ARQ)-检错编码、前向纠错(FEC)-纠错编码&lt;/h3>
&lt;h3 id="arq-接收端通知发送端重发直到正确">ARQ: 接收端通知发送端重发,直到正确&lt;/h3>
&lt;h3 id="fec-接收端发现差错并可以确定错误位置加以纠正">FEC: 接收端发现差错,并可以确定错误位置,加以纠正&lt;/h3>
&lt;h2 id="检错编码">检错编码&lt;/h2>
&lt;p>奇偶校验码&lt;/p>
&lt;p>通过增加冗余位来使码字中 1 的个数保持为奇数或偶数的编码方法.&lt;/p>
&lt;p>只能发现奇数个比特的错误&lt;/p>
&lt;p>循环冗余校验码&lt;/p>
&lt;p>假设一个帧有m位,其对应的多项式为G(x),则计算冗余码的步骤如下:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>加0: 假设G(x)的阶为r,在帧的低位端加上r个0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模2除: 利用模2除法,用G(x)对应的数据串去除1)中计算出的数据串,得到的余数为冗余码(共r位,前导0不可去除)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>多项式为模2运算. 加法不进位,减法不借位(其实就是异或操作)&lt;/p>
&lt;h2 id="纠错编码">纠错编码&lt;/h2>
&lt;p>m个信息位插入r个校验位组成m+r个码字,必须满足2^r&amp;gt;=m+r+1&lt;/p>
&lt;p>海明码&lt;/p>
&lt;p>可发现双比特错,纠正单比特错&lt;/p>
&lt;p>纠错d位 需要码距为2d+1的编码方案 检错d位 只需要d+1位&lt;/p>
&lt;h1 id="流量控制与可靠传输">流量控制与可靠传输&lt;/h1>
&lt;h2 id="流量控制">流量控制&lt;/h2>
&lt;p>使接收方有足够的缓冲空间来接收帧&lt;/p>
&lt;p>基本方法: 由接收方来控制发送方发送数据的速率&lt;/p></content></item><item><title>HTTP1.x/2/3的区别</title><link>https://xujiajiadexiaokeai.github.io/2021-10-28/the-difference-between-http1x-and-http2-and-http3/</link><pubDate>Thu, 28 Oct 2021 22:40:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-10-28/the-difference-between-http1x-and-http2-and-http3/</guid><description>HTTP/1.x缺陷 连接无法复用
HTTP/1.0 每次都需要重新建立连接，增加延迟
HTTP/1.1 虽然加入keep-alive可以复用一部分连接，但域名分片等情况下仍然需要建立多个connection，耗费资源，给服务器带来性能压力
HOLB(Head-Of-Line-Blocking)：导致带宽无法被充分利用，以及后续健康请求被阻塞 HOLB是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。
HTTP 1.0：下个请求必须在前一个请求返回后才能发出，request-response对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。
HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。
协议开销大： HTTP1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。
安全因素：HTTP1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性
SPDY协议 HTTP/2新特性 二进制传输 HTTP/2将请求和响应数据分割为更小的帧，并且它们采用二进制编码。
重要概念：
流： 流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符；
消息：是指逻辑上的HTTP消息，比如请求、响应等，由一个或多个帧组成。
帧： HTTP/2 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如HTTP首部、负荷，等等
HTTP/2 中，同域名下所有通信都在耽搁连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
多路复用
Header 压缩
在HTTP/1 中，我们使用文本的形式传输header，在header携带cookie的情况下，可能每次都需要重复传输几百到几千的字节。</description><content>&lt;h1 id="http1x缺陷">HTTP/1.x缺陷&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>连接无法复用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP/1.0 每次都需要重新建立连接，增加延迟&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP/1.1 虽然加入keep-alive可以复用一部分连接，但域名分片等情况下仍然需要建立多个connection，耗费资源，给服务器带来性能压力&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HOLB(Head-Of-Line-Blocking)：导致带宽无法被充分利用，以及后续健康请求被阻塞 &lt;a href="http://stackoverflow.com/questions/25221954/spdy-head-of-line-blocking">HOLB&lt;/a>是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP 1.0：下个请求必须在前一个请求返回后才能发出，&lt;code>request-response&lt;/code>对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>协议开销大&lt;/strong>： HTTP1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>安全因素&lt;/strong>：HTTP1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="spdy协议">SPDY协议&lt;/h1>
&lt;h1 id="http2新特性">HTTP/2新特性&lt;/h1>
&lt;ol>
&lt;li>二进制传输&lt;/li>
&lt;/ol>
&lt;p>HTTP/2将请求和响应数据分割为更小的帧，并且它们采用二进制编码。&lt;/p>
&lt;p>重要概念：&lt;/p>
&lt;p>流： 流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符；&lt;/p>
&lt;p>消息：是指逻辑上的HTTP消息，比如请求、响应等，由一个或多个帧组成。&lt;/p>
&lt;p>帧： HTTP/2 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如HTTP首部、负荷，等等&lt;/p>
&lt;p>HTTP/2 中，同域名下所有通信都在耽搁连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>多路复用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Header 压缩&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在HTTP/1 中，我们使用文本的形式传输header，在header携带cookie的情况下，可能每次都需要重复传输几百到几千的字节。&lt;/p>
&lt;p>HTTP/2 采用了首部压缩策略&lt;/p>
&lt;p>HTTP/2 在 client和server use header table 来跟踪和存储之前发送的k-v pair&lt;/p>
&lt;p>对于same data 不再通过每次 req和 resp 发送&lt;/p>
&lt;p>header table 在 HTTP/2 连接存续阶段 始终存在，由client和server共同更新&lt;/p>
&lt;p>every new k-v pair will change the old value or 追加到当前表的末尾&lt;/p>
&lt;p>&lt;img src="../../img/the-difference-between-http1.x-and-http2-and-http3-1.png" alt="">&lt;/p>
&lt;ol>
&lt;li>Server push&lt;/li>
&lt;/ol>
&lt;p>Server 可以通过 push的方式将client 需要的内容 预先push过去 “cache push”&lt;/p>
&lt;p>prefetch 在browser兼容的情况下可以使用&lt;/p>
&lt;p>server可以主动把js和css文件推送给client 而不需要client解析html时再发送请求&lt;/p>
&lt;p>&lt;img src="../../img/the-difference-between-http1.x-and-http2-and-http3-2.png" alt="">&lt;/p>
&lt;p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。&lt;/p>
&lt;h1 id="http3新特性">HTTP/3新特性&lt;/h1>
&lt;p>HTTP/3 简介&lt;/p>
&lt;p>HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。&lt;/p>
&lt;p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据&lt;/p>
&lt;p>google 基于UDP的QUIC协议&lt;/p>
&lt;p>QUIC新功能&lt;/p>
&lt;p>0-RTT&lt;/p>
&lt;p>通过类时TCP快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证就可以进行传输了&lt;/p>
&lt;p>0RTT建连可以说是QUIC相比HTTP2最大的性能优势&lt;/p>
&lt;p>传输层0RTT就能建立连接&lt;/p>
&lt;p>加密层0RTT就能建立加密连接&lt;/p>
&lt;p>&lt;img src="../../img/the-difference-between-http1.x-and-http2-and-http3-3.png" alt="">&lt;/p>
&lt;p>多路复用&lt;/p>
&lt;p>QUIC原生实现了多路复用，并且在传输的单个数据流可以保证有序交付且不会影响其他的数据流&lt;/p>
&lt;p>同一条QUIC连接上可以创建多个stream 且stream间互不依赖(因为基于UDP)&lt;/p>
&lt;p>不存在TCP队头阻塞&lt;/p>
&lt;p>通过ID去识别连接 在移动端的表现好&lt;/p>
&lt;p>加密认证的报文&lt;/p>
&lt;p>TCP协议头部没有经过加密和认证 在传输过程中容易被中间网络设备篡改、注入和窃听&lt;/p>
&lt;p>QUIC除了个别报文 PUBLIC_RESET 和 CHLO 都是经过认证的 Body都是经过加密的&lt;/p>
&lt;p>&lt;img src="../../img/the-difference-between-http1.x-and-http2-and-http3-4.png" alt="">&lt;/p>
&lt;p>向前纠错(FEC) Forward Error Correction&lt;/p>
&lt;p>每个数据包除了它本身 还包括了部分其他数据包的数据&lt;/p>
&lt;p>少量的丢包可以通过其他包的冗余数据直接组装&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>HTTP/1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议&lt;/p>
&lt;/li>
&lt;/ul></content></item><item><title>[译]Progress in etcd</title><link>https://xujiajiadexiaokeai.github.io/2021-10-28/progress-in-etcd/</link><pubDate>Thu, 28 Oct 2021 15:00:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-10-28/progress-in-etcd/</guid><description>From etcd Raft Design Doc
Progress是etcd中leader保存的所有follower的progress的视图
Leader维护着所有follower的progress，并根据follower的progress向follower发送 replication message
replication message 是带着log entries信息的msgAppend 消息
progress有两个属性： match 和 next
match 是leader对该follower已确定日志(entry)中最高的index，如果leader对这个follower的日志复制情况(replication status)一无所知，match 则会被设置为0
next 是leader将要发送给该follower的第一条日志(entry)的index,leader会将从next 开始到最新的entries放到下一条replication message 中
一个follower的progress会处于以下三种状态： probe , replicate ,snapshot
+--------------------------------------------------------+ | send snapshot | | | +---------+----------+ +----------v---------+ +---&amp;gt; probe | | snapshot | | | max inflight = 1 &amp;lt;----------------------------------+ max inflight = 0 | | +---------+----------+ +--------------------+ | | 1. snapshot success | | (next=snapshot.</description><content>&lt;blockquote>
&lt;p>From etcd Raft Design Doc&lt;/p>
&lt;/blockquote>
&lt;p>Progress是etcd中leader保存的所有follower的progress的视图&lt;/p>
&lt;p>Leader维护着所有follower的progress，并根据follower的progress向follower发送 &lt;code>replication message&lt;/code>&lt;/p>
&lt;p>&lt;code>replication message&lt;/code> 是带着log entries信息的&lt;code>msgAppend&lt;/code> 消息&lt;/p>
&lt;p>progress有两个属性： &lt;code>match&lt;/code> 和 &lt;code>next&lt;/code>&lt;/p>
&lt;p>&lt;code>match&lt;/code> 是leader对该follower已确定日志(entry)中最高的index，如果leader对这个follower的日志复制情况(replication status)一无所知，&lt;code>match&lt;/code> 则会被设置为0&lt;/p>
&lt;p>&lt;code>next&lt;/code> 是leader将要发送给该follower的第一条日志(entry)的index,leader会将从&lt;code>next&lt;/code> 开始到最新的entries放到下一条&lt;code>replication message&lt;/code> 中&lt;/p>
&lt;p>一个follower的progress会处于以下三种状态： &lt;code>probe&lt;/code> , &lt;code>replicate&lt;/code> ,&lt;code>snapshot&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text"> +--------------------------------------------------------+
| send snapshot |
| |
+---------+----------+ +----------v---------+
+---&amp;gt; probe | | snapshot |
| | max inflight = 1 &amp;lt;----------------------------------+ max inflight = 0 |
| +---------+----------+ +--------------------+
| | 1. snapshot success
| | (next=snapshot.index + 1)
| | 2. snapshot failure
| | (no change)
| | 3. receives msgAppResp(rej=false&amp;amp;&amp;amp;index&amp;gt;lastsnap.index)
| | (match=m.index,next=match+1)
receives msgAppResp(rej=true)
(next=match+1)| |
| |
| |
| | receives msgAppResp(rej=false&amp;amp;&amp;amp;index&amp;gt;match)
| | (match=m.index,next=match+1)
| |
| |
| |
| +---------v----------+
| | replicate |
+---+ max inflight = n |
+--------------------+
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>probe&lt;/code> ：当follower处于待调查(probe)状态时，leader在一次心跳间隔(heartbeat interval)内最多向该follower发送一条&lt;code>replication message&lt;/code> 。leader慢慢向follower发送&lt;code>replication message&lt;/code> 并试探follower的实际复制进展(actual progress)。leader在收到&lt;code>msgHeartbeatResp&lt;/code> 或者&lt;code>msgAppResp&lt;/code> 的拒绝消息后会触发下一条&lt;code>replication message&lt;/code> 的发送。&lt;/p>
&lt;p>&lt;code>replicate&lt;/code> ：当follower处于复制(replicate)状态时，leader在向该follower发送&lt;code>replication message&lt;/code> 时，会乐观地(optimistically)将&lt;code>next&lt;/code> 增加至最新的index。这是一个最优的状态(optimized state)，可以快速的将日志(log entries)复制给follower。&lt;/p>
&lt;p>&lt;code>snapshot&lt;/code> ：当follower处于快照(snapshot)状态时，leader会停止向该follower发送&lt;code>replication message&lt;/code>&lt;/p>
&lt;h1 id="状态流转">状态流转&lt;/h1>
&lt;p>一个新选出的leader，会将所有follower的state设置为&lt;code>probe&lt;/code> 状态，&lt;code>match&lt;/code> 设置为0，&lt;code>next&lt;/code> 设置为自己最新的index。之后leader会缓慢的向各个follower发送&lt;code>replication message&lt;/code> (一次心跳最多一条)去试探他们的日志复制进展。&lt;/p>
&lt;p>在收到follower&lt;code>reject&lt;/code> 为&lt;code>false&lt;/code> 的&lt;code>msgAppResp&lt;/code> 时，会将该follower的progress设置为&lt;code>replicate&lt;/code> 状态，这表明发送的index已经和follower目前的index匹配上了，可以进行后续日志快速的发送。当follower回复一条reject的&lt;code>msgAppResp&lt;/code> 或者连接层(link layer) 报告follower不可连接时，该follower的progress会回到&lt;code>probe&lt;/code> 状态。我们积极地将&lt;code>next&lt;/code> 重置为&lt;code>match&lt;/code> +1，因为如果我们很快收到任何&lt;code>msgAppResp&lt;/code> ，&lt;code>match&lt;/code> 和&lt;code>next&lt;/code> 将直接增加到&lt;code>msgAppResp&lt;/code> 中的index。（如果将&lt;code>next&lt;/code> 设置过低，我们可能会发送一些重复条目。请参阅开放性问题）&lt;/p>
&lt;p>当follower远远落后并且需要快照(snapshot)时，该follower将从&lt;code>probe&lt;/code> 状态更改为&lt;code>snapshot&lt;/code> 状态。发送&lt;code>msgSnap&lt;/code> 后，leader将等待上一个快照发送成功、失败或中止。应用发送结果后，该follower的progress将返回到&lt;code>probe&lt;/code> 状态。&lt;/p>
&lt;h1 id="流转控制">流转控制&lt;/h1>
&lt;p>限制每条message发送的message最大大小。最大值应该是可配置的。降低探测状态的成本，因为我们限制每条消息的大小；如果下一步的罚分过低，则降低罚分&lt;/p>
&lt;p>当处于复制状态时，限制飞行中消息的数量 &amp;lt; N N应该是可配置的。大多数实现将在其实际网络传输层（不阻塞raft节点）的顶部有一个发送缓冲区。我们希望确保raft不会使缓冲区溢出，这可能会导致消息丢失并触发大量不必要的重复重发。&lt;/p></content></item><item><title>Dynamo</title><link>https://xujiajiadexiaokeai.github.io/2021-10-26/dynamo/</link><pubDate>Tue, 26 Oct 2021 13:52:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-10-26/dynamo/</guid><description>Dynamo is a peer-to-peer system can quickly find the key by DHT(distributed hash table)
为了保证能最快速的定位到key，所以在每个node中都保存了整个集群的信息，在客户端也保存了集群信息，可以将请求直接打到目标node
zero-hop (零跳)
一致性哈希的优点： node join or exit，only effect the adjacent nodes in the same hash ring
接着考虑到每个node的Heterogeneous(异构性)、处理能力不同，于是加入了virtual nodes（虚拟结点）的概念
尽量做到每个虚拟节点的处理能力一致
起初一致性哈希是为了解决新加入节点和退出节点对数据的影响最小，但是由于数据分布的不均匀，热点数据，节点能力的异构都会造成分布不均匀，于是加入的virtual nodes，但是为了同一份数据的replicas分布在不同的物理机器上，配置virtual也会造成一定的困难。
一致性和复制 replicate： the node that performs data replication is called coordinator
负责存储key的node被称为preference list
coordinator coordinator进行复制的时候，是异步进行的，（可尽快给用户返回），所以Dynamo是一个弱一致系统
NRW: 可自定义R和W的数量，但要满足 R + W &amp;gt; N
W(W&amp;lt;=N): 一个写操作只有成功更新了W个副本，才会被任务操作成功
R(R&amp;lt;=N): 一个读操作需要读的副本数量
R + W &amp;gt; N 能够保证读操作和写操作有节点交集：至少有一个节点会被读操作和写操作同时操作到
通过调整R和W能实现available和consistency之间的转换
W小R大 writes never fail -&amp;gt; high availability</description><content>&lt;p>Dynamo is a peer-to-peer system can quickly find the key by DHT(distributed hash table)&lt;/p>
&lt;p>为了保证能最快速的定位到key，所以在每个node中都保存了整个集群的信息，在客户端也保存了集群信息，可以将请求直接打到目标node&lt;/p>
&lt;p>zero-hop (零跳)&lt;/p>
&lt;h1 id="一致性哈希的优点">一致性哈希的优点：&lt;/h1>
&lt;p>node join or exit，only effect the adjacent nodes in the same hash ring&lt;/p>
&lt;p>接着考虑到每个node的Heterogeneous(异构性)、处理能力不同，于是加入了virtual nodes（虚拟结点）的概念&lt;/p>
&lt;p>尽量做到每个虚拟节点的处理能力一致&lt;/p>
&lt;p>起初一致性哈希是为了解决新加入节点和退出节点对数据的影响最小，但是由于数据分布的不均匀，热点数据，节点能力的异构都会造成分布不均匀，于是加入的virtual nodes，但是为了同一份数据的replicas分布在不同的物理机器上，配置virtual也会造成一定的困难。&lt;/p>
&lt;h1 id="一致性和复制">一致性和复制&lt;/h1>
&lt;h2 id="replicate">replicate：&lt;/h2>
&lt;p>the node that performs data replication is called coordinator&lt;/p>
&lt;p>负责存储key的node被称为preference list&lt;/p>
&lt;h2 id="coordinator">coordinator&lt;/h2>
&lt;p>coordinator进行复制的时候，是异步进行的，（可尽快给用户返回），所以Dynamo是一个弱一致系统&lt;/p>
&lt;h2 id="nrw">NRW:&lt;/h2>
&lt;p>可自定义R和W的数量，但要满足 R + W &amp;gt; N&lt;/p>
&lt;h3 id="wwn">W(W&amp;lt;=N):&lt;/h3>
&lt;p>一个写操作只有成功更新了W个副本，才会被任务操作成功&lt;/p>
&lt;h3 id="rrn">R(R&amp;lt;=N):&lt;/h3>
&lt;p>一个读操作需要读的副本数量&lt;/p>
&lt;h3 id="r--w--n">R + W &amp;gt; N&lt;/h3>
&lt;p>能够保证读操作和写操作有节点交集：至少有一个节点会被读操作和写操作同时操作到&lt;/p>
&lt;p>通过调整R和W能实现available和consistency之间的转换&lt;/p>
&lt;h3 id="w小r大">W小R大&lt;/h3>
&lt;p>writes never fail -&amp;gt; high availability&lt;/p>
&lt;h3 id="r小w大">R小W大&lt;/h3>
&lt;p>block for all replicas to be readable -&amp;gt; strong consistency&lt;/p>
&lt;p>每个node都记录自己的操作记录，通过向量时钟能够记录同一对象不同版本间的因果关系&lt;/p>
&lt;p>当节点接收到更新 -&amp;gt; 逐相对比本地向量钟和待更新数据的向量钟&lt;/p>
&lt;p>如果待更新向量钟的每一项都不小于本地向量钟，那么数据无冲突，新的值可以接受。&lt;/p>
&lt;p>Dynamo并不会贸然假定数据的冲突合并准则，而是保留全部的冲突数据，等待客户端处理。&lt;/p>
&lt;h1 id="容错">容错&lt;/h1>
&lt;p>Dynamo将异常分为两种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>临时性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>永久性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="临时性故障">临时性故障：&lt;/h2>
&lt;p>针对临时性故障，其处理策略就是仲裁(quorum)，但是如果严格执行仲裁策略，会影响Dynamo的可用性，因为需要等到N个节点都执行了，才能返回，此时如果其中一个结点故障了，会影响可用性。&lt;/p>
&lt;p>于是Dynamo采用了Sloppy Quorum策略，只需要N个healthy node即可&lt;/p>
&lt;p>Sloppy Quorum：&lt;/p>
&lt;p>如果某台机器故障了，则顺延将数据写入到后面的健康机器，并标注数据为hinted handoff，当机器恢复后，将数据进行回传&lt;/p>
&lt;h2 id="永久性故障">永久性故障：&lt;/h2>
&lt;p>针对永久性故障，其处理策略是Merkle Hash Tree.&lt;/p>
&lt;h3 id="merkle-hash-tree">Merkle Hash Tree:&lt;/h3>
&lt;p>非叶子结点对应多个文件，值是其所有子节点值结合以后的哈希值；&lt;/p>
&lt;p>叶子节点对应单个数据文件，值是文件内容的哈希&lt;/p>
&lt;p>通过对比Merkle树，就能找出不同的文件了&lt;/p>
&lt;h1 id="成员资格及错误检测">成员资格及错误检测&lt;/h1>
&lt;p>所有的node中都保存了集群中所有node的路由信息，这导致了有新节点加入或者节点退出的时候，需要将这消息传递给集群内的所有人，使用了gossip协议&lt;/p>
&lt;h1 id="总体特点">总体特点&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>最终一致性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>即使故障也保障可写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许写冲突，由上层应用自行解决&lt;/p>
&lt;/li>
&lt;/ul></content></item><item><title>Linux Network Notes</title><link>https://xujiajiadexiaokeai.github.io/2021-10-16/linux-network-notes/</link><pubDate>Sat, 16 Oct 2021 15:51:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-10-16/linux-network-notes/</guid><description>I/O模型 阻塞I/O Blocking I/O
非阻塞I/O Nonblocking I/O
Linux 下,我们可以通过 fcntl 系统调用来设置 O_NONBLOCK 标志位,从而把 socket 设置成 Non-blocking。
当用户进程发出 read 操作时,如果 kernel 中的数据还没有准备好,那么它并不会 block 用户进程,而是立刻返回一个 EAGAIN error。从用户进程角度讲 ,它发起一个 read 操作后,并不需要等待,而是马上就得到了一个结果。用户进程判断结果是一个 error 时,它就知道数据还没有准备好,于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了,并且又再次收到了用户进程的 system call,那么它马上就将数据拷贝到了用户内存,然后返回。
所以,Non-blocking I/O 的特点是用户进程需要不断的主动询问 kernel 数据好了没有
I/O多路复用 I/O multiplexing I/O多路复用就是 select/poll/epoll 等多路选择器：支持单一线程同时监听多个文件描述符,阻塞等待,并在其中某个文件描述符文可读写时收到通知。
本质上复用的是线程,让一个thread of control能够处理多个连接(I/O事件)
信号驱动I/O Signal drivern I/O 异步I/O Asynchronous I/O</description><content>&lt;h3 id="io模型">I/O模型&lt;/h3>
&lt;p>阻塞I/O Blocking I/O&lt;/p>
&lt;p>非阻塞I/O Nonblocking I/O&lt;/p>
&lt;p>Linux 下,我们可以通过 &lt;code>fcntl&lt;/code> 系统调用来设置 &lt;code>O_NONBLOCK&lt;/code> 标志位,从而把 socket 设置成 Non-blocking。&lt;/p>
&lt;p>当用户进程发出 read 操作时,如果 kernel 中的数据还没有准备好,那么它并不会 block 用户进程,而是立刻返回一个 EAGAIN error。从用户进程角度讲 ,它发起一个 read 操作后,并不需要等待,而是马上就得到了一个结果。用户进程判断结果是一个 error 时,它就知道数据还没有准备好,于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了,并且又再次收到了用户进程的 system call,那么它马上就将数据拷贝到了用户内存,然后返回。&lt;/p>
&lt;p>&lt;strong>所以,Non-blocking I/O 的特点是用户进程需要不断的主动询问 kernel 数据好了没有&lt;/strong>&lt;/p>
&lt;h3 id="io多路复用-io-multiplexing">I/O多路复用 I/O multiplexing&lt;/h3>
&lt;p>I/O多路复用就是 select/poll/epoll 等多路选择器：支持单一线程同时监听多个文件描述符,阻塞等待,并在其中某个文件描述符文可读写时收到通知。&lt;/p>
&lt;p>本质上复用的是线程,让一个thread of control能够处理多个连接(I/O事件)&lt;/p>
&lt;h3 id="信号驱动io-signal-drivern-io">信号驱动I/O Signal drivern I/O&lt;/h3>
&lt;h3 id="异步io-asynchronous-io">异步I/O Asynchronous I/O&lt;/h3></content></item><item><title>Quorum in etcd</title><link>https://xujiajiadexiaokeai.github.io/2021-10-12/quorum-in-etcd/</link><pubDate>Tue, 12 Oct 2021 22:44:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-10-12/quorum-in-etcd/</guid><description>CAP 一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)
WARO (Write All Read One)一种简单的副本控制协议。当Client请求向某副本写数据时,只有当所有的副本都更新成功后,才算写成功,否则都视为失败。
WARO牺牲了更新服务的可用性,最大程度增强了读服务的可用性
Quorum 一种权衡机制, 一种将“读写转化”的模型
quorum是“抽屉原理”的一个应用。定义:假设有N个副本,更新操作wi在W个副本中更新成功后,才认为此次更新操作wi成功。称成功提交的更新操作对应的数据为“成功提交的数据”。对于读操作而言,至少需要读R个副本才能读到此次更新的数据。其中,W+R&amp;gt;N,即W和R有重叠。一般W+R=N+1
Quorum机制分析 Quorum机制无法保证强一致性
如何读取最新的数据:在已经知道最近成功提交的数据版本号的前提下,最多读R个副本就可以了
如何确定 最高版本号 的数据是一个成功提交的数据: 继续读其他副本,直到读到了 W 次
基于Quorum机制选primary
中心节点读取R个副本,选择R个副本中版本号最高的副本作为新的Primary。
新选出的primary不能立即提供服务,还需要与至少W个副本完成同步后,才能提供服务 &amp;mdash;&amp;ndash;&amp;gt; 为了保证Quorum的规则: W+R &amp;gt; N
如何处理冲突？ (V2,V2,V1,V1,V1) R = 3
如果读取的是(V1,V1,V1),则V2需要丢弃
如果是(V2,V1,V1),则V1需要同步到V2
Quorum 在etcd中的应用 Quorum在etcd中主要作用有两个,一个是计算已被多数节点接收(Match)的Index,二是在进行Leader选举时,计算选举结果。
raft/quorum/quorum.go</description><content>&lt;h1 id="cap">CAP&lt;/h1>
&lt;p>一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)&lt;/p>
&lt;h1 id="waro">WARO&lt;/h1>
&lt;p>(Write All Read One)一种简单的副本控制协议。当Client请求向某副本写数据时,只有当所有的副本都更新成功后,才算写成功,否则都视为失败。&lt;/p>
&lt;p>WARO牺牲了更新服务的可用性,最大程度增强了读服务的可用性&lt;/p>
&lt;h1 id="quorum">Quorum&lt;/h1>
&lt;p>一种权衡机制, 一种将“读写转化”的模型&lt;/p>
&lt;p>quorum是“抽屉原理”的一个应用。定义:假设有N个副本,更新操作wi在W个副本中更新成功后,才认为此次更新操作wi成功。称成功提交的更新操作对应的数据为“成功提交的数据”。对于读操作而言,至少需要读R个副本才能读到此次更新的数据。其中,W+R&amp;gt;N,即W和R有重叠。一般W+R=N+1&lt;/p>
&lt;h2 id="quorum机制分析">Quorum机制分析&lt;/h2>
&lt;p>&lt;strong>Quorum机制无法保证强一致性&lt;/strong>&lt;/p>
&lt;p>如何读取最新的数据:在已经知道最近成功提交的数据版本号的前提下,最多读R个副本就可以了&lt;/p>
&lt;p>如何确定 最高版本号 的数据是一个成功提交的数据: 继续读其他副本,直到读到了 W 次&lt;/p>
&lt;p>基于Quorum机制选primary&lt;/p>
&lt;p>中心节点读取R个副本,选择R个副本中版本号最高的副本作为新的Primary。&lt;/p>
&lt;p>新选出的primary不能立即提供服务,还需要与至少W个副本完成同步后,才能提供服务 &amp;mdash;&amp;ndash;&amp;gt; 为了保证Quorum的规则: W+R &amp;gt; N&lt;/p>
&lt;h3 id="如何处理冲突">如何处理冲突？&lt;/h3>
&lt;p>(V2,V2,V1,V1,V1) R = 3&lt;/p>
&lt;p>如果读取的是(V1,V1,V1),则V2需要丢弃&lt;/p>
&lt;p>如果是(V2,V1,V1),则V1需要同步到V2&lt;/p>
&lt;h2 id="quorum-在etcd中的应用">Quorum 在etcd中的应用&lt;/h2>
&lt;p>Quorum在etcd中主要作用有两个,一个是计算已被多数节点接收(Match)的Index,二是在进行Leader选举时,计算选举结果。&lt;/p>
&lt;p>raft/quorum/quorum.go&lt;/p></content></item><item><title>Posts Archive</title><link>https://xujiajiadexiaokeai.github.io/archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xujiajiadexiaokeai.github.io/archive/</guid><description/><content/></item><item><title>关于我</title><link>https://xujiajiadexiaokeai.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xujiajiadexiaokeai.github.io/about/</guid><description>姜文浩 男 / 1997.11 本科 / 上海第二工业大学 / 软件工程 工作时间: 2年+ 联系方式: whjiang1997@gmail.com Github: https://github.com/xujiajiadexiaokeai Blog: https://blog.xujiajiadexiaokeai.xyz 期望职位: 后端研发工程师(云原生方向) 专业技能 熟悉Golang/Node.js 具备B端SaaS研发经验,有大量排查问题经历 熟悉Kubernetes, 了解Orchestration、Observability方向相关生态和技术 熟悉eBPF,了解Linux内核下eBPF运行机制和相关应用 熟悉分布式原理,了解Paxos、Raft等一致性算法 熟悉HTTP相关网络协议,知悉优劣,了解gRPC 了解设计模式、混沌工程 工作经历 2022.10 - 2022.11 三度观测云(北京)科技有限责任公司 - 后端研发工程师 Tricorder Observability是一款开源云原生观测平台SaaS；基于eBPF、WASM，定义不改业务代码、自动数据采集零成本观测体验.
我主要负责基于eBPF的核心数据采集和部署模块的开发.作为初创公司的创始团队成员,还参与了研发相关流程的梳理和规范撰写,在知识库中保留了相关文档供新晋员工参考.
主要解决的问题:
基于eBPF的HTTP1.x流量解析模块 Kubernetes集群内eBPF Code的部署模块 收获:
从0到1的项目构建经验 eBPF与可观测性领域相关知识 2020.8 - 2021.8 阿里巴巴钉钉事业部Teambition团队(外包编制) - 后端研发工程师 Teambition私有云开发及维护
Teambition为自研团队协作工具,以项目和任务的可视化管理来支撑企业团队协作,有公有云和私有云两个版本,拥有大量用户.
我主要负责私有云线上问题的排查处理、公有云迁移值班OnCall和处理一些客户定制开发需求.累计参与数百项问题的定位和修复.
主要解决的问题:
推动刷库脚本&amp;quot;DryRun&amp;quot;及可回滚 推动对强依赖中间件添加健康检查 推动故障排查手册的维护和使用 收获:</description><content>&lt;h1 id="姜文浩">姜文浩&lt;/h1>
&lt;ul>
&lt;li>男 / 1997.11&lt;/li>
&lt;li>本科 / 上海第二工业大学 / 软件工程&lt;/li>
&lt;li>工作时间: 2年+&lt;/li>
&lt;li>联系方式: &lt;a href="mailto:whjiang1997@gmail.com">whjiang1997@gmail.com&lt;/a>&lt;/li>
&lt;li>Github: &lt;a href="https://github.com/xujiajiadexiaokeai">https://github.com/xujiajiadexiaokeai&lt;/a>&lt;/li>
&lt;li>Blog: &lt;a href="https://blog.xujiajiadexiaokeai.xyz">https://blog.xujiajiadexiaokeai.xyz&lt;/a>&lt;/li>
&lt;li>期望职位: &lt;em>后端研发工程师(云原生方向)&lt;/em>&lt;/li>
&lt;/ul>
&lt;h2 id="专业技能">专业技能&lt;/h2>
&lt;ul>
&lt;li>熟悉Golang/Node.js&lt;/li>
&lt;li>具备B端SaaS研发经验,有大量排查问题经历&lt;/li>
&lt;li>熟悉Kubernetes, 了解Orchestration、Observability方向相关生态和技术&lt;/li>
&lt;li>熟悉eBPF,了解Linux内核下eBPF运行机制和相关应用&lt;/li>
&lt;li>熟悉分布式原理,了解Paxos、Raft等一致性算法&lt;/li>
&lt;li>熟悉HTTP相关网络协议,知悉优劣,了解gRPC&lt;/li>
&lt;li>了解设计模式、混沌工程&lt;/li>
&lt;/ul>
&lt;h2 id="工作经历">工作经历&lt;/h2>
&lt;h3 id="202210---202211-三度观测云北京科技有限责任公司---后端研发工程师">2022.10 - 2022.11 三度观测云(北京)科技有限责任公司 - 后端研发工程师&lt;/h3>
&lt;p>&lt;a href="https://tricorder.dev/">Tricorder Observability&lt;/a>是一款开源云原生观测平台SaaS；基于eBPF、WASM，定义&lt;strong>不改业务代码、自动数据采集&lt;/strong>零成本观测体验.&lt;/p>
&lt;p>我主要负责基于eBPF的核心数据采集和部署模块的开发.作为初创公司的创始团队成员,还参与了研发相关流程的梳理和规范撰写,在知识库中保留了相关文档供新晋员工参考.&lt;/p>
&lt;p>&lt;strong>主要解决的问题:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>基于eBPF的HTTP1.x流量解析模块&lt;/li>
&lt;li>Kubernetes集群内eBPF Code的部署模块&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>收获:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从0到1&lt;/strong>的项目构建经验&lt;/li>
&lt;li>eBPF与可观测性领域相关知识&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="20208---20218-阿里巴巴钉钉事业部teambition团队外包编制---后端研发工程师">2020.8 - 2021.8 阿里巴巴钉钉事业部Teambition团队(外包编制) - 后端研发工程师&lt;/h3>
&lt;p>&lt;strong>Teambition私有云开发及维护&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.teambition.com/">Teambition&lt;/a>为自研团队协作工具,以项目和任务的可视化管理来支撑企业团队协作,有公有云和私有云两个版本,拥有大量用户.&lt;/p>
&lt;p>我主要负责私有云线上问题的排查处理、公有云迁移值班OnCall和处理一些客户定制开发需求.累计参与数百项问题的定位和修复.&lt;/p>
&lt;p>&lt;strong>主要解决的问题:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>推动刷库脚本&amp;quot;DryRun&amp;quot;及可回滚&lt;/li>
&lt;li>推动对强依赖中间件添加健康检查&lt;/li>
&lt;li>推动故障排查手册的维护和使用&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>收获:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>大量的线上问题排查经验&lt;/li>
&lt;li>大型SaaS微服务架构设计经验&lt;/li>
&lt;li>优秀团队规范的coding风格和标准的CI&amp;amp;CD流程&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="20194---20206-上海妙点网络科技有限公司---后端研发工程师">2019.4 - 2020.6 上海妙点网络科技有限公司 - 后端研发工程师&lt;/h3>
&lt;p>&lt;strong>聚合写作&lt;/strong>
聚合写作为公司内部项目,从外部网站、接口爬取数据,再根据预编写的规则对数据进行加工,生成数据用于内容部门生产,实现了完整的ETL过程.有100+数据项目在线运行.&lt;/p>
&lt;p>我主要负责聚合写作项目的日常开发及维护.&lt;/p>
&lt;p>&lt;strong>主要解决的问题:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>基于BloomFilter的爬虫排重过滤器的开发&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>收获:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对Node.js的events、child_process、vm等模块有了更加详细的认识&lt;/li>
&lt;li>加深了对Node.js单线程、非阻塞IO等特性的理解&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>财经秘书&lt;/strong>
财经秘书为公司C端产品,日活1万+.为用户提供90+细分行业每日经济资讯、行业数据；并有专业研究员为用户解答问题、提供投资建议和行业研报.&lt;/p>
&lt;p>我主要负责v3.0版本的接口设计与开发、后台管理系统改造和内容创作中心的开发.&lt;/p>
&lt;p>&lt;strong>主要解决的问题:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>多来源、多类型混合feed流的开发&lt;/li>
&lt;li>后台管理系统改造为开放平台,允许第三方接入&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>收获:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对NoSQL与SQL在使用和设计上的不同有了新的认识&lt;/li>
&lt;li>尝试使用缓存和队列来缓解服务器和数据库压力&lt;/li>
&lt;/ul>
&lt;h2 id="自我评价">自我评价&lt;/h2>
&lt;p>乐观开朗,具有良好的合作沟通能力,能够快速融入团队,并结合自身进展反哺.技术上视野广阔,对新技术有着强烈好奇心.&lt;/p>
&lt;h2 id="感兴趣的领域">感兴趣的领域&lt;/h2>
&lt;ul>
&lt;li>基于eBPF增强系统可观测性&lt;/li>
&lt;li>基于Kubernetes的容器调度策略&lt;/li>
&lt;li>基于Kubernetes的Aplication Runtime实现&lt;/li>
&lt;li>基于risc-v架构的操作系统内核实现&lt;/li>
&lt;/ul></content></item></channel></rss>