<!doctype html><html lang=en>
<head>
<title>Goroutine :: xujiajiadexiaokeai</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Go Memory">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/>
<link rel=stylesheet href=https://xujiajiadexiaokeai.github.io/assets/style.css>
<link rel=apple-touch-icon href=https://xujiajiadexiaokeai.github.io/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=https://xujiajiadexiaokeai.github.io/favicon.ico>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta property="og:title" content="Goroutine">
<meta property="og:description" content="Go Memory">
<meta property="og:url" content="https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/">
<meta property="og:site_name" content="xujiajiadexiaokeai">
<meta property="og:image" content="https://xujiajiadexiaokeai.github.io/favicon.ico">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:published_time" content="2022-07-13 10:16:17 +0800 +0800">
</head>
<body class=orange>
<div class="container center headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
RTSC && RTFM
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/about>About</a></li>
<li><a href=/archive>Archive</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/about>About</a></li>
<li><a href=/archive>Archive</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/>Goroutine</a></h1>
<div class=post-meta>
<span class=post-date>
2022-07-13
</span>
<span class=post-author>:: Wenhao Jiang</span>
<span class=post-reading-time>:: 1 min read (71 words)</span>
</div>
<span class=post-tags>
#<a href=https://xujiajiadexiaokeai.github.io/tags/go/>Go</a>&nbsp;
</span>
<div class=post-content><div>
<h1 id=基本概念>基本概念<a href=#基本概念 class=hanchor arialabel=Anchor>&#8983;</a> </h1>
<ol>
<li>进程</li>
</ol>
<ul>
<li>进程是应用程序的启动实例</li>
<li>有独立的内存空间</li>
<li>不同进程通过进程间通信的方式进行通信</li>
</ul>
<ol start=2>
<li>线程</li>
</ol>
<ul>
<li>线程是cpu调度的基本单位</li>
<li>不同线程可以共享进程的资源</li>
<li>不同线程通过共享内存等线程间通信方式进行通信</li>
</ul>
<ol start=3>
<li>协程</li>
</ol>
<ul>
<li>协程调度由用户程序提供,不直接受操作系统调度</li>
<li>协程调度器按照调度策略把协程调度到线程中执行</li>
</ul>
<h1 id=协程的优势>协程的优势<a href=#协程的优势 class=hanchor arialabel=Anchor>&#8983;</a> </h1>
<p>过多的线程会导致上下文切换的开销变大,而工作在用户态的协程则能大大减少上下文切换的开销
协程调度器把可运行的协程逐个调度到线程中执行,同时及时把阻塞的协程调度出线程
有效地避免了线程的频繁切换
实现了使用少量线程实现高并发的效果</p>
<p>多个协程分享操作系统分给线程的时间片
协程调度器决定了协程运行的顺序
线程运行调度器指派的协程,每一时刻只能运行一个协程</p>
<h1 id=调度模型>调度模型<a href=#调度模型 class=hanchor arialabel=Anchor>&#8983;</a> </h1>
<ol>
<li>线程模型
线程可分为用户线程和内核线程
用户线程由用户创建、同步合销毁
根据用户线程管理方式的不同,分为三种线程模型:</li>
</ol>
<ul>
<li>N:1模型
N个用户线程运行在1个内核线程中,上下文切换较快</li>
<li>1:1模型
每个用户线程对应一个内核线程,上下文切换较慢</li>
<li>M:N模型
充分利用cpu且上下文切换较快,但调度算法较为复杂</li>
</ul>
<ol start=2>
<li>Go GPM模型
G: goroutine,Go协程,每个<code>go</code>关键字都会创建一个goroutine
P: processor,处理器(Go定义的一个概念,不是指cpu),包含运行Go代码的必要资源,也有调度goroutine的能力
M: machine,工作线程,由操作系统调度</li>
</ol>
<p>M必须持有P才能运行代码
M会被系统调用阻塞</p>
<p>P的个数在程序启动时决定,默认等于CPU的核数,可以使用环境变量GOMAXPROCS或在程序中使用runtime.GOMAXPROCS()方法指定P的个数</p>
<pre tabindex=0><code>export GOMAXPROC=80

runtime.GOMAXPROCS(80)
</code></pre><p>M的个数通常稍大于P的个数,因为除了运行Go代码,还有其他内置任务需要处理.</p>
<h1 id=调度策略>调度策略<a href=#调度策略 class=hanchor arialabel=Anchor>&#8983;</a> </h1>
<ol>
<li>
<p>队列轮转
每个处理器P维护着一个协程G的队列, 处理器P依次将协程G调度到M中执行
P会周期性地查看全局队列中是否有G待运行,防止“饥饿”
全局队列中的G主要来自从系统调用中恢复的G</p>
</li>
<li>
<p>系统调用</p>
</li>
</ol>
<p>P的个数默认等于CPU的核数, 每个M必须持有一个P才能执行G
一般情况下M的个数略大于P,多出来的M将会在G产生系统调用时发挥作用</p>
<p>M池
当M运行的某个G产生系统调用时: // TODO</p>
<ol start=3>
<li>工作量窃取
通过<code>go</code>关键字创建的协程通常会优先放到当前协程对应的多处理器队列中
可能有些协程自身会不断派生新协程,有些协程不会派生,导致多个P中维护的G队列是不均衡的</li>
</ol>
<p>所以Go调度器提供了工作量窃取策略: 当某个P没有需要调度的协程时, 将从其他处理器中偷取协程</p>
<p>发生窃取前,会查询全局队列,如果全局队列中没有需要调度的协程,才会从其他P中偷取,一次偷一半</p>
<ol start=4>
<li>抢占式调度
避免某个协程长时间执行,而阻碍其他协程被调度的机制</li>
</ol>
<p>调度器会监控每个协程的执行时间, 一旦执行时间过程且有其他协程在等待时,会把当前协程暂停,转而调度等待的协程,类似<code>时间片轮转</code></p>
</div></div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=https://xujiajiadexiaokeai.github.io/2022-07-13/grpc-concepts/>
<span class=button__icon>←</span>
<span class=button__text>gRPC concepts</span>
</a>
</span>
<span class="button next">
<a href=https://xujiajiadexiaokeai.github.io/2022-07-13/go-memory/>
<span class=button__text>Go Memory</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>© 2021-2022 xujiajiadexiaokeai</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span>
</div>
</div>
</footer>
<script src=https://xujiajiadexiaokeai.github.io/assets/main.js></script>
<script src=https://xujiajiadexiaokeai.github.io/assets/prism.js></script>
<script src=https://xujiajiadexiaokeai.github.io/assets/displayInlineEquations.js></script>
</div>
</body>
</html>