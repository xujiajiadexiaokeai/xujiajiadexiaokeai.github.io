<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>eBPF on xujiajiadexiaokeai</title><link>https://xujiajiadexiaokeai.github.io/tags/ebpf/</link><description>Recent content in eBPF on xujiajiadexiaokeai</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2021-2023 xujiajiadexiaokeai</copyright><lastBuildDate>Sun, 09 Apr 2023 14:15:30 +0800</lastBuildDate><atom:link href="https://xujiajiadexiaokeai.github.io/tags/ebpf/index.xml" rel="self" type="application/rss+xml"/><item><title>[NOTE] Developing eBPF profiler for polyglot cloud-native applications</title><link>https://xujiajiadexiaokeai.github.io/2023-04-09/developing-ebpf-profiler-for-polyglot-cloud-native-applications/</link><pubDate>Sun, 09 Apr 2023 14:15:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2023-04-09/developing-ebpf-profiler-for-polyglot-cloud-native-applications/</guid><description>[NOTE] Developing eBPF profiler for polyglot cloud-native applications Agenda Infrastructure-wide profilers Low level ecosystem Stack unwinding/walking in the Linux Kernel Building profilers using BPF Walking user stacks(without frame pointers) Future work Profilers for the cloud native environment Discovery mechanism for the targets
-&amp;gt; Mechanism to collect stack traces(kernel, userspace)
-&amp;gt; Profile formats
-&amp;gt; Async symbolization &amp;amp; visualization
Low level ecosystem ELF and DWARF Executable Linkable format -ELF for obj file, executable program, shared object etc DWARF - widely used debugging format CIE - Common information Entry Tools to read ELF and/or DWARF information readily, objdump, elfutils, llvm-dwarfdump gcc also has -g option Stacktraces and x86_64 ABI What collection stack traces involve Kernel stacks Application stacks Direction of stack growth So what are stack pointers, where do they come form $rbp, $rsp &amp;amp; $rip registers $rbp: address of the base of the previous stack frame $rsp: Top of the stack, local variables Generally previous value of rsp is where FP is stored $rip: Holds the pc for the currently executing function Frame pointers are often disabled Increased binary size -&amp;gt; less i-cache hits 1 less rigister available Cons of disabling frame pointers Walking stack traces becomes more expensive Less accuracy Way more work ofr compiler / debugger / profiler developers This information is large The reality Frame pointer believers Golang &amp;gt;= 1.</description><content>&lt;h1 id="note-developing-ebpf-profiler-for-polyglot-cloud-native-applications">[NOTE] Developing eBPF profiler for polyglot cloud-native applications&lt;/h1>
&lt;h2 id="agenda">Agenda&lt;/h2>
&lt;ul>
&lt;li>Infrastructure-wide profilers&lt;/li>
&lt;li>Low level ecosystem&lt;/li>
&lt;li>Stack unwinding/walking in the Linux Kernel&lt;/li>
&lt;li>Building profilers using BPF&lt;/li>
&lt;li>Walking user stacks(without frame pointers)&lt;/li>
&lt;li>Future work&lt;/li>
&lt;/ul>
&lt;h2 id="profilers-for-the-cloud-native-environment">Profilers for the cloud native environment&lt;/h2>
&lt;p>Discovery mechanism for the targets&lt;/p>
&lt;p>-&amp;gt; Mechanism to collect stack traces(kernel, userspace)&lt;/p>
&lt;p>-&amp;gt; Profile formats&lt;/p>
&lt;p>-&amp;gt; Async symbolization &amp;amp; visualization&lt;/p>
&lt;h2 id="low-level-ecosystem">Low level ecosystem&lt;/h2>
&lt;h3 id="elf-and-dwarf">ELF and DWARF&lt;/h3>
&lt;ul>
&lt;li>Executable Linkable format -ELF
&lt;ul>
&lt;li>for obj file, executable program, shared object etc&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DWARF - widely used debugging format
&lt;ul>
&lt;li>CIE - Common information Entry&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Tools to read ELF and/or DWARF information
&lt;ul>
&lt;li>readily, objdump, elfutils, llvm-dwarfdump&lt;/li>
&lt;li>gcc also has -g option&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="stacktraces-and-x86_64-abi">Stacktraces and x86_64 ABI&lt;/h3>
&lt;ul>
&lt;li>What collection stack traces involve
&lt;ul>
&lt;li>Kernel stacks&lt;/li>
&lt;li>Application stacks&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Direction of stack growth&lt;/li>
&lt;li>So what are stack pointers, where do they come form&lt;/li>
&lt;/ul>
&lt;h3 id="rbp-rsp--rip-registers">$rbp, $rsp &amp;amp; $rip registers&lt;/h3>
&lt;ul>
&lt;li>$rbp: address of the base of the previous stack frame&lt;/li>
&lt;li>$rsp: Top of the stack, local variables
&lt;ul>
&lt;li>Generally previous value of rsp is where FP is stored&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>$rip: Holds the pc for the currently executing function&lt;/li>
&lt;/ul>
&lt;h3 id="frame-pointers-are-often-disabled">Frame pointers are often disabled&lt;/h3>
&lt;ul>
&lt;li>Increased binary size -&amp;gt; less i-cache hits&lt;/li>
&lt;li>1 less rigister available&lt;/li>
&lt;/ul>
&lt;h3 id="cons-of-disabling-frame-pointers">Cons of disabling frame pointers&lt;/h3>
&lt;ul>
&lt;li>Walking stack traces becomes more expensive&lt;/li>
&lt;li>Less accuracy&lt;/li>
&lt;li>Way more work ofr compiler / debugger / profiler developers&lt;/li>
&lt;li>This information is large&lt;/li>
&lt;/ul>
&lt;h3 id="the-reality">The reality&lt;/h3>
&lt;h3 id="frame-pointer-believers">Frame pointer believers&lt;/h3>
&lt;ul>
&lt;li>Golang &amp;gt;= 1.7&lt;/li>
&lt;li>MacOS&lt;/li>
&lt;li>The Linux Kernel(*):
&lt;ul>
&lt;li>CONFIG_UNWINDER_FRAME_POINTER and CONFIG_UNWINDER_ORC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="stack-unwinding-in-the-linux-kernel-wo-fp">Stack unwinding in the Linux kernel w/o fp&lt;/h3>
&lt;ul>
&lt;li>ORC (CONFIG_UNWINDER_ORC x86_64 only)&lt;/li>
&lt;li>Doesn&amp;rsquo;t rely on .debug_frame/.eh_frame&lt;/li>
&lt;li>Enabled by some of the major cloud vendors&lt;/li>
&lt;/ul>
&lt;h3 id="unwinding-the-stack-without-frame-pointers">Unwinding the stack without frame pointers&lt;/h3>
&lt;ul>
&lt;li>DWARF unwind information
&lt;ul>
&lt;li>.eh_frame&lt;/li>
&lt;li>.debug_frame&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Synthesizing them from object code&lt;/li>
&lt;li>Guessing which stack vlues are return addresses&lt;/li>
&lt;/ul>
&lt;h3 id="eh_frame---unwind-tables">.eh_frame - unwind tables&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ readelf -wF ./test_binary
&lt;/code>&lt;/pre>&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">LOC&lt;/th>
&lt;th style="text-align:center">CFA&lt;/th>
&lt;th style="text-align:center">rbp&lt;/th>
&lt;th style="text-align:center">ra&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">00000000004011f0&lt;/td>
&lt;td style="text-align:center">rsp+8&lt;/td>
&lt;td style="text-align:center">u&lt;/td>
&lt;td style="text-align:center">c-8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">00000000004011f1&lt;/td>
&lt;td style="text-align:center">rsp+16&lt;/td>
&lt;td style="text-align:center">c-16&lt;/td>
&lt;td style="text-align:center">c-8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">00000000004011f4&lt;/td>
&lt;td style="text-align:center">rbp+16&lt;/td>
&lt;td style="text-align:center">c-16&lt;/td>
&lt;td style="text-align:center">c-8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">0000000000401242&lt;/td>
&lt;td style="text-align:center">rsp+8&lt;/td>
&lt;td style="text-align:center">c-16&lt;/td>
&lt;td style="text-align:center">c-8&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="eh_frame---generating-unwind-tables">.eh_frame - generating unwind tables&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ readelf --debug-dump&lt;span style="color:#f92672">=&lt;/span>frames ./test_binary
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="stack-unwinding-with-ebpf">Stack unwinding with eBPF&lt;/h2>
&lt;h3 id="with-frame-pointers">With frame pointers&lt;/h3>
&lt;pre tabindex="0">&lt;code>user_stack = map&amp;lt;stack_id, array&amp;lt;addresses&amp;gt;&amp;gt;
add_stack bumps map&amp;lt;stack_id, count_t&amp;gt;
stack_id = bpd_get_stackid(ctx, &amp;amp;user_stacks, BPF_F_USER_STACK);
add_stack(stack_id);
&lt;/code>&lt;/pre>&lt;h3 id="without-frame-pointers">Without frame pointers&lt;/h3>
&lt;ul>
&lt;li>BPF code: ~250 lines of C&lt;/li>
&lt;li>DWARF unwind info parser and evaluator: &amp;gt;1k lines of Go&lt;/li>
&lt;/ul>
&lt;h3 id="unwinding-wo-frame-pointers---architecture">Unwinding w/o frame pointers - architecture&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;pre tabindex="0">&lt;code>struct unwind_row {
u64 program_counter;
type_t previous_rsp;
type_t previous_rbp;
}
&lt;/code>&lt;/pre>&lt;h3 id="unwinding-wo-frame-pointers---unwind-table-gen">Unwinding w/o frame pointers - unwind table gen&lt;/h3>
&lt;ul>
&lt;li>.eh_frame / .debug_frame
&lt;ul>
&lt;li>Parse&lt;/li>
&lt;li>Evaluate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="unwinding-wo-frame-pointers---bpf">Unwinding w/o frame pointers - BPF&lt;/h3>
&lt;ul>
&lt;li>Find the unwind table for the current process&lt;/li>
&lt;li>While main isn&amp;rsquo;t reached:
&lt;ul>
&lt;li>Append the program counter ($rip) to the walked stack&lt;/li>
&lt;li>Find the unwind row for the current program counter&lt;/li>
&lt;li>Restore registers for the provious frame
&lt;ul>
&lt;li>Return address $rip&lt;/li>
&lt;li>Stack pointer $rsp&lt;/li>
&lt;li>And $rbp, too&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Efficiently finding the unwind data for a program counter&lt;/li>
&lt;li>Fun to implement in BPF&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">find_offset_for_pc&lt;/span>(__u32 index, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>data) {
&lt;span style="color:#66d9ef">struct&lt;/span> callback_ctx &lt;span style="color:#f92672">*&lt;/span>ctx &lt;span style="color:#f92672">=&lt;/span> data;
&lt;span style="color:#66d9ef">if&lt;/span> (ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>left &lt;span style="color:#f92672">&amp;gt;=&lt;/span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>right) {
LOG(&lt;span style="color:#e6db74">&amp;#34;.done&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
u32 mid &lt;span style="color:#f92672">=&lt;/span> (ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>left &lt;span style="color:#f92672">+&lt;/span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>right) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#75715e">// Appease the verifier.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (mid &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> mid &lt;span style="color:#f92672">&amp;lt;=&lt;/span> MAX_UNWIND_TABLE_SIZE) {
LOG(&lt;span style="color:#e6db74">&amp;#34;.should never happen&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span> (ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>table&lt;span style="color:#f92672">-&lt;/span>rows[mid].pc &lt;span style="color:#f92672">&amp;lt;=&lt;/span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pc) {
ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>found &lt;span style="color:#f92672">=&lt;/span> mid;
ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>left &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
} &lt;span style="color:#66d9ef">else&lt;/span> {
ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>right &lt;span style="color:#f92672">=&lt;/span> mid;
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="unwinding-wo-frame-pointers---future-work">Unwinding w/o frame pointers - Future work&lt;/h3>
&lt;ul>
&lt;li>Testing more complex binaries&lt;/li>
&lt;li>arm64 support&lt;/li>
&lt;li>Static table size&lt;/li>
&lt;li>But we know we will hit limits&lt;/li>
&lt;li>Reduce minimum required kernel version&lt;/li>
&lt;li>Engage with various communities&lt;/li>
&lt;/ul>
&lt;h1 id="sources">Sources&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Gr1rrSzvqfg">https://www.youtube.com/watch?v=Gr1rrSzvqfg&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>MacOS用户快速上手Cilium eBPF</title><link>https://xujiajiadexiaokeai.github.io/2022-03-06/cilium-ebpf-quick-tutorial/</link><pubDate>Sun, 06 Mar 2022 20:41:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-03-06/cilium-ebpf-quick-tutorial/</guid><description>机器: Macbook Pro 13inch 2015款
系统: macOS Mojave 10.14.6
安装虚拟机 首先需要一个linux发行版,选择安装一个虚拟机来装Ubuntu,找到了multipass.
multipass是Ubuntu旗下一款虚拟机产品,适用个各个平台,可以在本地快速的开启一个虚拟机
Multipass orchestrates virtual Ubuntu instances
版本: 1.8.1+mac
multipass version 安装完成后,指定VirtualBox为vm driver
sudo multipass set local.driver=virtualbox Using VirtualBox in Multipass on macOS | Multipass documentation
快速启动一台当前最新LTS版的Ubuntu虚拟机并等待启动完成
$ multipass launch --name ubuntu 配置ssh 这一步主要是为了能够使用开发机上vscode来连接到虚拟机进行coding,毕竟如果不是很熟悉使用vim的开发者,在terminal内编程还是有点困难
multipass启动的虚拟机默认开放22端口,也内置了ssh server.但是,因为处于不同网段,如果想要公开这个端口供开发机连接,需要使用VirtualBox的端口转发功能,将22端口映射到宿主机的某个端口,这样就提供了外部访问的能力.在终端输入:
sudo VBoxManage controlvm &amp;#34;ubuntu&amp;#34; natpf1 &amp;#34;myservice,tcp,,22,,2222&amp;#34; 该命令为ubuntu实例(也就是虚拟机)在natpf1网卡上添加了一条转发规则,规则名叫做&amp;quot;myservice&amp;quot;,tcp协议,将所有到达宿主机2222端口的流量转发到实例的22端口上
局域网记得锁定ip
安装go sudo snap install go --classic 克隆cilium/ebpf项目 git clone https://github.com/cilium/ebpf.git 运行example cd ebpf/examples/ go run -exec sudo .</description><content>&lt;p>机器: Macbook Pro 13inch 2015款&lt;/p>
&lt;p>系统: macOS Mojave 10.14.6&lt;/p>
&lt;h1 id="安装虚拟机">安装虚拟机&lt;/h1>
&lt;p>首先需要一个linux发行版,选择安装一个虚拟机来装Ubuntu,找到了multipass.&lt;/p>
&lt;p>multipass是Ubuntu旗下一款虚拟机产品,适用个各个平台,可以在本地快速的开启一个虚拟机&lt;/p>
&lt;p>&lt;a href="https://multipass.run/">Multipass orchestrates virtual Ubuntu instances&lt;/a>&lt;/p>
&lt;p>版本: 1.8.1+mac&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">multipass version
&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装完成后,指定VirtualBox为vm driver&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">sudo multipass set local.driver=virtualbox
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://multipass.run/docs/using-virtualbox-in-multipass-macos">Using VirtualBox in Multipass on macOS | Multipass documentation&lt;/a>&lt;/p>
&lt;p>快速启动一台当前最新LTS版的Ubuntu虚拟机并等待启动完成&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">$ multipass launch --name ubuntu
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置ssh">配置ssh&lt;/h1>
&lt;p>这一步主要是为了能够使用开发机上vscode来连接到虚拟机进行coding,毕竟如果不是很熟悉使用vim的开发者,在terminal内编程还是有点困难&lt;/p>
&lt;p>multipass启动的虚拟机默认开放22端口,也内置了ssh server.但是,因为处于不同网段,如果想要公开这个端口供开发机连接,需要使用&lt;a href="https://www.virtualbox.org/manual/ch06.html#natforward">&lt;strong>VirtualBox的端口转发&lt;/strong>&lt;/a>功能,将22端口映射到宿主机的某个端口,这样就提供了外部访问的能力.在终端输入:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">sudo VBoxManage controlvm &amp;#34;ubuntu&amp;#34; natpf1 &amp;#34;myservice,tcp,,22,,2222&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>该命令为ubuntu实例(也就是虚拟机)在natpf1网卡上添加了一条转发规则,规则名叫做&amp;quot;myservice&amp;quot;,tcp协议,将所有到达宿主机2222端口的流量转发到实例的22端口上&lt;/p>
&lt;p>局域网记得锁定ip&lt;/p>
&lt;h1 id="安装go">安装go&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">sudo snap install go --classic
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="克隆ciliumebpf项目">克隆cilium/ebpf项目&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">git clone https://github.com/cilium/ebpf.git
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="运行example">运行example&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">cd ebpf/examples/
go run -exec sudo ./kprobe
&lt;/code>&lt;/pre>&lt;/div></content></item></channel></rss>