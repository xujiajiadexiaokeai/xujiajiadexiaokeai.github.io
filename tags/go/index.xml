<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on xujiajiadexiaokeai</title><link>https://xujiajiadexiaokeai.github.io/tags/go/</link><description>Recent content in Go on xujiajiadexiaokeai</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2021-2023 xujiajiadexiaokeai</copyright><lastBuildDate>Mon, 10 Apr 2023 14:25:30 +0800</lastBuildDate><atom:link href="https://xujiajiadexiaokeai.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>[NOTE] Go Profiling and Observability from Scratch</title><link>https://xujiajiadexiaokeai.github.io/2023-04-10/go-profiling-and-observability-from-scratch/</link><pubDate>Mon, 10 Apr 2023 14:25:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2023-04-10/go-profiling-and-observability-from-scratch/</guid><description>[NOTE] Go Profiling and Observability from Scratch Agenda Scheduling &amp;amp; Memory Management: A simple model Profiling: CPU, Memory, Mutex, Block, Goroutine + Overhead Benchmarks Tracing: Manually, Distributed, Runtime Metrics: Runtime Metrics 3rd party Tools: Linux perf, BPF, Delve,fgprof Scheduling &amp;amp; Memory Management Go&amp;rsquo;s primary job is to multiplex and abstract hardware resources Very similar to an operating system, - it&amp;rsquo;s turtles all the way down Following model recap for some, but perhaps more useful than more complex models usually presented.</description><content>&lt;h1 id="note-go-profiling-and-observability-from-scratch">[NOTE] Go Profiling and Observability from Scratch&lt;/h1>
&lt;h2 id="agenda">Agenda&lt;/h2>
&lt;ul>
&lt;li>Scheduling &amp;amp; Memory Management: A simple model&lt;/li>
&lt;li>Profiling: CPU, Memory, Mutex, Block, Goroutine + Overhead Benchmarks&lt;/li>
&lt;li>Tracing: Manually, Distributed, Runtime&lt;/li>
&lt;li>Metrics: Runtime Metrics&lt;/li>
&lt;li>3rd party Tools: Linux perf, BPF, Delve,fgprof&lt;/li>
&lt;/ul>
&lt;h2 id="scheduling--memory-management">Scheduling &amp;amp; Memory Management&lt;/h2>
&lt;ul>
&lt;li>Go&amp;rsquo;s primary job is to multiplex and abstract hardware resources&lt;/li>
&lt;li>Very similar to an operating system, - it&amp;rsquo;s turtles all the way down&lt;/li>
&lt;li>Following model recap for some, but perhaps more useful than more complex models usually presented.&lt;/li>
&lt;/ul>
&lt;h3 id="scheduling">Scheduling&lt;/h3>
&lt;ul>
&lt;li>Go schedules goroutines onto CPUs (OS Threads)&lt;/li>
&lt;li>Deeply integrated with networking, channels and mutexes&lt;/li>
&lt;li>Scalable to hundred of thousands of goroutines&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="../../img/image-20230410152956115.png" alt="image-20230410152956115">&lt;/p>
&lt;h3 id="memory-management">Memory Management&lt;/h3>
&lt;ul>
&lt;li>Small stack per goroutine (4kB+)&lt;/li>
&lt;li>Big heap, needed for shared data and other reasons&lt;/li>
&lt;li>Stack allocation is very cheap&lt;/li>
&lt;li>Heap allocation and GC is expensive (20%+ CPU Time common)&lt;/li>
&lt;li>Reduce: Turn heap into stack allocs or avoid completely&lt;/li>
&lt;li>Reuse: Reuse heap allocations like structs and buffers&lt;/li>
&lt;li>Recycle: Some GC work is inevitable, it&amp;rsquo;s okay&lt;/li>
&lt;li>Reducing heap allocs speed up unrelated code (GC thrashes CPU Caches)&lt;/li>
&lt;/ul>
&lt;h3 id="memory-management-heap">Memory Management: Heap&lt;/h3>
&lt;ul>
&lt;li>Referenced Allocation (In-Use)&lt;/li>
&lt;li>Unreferenced Allocation (Garbage)&lt;/li>
&lt;/ul>
&lt;h2 id="profiling">Profiling&lt;/h2>
&lt;h3 id="cpu-profiler">CPU Profiler&lt;/h3>
&lt;ul>
&lt;li>Captures: On-CPU time of your code by interrupting the process after every 10ms of CPU Time to take a stack trace.&lt;/li>
&lt;li>Profile Data: Sample count and time spent per stack trace&lt;/li>
&lt;li>Sample Rate: runtime.SetCPUProfileRate(hz)&lt;/li>
&lt;/ul>
&lt;h3 id="cpu-profiler-sigprof-for-every-10ms-of-cpu-time">CPU Profiler: SIGPROF for every 10ms of CPU Time&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// go 1.17.3 src/runtime/signal_unix.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">setProcessCPUPROFILER&lt;/span>(&lt;span style="color:#a6e22e">hz&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">hz&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#75715e">// Enable the Go signal handler if not enabled.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">atomic&lt;/span>.&lt;span style="color:#a6e22e">Cas&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">handlingSig&lt;/span>[&lt;span style="color:#a6e22e">_SIGPROF&lt;/span>], &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;span style="color:#a6e22e">atomic&lt;/span>.&lt;span style="color:#a6e22e">Storeuintptr&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">fwdSig&lt;/span>[&lt;span style="color:#a6e22e">_SIGPROF&lt;/span>], &lt;span style="color:#a6e22e">getsig&lt;/span>(&lt;span style="color:#a6e22e">_SIGPROF&lt;/span>))
&lt;span style="color:#a6e22e">setsig&lt;/span>(&lt;span style="color:#a6e22e">_SIGPROF&lt;/span>, &lt;span style="color:#a6e22e">funcPC&lt;/span>(&lt;span style="color:#a6e22e">sighandler&lt;/span>))
}
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">it&lt;/span> &lt;span style="color:#a6e22e">itimerval&lt;/span>
&lt;span style="color:#a6e22e">it&lt;/span>.&lt;span style="color:#a6e22e">it_interval&lt;/span>.&lt;span style="color:#a6e22e">tv_sec&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#a6e22e">it&lt;/span>.&lt;span style="color:#a6e22e">it_interval&lt;/span>.&lt;span style="color:#a6e22e">set_usec&lt;/span>(&lt;span style="color:#ae81ff">1000000&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">hz&lt;/span>)
&lt;span style="color:#a6e22e">it&lt;/span>.&lt;span style="color:#a6e22e">it_value&lt;/span> = &lt;span style="color:#a6e22e">it&lt;/span>.&lt;span style="color:#a6e22e">it_interval&lt;/span>
&lt;span style="color:#a6e22e">setitimer&lt;/span>(&lt;span style="color:#a6e22e">_ITIMER_PROF&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">it&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
} &lt;span style="color:#66d9ef">else&lt;/span> {&lt;span style="color:#f92672">...&lt;/span>}
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sighandler&lt;/span>(&lt;span style="color:#a6e22e">sig&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>, &lt;span style="color:#a6e22e">info&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">siginfo&lt;/span>, &lt;span style="color:#a6e22e">ctxt&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>, &lt;span style="color:#a6e22e">gp&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">g&lt;/span>) {
&lt;span style="color:#a6e22e">_g_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">getg&lt;/span>()
&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sigctxt&lt;/span>{&lt;span style="color:#a6e22e">info&lt;/span>, &lt;span style="color:#a6e22e">ctxt&lt;/span>}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">sig&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">_SIGPROF&lt;/span> {
&lt;span style="color:#a6e22e">sigprof&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">sigpc&lt;/span>(), &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">sigsp&lt;/span>(), &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">siglr&lt;/span>(), &lt;span style="color:#a6e22e">gp&lt;/span>, &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span>
}
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cpu-profiler-add-stacktrace-to-profile">CPU Profiler: Add Stacktrace to Profile&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// go 1.17.3 src/runtime/proc.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">maxCPUProfStack&lt;/span> = &lt;span style="color:#ae81ff">64&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sigprof&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>, &lt;span style="color:#a6e22e">lr&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">gp&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">g&lt;/span>, &lt;span style="color:#a6e22e">mp&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">m&lt;/span>) {
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stk&lt;/span> [&lt;span style="color:#a6e22e">maxCPUProfStack&lt;/span>]&lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">gentraceback&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>, &lt;span style="color:#a6e22e">lr&lt;/span>, &lt;span style="color:#a6e22e">gp&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">stk&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>], len(&lt;span style="color:#a6e22e">stk&lt;/span>), &lt;span style="color:#f92672">...&lt;/span>)
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">cpuprof&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#a6e22e">gp&lt;/span>, &lt;span style="color:#a6e22e">stk&lt;/span>[:&lt;span style="color:#a6e22e">n&lt;/span>])
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cpu-profiler-waiting-for-go-118">CPU Profiler: Waiting for Go 1.18&lt;/h3>
&lt;ul>
&lt;li>setitimer(2) fails to deliver more than 250 signals per second, biases profile to underestimate CPU Spikes, see GH #35057&lt;/li>
&lt;li>Go 1.18 patch from Rhys Hiltner will fix this and thread bias issues such as GH #14434 by using timer_create(2)&lt;/li>
&lt;/ul>
&lt;h3 id="block-profiler">Block Profiler&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Captures: Off-CPU time waiting on channels and mutexes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>But not: Sleep, I/O, Syscalls, GC, etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Profile Data: Cumulative contentions and delays per stack trace&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">stack trace&lt;/th>
&lt;th style="text-align:center">contentions/count&lt;/th>
&lt;th style="text-align:center">delay/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">main; foo;runtime.chansend1&lt;/td>
&lt;td style="text-align:center">22820&lt;/td>
&lt;td style="text-align:center">867549417&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">main; foo;bar;tuntime.chanrecv1&lt;/td>
&lt;td style="text-align:center">22748&lt;/td>
&lt;td style="text-align:center">453510869&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">main;foobar;sync.(*Mutex).Lock&lt;/td>
&lt;td style="text-align:center">795&lt;/td>
&lt;td style="text-align:center">5351086&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>Sample Rate: runtime.SetBlockProfileRate(rate)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="mutex-profiler">Mutex Profiler&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Captures: Off-CPU time waiting on mutexes (not channels)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Profile data: Cumulative contentions and delays per stack trace&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">stack trace&lt;/th>
&lt;th style="text-align:center">contentions/count&lt;/th>
&lt;th style="text-align:center">delay/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">main; foo; sync.(*Mutex).Unlock&lt;/td>
&lt;td style="text-align:center">22820&lt;/td>
&lt;td style="text-align:center">867549417&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">main; foo;bar;sync.(*Mutex).Unlock&lt;/td>
&lt;td style="text-align:center">22748&lt;/td>
&lt;td style="text-align:center">453510869&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">main;foobar;sync.(*Mutex).Unlock&lt;/td>
&lt;td style="text-align:center">795&lt;/td>
&lt;td style="text-align:center">5351086&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>Rate: runtime.SetMutexProfileFraction(rate)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="block-vs-mutex">Block vs Mutex&lt;/h3>
&lt;ul>
&lt;li>Block seems like a superset of mutex profile, but it&amp;rsquo;s not:&lt;/li>
&lt;li>&lt;strong>Mutex profile&lt;/strong> shows what code is &lt;strong>doing the blocking&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Block profile&lt;/strong> show what code is &lt;strong>getting blocked&lt;/strong>&lt;/li>
&lt;li>Both perspectives are useful, so enable both profilers&lt;/li>
&lt;/ul>
&lt;h3 id="quick-note-on-time">Quick Note on Time&lt;/h3>
&lt;p>&lt;img src="../../img/image-20230410194639932.png" alt="image-20230410194639932">&lt;/p>
&lt;p>On-CPU Time &amp;gt; Real Time&lt;/p>
&lt;p>&lt;img src="../../img/image-20230410194928468.png" alt="image-20230410194928468">&lt;/p>
&lt;ul>
&lt;li>Goroutine Time: Cumulative (end - start) time of all goroutines&lt;/li>
&lt;li>CPU Time: CPU tiem circle can be larger than Real time circle&lt;/li>
&lt;li>Mutex Time&lt;/li>
&lt;li>Block Time: Block time is a superset of mutex time (but with different call stacks)&lt;/li>
&lt;li>Untracked Off-CPU Waiting Time: Profiling Blindspot!&lt;/li>
&lt;/ul>
&lt;h3 id="memory-profiling">Memory Profiling&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Profile Data: Cumulative allocs and inuse per stack trace&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>alloc_objects/count&lt;/th>
&lt;th>alloc_space/bytes&lt;/th>
&lt;th>inuse_objects/count&lt;/th>
&lt;th>inuse_space/bytes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main; foo&lt;/td>
&lt;td>5&lt;/td>
&lt;td>120&lt;/td>
&lt;td>2&lt;/td>
&lt;td>48&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foo;bar&lt;/td>
&lt;td>3&lt;/td>
&lt;td>768&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar&lt;/td>
&lt;td>4&lt;/td>
&lt;td>512&lt;/td>
&lt;td>1&lt;/td>
&lt;td>128&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>Samples captured every 512kB of malloc() and when those objects are free()&amp;rsquo;d by the GC later on (inuse = allocs - frees)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Sample Rate: runtime.memProfileRate = rate (default = 512kB)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;alice&amp;#34;&lt;/span>}
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;User: %v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">user&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">LEAQ type.&amp;quot;&amp;quot;.User(SB), AX
PCDATA $1, $0
NOP
CALL runtime.newobject(SB)
MOVQ $5, 8(AX)
LEAQ go.string.&amp;quot;alice&amp;quot;(SB), CX
MOVQ CX, (AX)
&lt;/code>&lt;/pre>&lt;h3 id="goroutine-profiling">Goroutine Profiling&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Profile Data: Goroutine count per stack trace&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>goroutine/count&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main;foo&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main; foo;bar&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>O(N) &lt;strong>Stop-The-World&lt;/strong> where N is the total number of goroutines (cause tail latency)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>No Sampling Mechanism&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use Cases&lt;/strong>: Detect goroutine leaks and diagnose hanging programs(debug=2)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="tracing">Tracing&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Tracing&lt;/strong>: Recording of time-stamped events&lt;/p>
&lt;p>Distinction with logging can be muddy, depends on context&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Distributed Tracing&lt;/strong>: Tracing requests through multiple services&lt;/p>
&lt;p>Highly recommended to understand performance from system perspective&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Runtime Tracing&lt;/strong>: Go&amp;rsquo;s built-in tracer&lt;/p>
&lt;p>Can shine a light on profiling blindspots (e.g. I/O, Sleep, GC, Scheduler Backlog)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Tracing Profiler&lt;/strong>: Tracing every function call&lt;/p>
&lt;p>Doesn&amp;rsquo;t currently exist for Go&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="runtime-tracer">Runtime Tracer&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Traces Scheduler, GC, Contentions, Syscall, etc.&lt;/p>
&lt;p>see src/runtime/trace.go for a list of events&lt;/p>
&lt;/li>
&lt;li>
&lt;p>High-overhead firehose that produces a lot of data&lt;/p>
&lt;/li>
&lt;li>
&lt;p>But fantastic way to track down latency when nothing else seems to have the answer&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="profiling-and-tracing-overhead-analysis">Profiling and Tracing Overhead Analysis&lt;/h3>
&lt;ul>
&lt;li>Run different workloads in a loop for 1 minute with and without various profilers enabled, measure avg latency&lt;/li>
&lt;li>Repeat each experiment 5 times&lt;/li>
&lt;li>Performed on a AWS c5.4xlarge machine(6h total duration)&lt;/li>
&lt;li>This is hard! Early sneak peek, bad env, bad stats, naive workloads, do not trst too much!&lt;/li>
&lt;/ul>
&lt;h3 id="overhead-analysis-error-sources">Overhead Analysis: Error Sources&lt;/h3>
&lt;ul>
&lt;li>Dynamic frequency scaling (Turbo Boost)&lt;/li>
&lt;li>Noisy Nerghbors&lt;/li>
&lt;li>Human error&lt;/li>
&lt;li>Check for new results by the time you watch this&lt;/li>
&lt;li>But: Very low overhead for cpu, memory, mutex and block profiler for non-pathological workloads&lt;/li>
&lt;/ul>
&lt;h2 id="metrics">Metrics&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Use runtime/metrics (Go 1.16+), highlights: (*mB ~ 100mB)&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>metric&lt;/th>
&lt;th>description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>/gc/pauses:seconds&lt;/strong>&lt;/td>
&lt;td>Stop-the-world pause latency histogram&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>/sched/latencies:seconds&lt;/strong>&lt;/td>
&lt;td>Goroutines waiting in runnable state latency histogram&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/sched/goroutines:goroutines&lt;/td>
&lt;td>Number of live goroutines&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/memory/classes/heap/objects:bytes&lt;/td>
&lt;td>Current heap memory usage&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/memory/classes/heap/stacksbytes&lt;/td>
&lt;td>Current stack memory usage&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>/memory/classes/profiling/buckets:bytes&lt;/strong>&lt;/td>
&lt;td>Memory used by internal profiling hash maps&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>Recommendation: Capture all runtime/metrics&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="3rd-party-tools">3rd Party Tools&lt;/h2>
&lt;ul>
&lt;li>Linux Perf&lt;/li>
&lt;li>bpftrace&lt;/li>
&lt;li>delve&lt;/li>
&lt;li>fgprof&lt;/li>
&lt;/ul>
&lt;h2 id="scheduling--execution-observability">Scheduling / Execution Observability&lt;/h2>
&lt;ul>
&lt;li>Profilers: CPU, Block, Mutex, Goroutine&lt;/li>
&lt;li>Tracing: Runtime Execution Tracer, Distributed Tracing&lt;/li>
&lt;li>Metrics: Scheduler Latency, Goroutine Count&lt;/li>
&lt;li>Compile Time: Function Inlining (go build -gcflags='-m')&lt;/li>
&lt;/ul>
&lt;h2 id="memory-management-observability">Memory Management Observability&lt;/h2>
&lt;ul>
&lt;li>Profilers: Memory Profiler&lt;/li>
&lt;li>Tracing: Runtime Tracing (GC Events)&lt;/li>
&lt;li>Metrics: GC counters, GC pause times, Heap Stats, Stack Stats&lt;/li>
&lt;li>Compile Time: Escape Analysis (go build -gcflags='-m')&lt;/li>
&lt;/ul>
&lt;h2 id="recap">Recap&lt;/h2>
&lt;ul>
&lt;li>Go runtime offers great observability out of the box&lt;/li>
&lt;li>Most tools play nice with production workloads&lt;/li>
&lt;li>3rd party tools and custom instrumentation can close the gaps&lt;/li>
&lt;/ul>
&lt;h2 id="source">Source&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7hg4T2Qqowk">GopherCon 2021: Felix Geisendörfer - Go Profiling and Observability from Scratch&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>[NOTE] Building a Go profiler using Go</title><link>https://xujiajiadexiaokeai.github.io/2023-04-10/building-a-go-profiler-using-go/</link><pubDate>Mon, 10 Apr 2023 09:35:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2023-04-10/building-a-go-profiler-using-go/</guid><description>[NOTE] Building a Go profiler using Go What is profilling A form of dynamic program analysis that measures resource consumption
For example:
the space (memory) time complexity of a program (CPU) usage of instructions frequency and duration of function calls Why use profiling Profiling is about how do we know:
What&amp;rsquo;s worth optimizing? What needs optimization? How to profiling Tracing Recording each and every event constantly High costs Sampling Sample for a certain duration Eg.</description><content>&lt;h1 id="note-building-a-go-profiler-using-go">[NOTE] Building a Go profiler using Go&lt;/h1>
&lt;h2 id="what-is-profilling">What is profilling&lt;/h2>
&lt;p>A form of dynamic program analysis that &lt;strong>measures&lt;/strong> resource consumption&lt;/p>
&lt;p>For example:&lt;/p>
&lt;ul>
&lt;li>the &lt;strong>space&lt;/strong> (memory)&lt;/li>
&lt;li>&lt;strong>time complexity&lt;/strong> of a program (CPU)&lt;/li>
&lt;li>&lt;strong>usage of instructions&lt;/strong>&lt;/li>
&lt;li>&lt;strong>frequency&lt;/strong> and &lt;strong>duration&lt;/strong> of function calls&lt;/li>
&lt;/ul>
&lt;h2 id="why-use-profiling">Why use profiling&lt;/h2>
&lt;p>Profiling is about how do we know:&lt;/p>
&lt;ul>
&lt;li>What&amp;rsquo;s worth optimizing?&lt;/li>
&lt;li>What needs optimization?&lt;/li>
&lt;/ul>
&lt;h2 id="how-to-profiling">How to profiling&lt;/h2>
&lt;ul>
&lt;li>Tracing
&lt;ul>
&lt;li>Recording each and every event constantly&lt;/li>
&lt;li>High costs&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Sampling
&lt;ul>
&lt;li>Sample for a certain duration
&lt;ul>
&lt;li>Eg. 10 seconds&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Periodically observe function call stack
&lt;ul>
&lt;li>Eg. 100x per second&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Low overhead
&lt;ul>
&lt;li>&amp;lt;0.5% CPU&lt;/li>
&lt;li>~4MB memory&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="tiny-profiler">Tiny Profiler&lt;/h2>
&lt;ul>
&lt;li>A proof-of-concept profiler&lt;/li>
&lt;li>Profile all Go processes on a machine&lt;/li>
&lt;li>Produce pprof formatted profiles every 10s&lt;/li>
&lt;/ul>
&lt;h2 id="continuous-profiling">Continuous Profiling&lt;/h2>
&lt;ul>
&lt;li>pprof creates profile samples&lt;/li>
&lt;li>We want to sample every so often&lt;/li>
&lt;li>Little overhead due to sampling&lt;/li>
&lt;li>We hope to get profiles right before OOMs&lt;/li>
&lt;li>Automatically collect profiles rather than by hand&lt;/li>
&lt;/ul>
&lt;h2 id="source">Source&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=OlHQ6gkwqyA">GopherCon Europe 2022: Kemal Akkoyun - Building a Go Profiler Using Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36575.pdf">Google-Wide Profiling: A Continuous Profiling Infrastructure For Data Centers&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>为什么select仅能作用于管道?</title><link>https://xujiajiadexiaokeai.github.io/2022-11-17/why-select-only-work-on-channel/</link><pubDate>Thu, 17 Nov 2022 19:15:45 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-11-17/why-select-only-work-on-channel/</guid><description>select的特性 case的执行 具体执行那个case,取决于函数传入的管道
管道没有缓冲区 有缓冲区并且还可以塞数据 有缓冲区但缓冲区已满 有缓冲区且已有部分数据 返回值 可以在case中声明变量并赋值
default default不能处理管道读写 当所有case被阻塞,执行default default是特殊的case
使用案例 永久阻塞 使用select阻塞main函数
func main() { server := webhooktesting.NewTestServer(nil) server.StartTLS() fmt.Println(&amp;#34;serving on&amp;#34;, server.URL) select {} // 没有case和default ,main()永久阻塞 } 快速检错 当使用管道来传输error时, 可以使用select快速检查管道中是否有error
errCh := make(chan error, active) jm.deleteJobPods(&amp;amp;job, activePods, errCh) // 传入chan用于记录error select { case manageJobErr = &amp;lt;-errCh: if manageJobErr != nil { break } default: // 没有error, 结束 } 限时等待 当使用管道管理函数上下文时, 可以使用select创建具有时效性的管道
func waitForStopOrTimeout(stopCh &amp;lt;-chan struct{}, timeout time.</description><content>&lt;h1 id="select的特性">select的特性&lt;/h1>
&lt;h2 id="case的执行">case的执行&lt;/h2>
&lt;p>具体执行那个case,取决于函数传入的管道&lt;/p>
&lt;ul>
&lt;li>管道没有缓冲区&lt;/li>
&lt;li>有缓冲区并且还可以塞数据&lt;/li>
&lt;li>有缓冲区但缓冲区已满&lt;/li>
&lt;li>有缓冲区且已有部分数据&lt;/li>
&lt;/ul>
&lt;h2 id="返回值">返回值&lt;/h2>
&lt;p>可以在case中声明变量并赋值&lt;/p>
&lt;h2 id="default">default&lt;/h2>
&lt;p>default不能处理管道读写
当所有case被阻塞,执行default
default是特殊的case&lt;/p>
&lt;h1 id="使用案例">使用案例&lt;/h1>
&lt;h2 id="永久阻塞">永久阻塞&lt;/h2>
&lt;p>使用select阻塞main函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">webhooktesting&lt;/span>.&lt;span style="color:#a6e22e">NewTestServer&lt;/span>(&lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">StartTLS&lt;/span>()
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;serving on&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">URL&lt;/span>)
&lt;span style="color:#66d9ef">select&lt;/span> {} &lt;span style="color:#75715e">// 没有case和default ,main()永久阻塞
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快速检错">快速检错&lt;/h2>
&lt;p>当使用管道来传输error时, 可以使用select快速检查管道中是否有error&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">errCh&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>, &lt;span style="color:#a6e22e">active&lt;/span>)
&lt;span style="color:#a6e22e">jm&lt;/span>.&lt;span style="color:#a6e22e">deleteJobPods&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">job&lt;/span>, &lt;span style="color:#a6e22e">activePods&lt;/span>, &lt;span style="color:#a6e22e">errCh&lt;/span>) &lt;span style="color:#75715e">// 传入chan用于记录error
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">select&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">manageJobErr&lt;/span> = &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">errCh&lt;/span>:
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">manageJobErr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">break&lt;/span>
}
&lt;span style="color:#66d9ef">default&lt;/span>: &lt;span style="color:#75715e">// 没有error, 结束
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="限时等待">限时等待&lt;/h2>
&lt;p>当使用管道管理函数上下文时, 可以使用select创建具有时效性的管道&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">waitForStopOrTimeout&lt;/span>(&lt;span style="color:#a6e22e">stopCh&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}, &lt;span style="color:#a6e22e">timeout&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>) &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{} {
&lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{})
&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;span style="color:#66d9ef">select&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">stopCh&lt;/span>:
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">After&lt;/span>(&lt;span style="color:#a6e22e">timeout&lt;/span>): &lt;span style="color:#75715e">// 管道会在指定时间内关闭
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
close(&lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span>)
}()
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">stopChWithTimeout&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="实现原理">实现原理&lt;/h1>
&lt;ul>
&lt;li>为什么每个case语句只能处理一个管道?&lt;/li>
&lt;li>为什么case语句执行顺序随机(多个case都就绪的情况下)?&lt;/li>
&lt;li>为什么case语句向值为nil的管道中写数据不会触发panic?&lt;/li>
&lt;/ul>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">scase&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">hchan&lt;/span> &lt;span style="color:#75715e">// 操作的管道
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">kind&lt;/span> &lt;span style="color:#a6e22e">unit16&lt;/span> &lt;span style="color:#75715e">// case类型
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">elem&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span> &lt;span style="color:#75715e">// 指向数据存放位置的指针
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">...&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>管道
因为每个scase中只有一个管道, 这决定了一个case只能处理一个管道
编译器在处理case语句时,如果case语句中没有管道操作(不能处理成scase对象),则会给出编译错误:&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>select case must be receive, send or assign recv
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>类型&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">const&lt;/span> (
&lt;span style="color:#a6e22e">caseNil&lt;/span> = &lt;span style="color:#66d9ef">iota&lt;/span>
&lt;span style="color:#a6e22e">caseRecv&lt;/span>
&lt;span style="color:#a6e22e">caseSend&lt;/span>
&lt;span style="color:#a6e22e">caseDefault&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>caseNil: 表示其操作的管道值为nil, 由于nil管道既不可读,也不可写,所以永远不会命中
所以在case语句中向值为nil的管道中写数据不会触发panic的原因&lt;/li>
&lt;li>caseRecv: 从管道中读数据&lt;/li>
&lt;li>caseSend: 向管道中写数据&lt;/li>
&lt;li>caseDeafult: 不会操作管道,每个select中仅可存在一个, 可出现在任意位置&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>数据
scase.elem表示数据存放的地址&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>caseRecv: 读出的数据存放的地址&lt;/li>
&lt;li>caseSend: 将写入管道的数据存放的地址&lt;/li>
&lt;/ul>
&lt;h2 id="实现逻辑">实现逻辑&lt;/h2>
&lt;p>&lt;code>selectgo()&lt;/code> 用于处理select语句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">selectgo&lt;/span>(&lt;span style="color:#a6e22e">cas0&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">scase&lt;/span>, &lt;span style="color:#a6e22e">order0&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">uint16&lt;/span>, &lt;span style="color:#a6e22e">ncases&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) (&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>selectgo()&lt;/code>函数会从一组case中挑选一个case,并返回命中case的下标,对于caseRecv的case,还会返回是否读取成功
当所有case都不可能就绪时,selectgo()陷入永久阻塞,此时函数不会返回&lt;/p>
&lt;h3 id="cas0">cas0&lt;/h3>
&lt;p>编译器会将select中的case语句存储在一个数组中,cas0保存这个数组的地址&lt;/p>
&lt;h3 id="ncases">ncases&lt;/h3>
&lt;p>ncases表示case的个数(包活default),即cas0数组的长度&lt;/p>
&lt;h3 id="order0">order0&lt;/h3>
&lt;p>order0 为一个整型数组的地址,其长度为case格式的2倍.
order0数组是&lt;strong>case执行随机性的关键&lt;/strong>&lt;/p>
&lt;p>order0数组被一分为二
前半部分存放case的随机顺序(pollorder),selectgo()会将原始的case顺序打乱,这样在检查每个case是否就绪时就会表现出随机性
后半部分存放管道加锁的顺序(lockorder),selectgo()会按照管道地址顺序对多个管道加锁,从而避免因重复加锁引发的死锁问题&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>selectgo()函数的实现包括以下要点:&lt;/p>
&lt;ul>
&lt;li>通过随机函数fastrandn()将原始的case顺序打乱,在遍历各个case时使用打乱后的顺序就会表现出随机性&lt;/li>
&lt;li>循环遍历各个case时,如果发现某个case就绪,则直接跳出循环操作管道并返回&lt;/li>
&lt;li>循环遍历各个case时,如果循环正常结束,说明所有case都没有就绪,有default直接跳default&lt;/li>
&lt;li>如果都没有就绪且没有default,selectgo()将阻塞等待所有管道,任一管道就绪后,都将开始新的循环&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;ul>
&lt;li>select仅能操作管道&lt;/li>
&lt;li>每个case仅能处理一个管道,要么读要么写&lt;/li>
&lt;li>多个case语句的执行顺序是随机的&lt;/li>
&lt;li>存在default,则select不会阻塞&lt;/li>
&lt;/ul></content></item><item><title>Go Generic</title><link>https://xujiajiadexiaokeai.github.io/2022-10-01/go-goroutine/</link><pubDate>Sat, 01 Oct 2022 15:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-10-01/go-goroutine/</guid><description>什么是泛型 类型系统 类型内存布局 类型检查 强类型、弱类型 静态检查、动态检查 静态检查: 编译阶段 动态检查: 运行时阶段 Go的类型检查发生在编译阶段
类型推导 编译器来做类型推导
非泛型突破类型的限制 手工复制 代码生成 genny
需要一些集成的手段去使用这些库，可能让代码构建变的更复杂。 增加了编译时间。 增加了二进制包的体积。 类型断言 通过将函数中的参数类型转换为根类型(interface{}),然后对根类型进行期望的类型断言
// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; ) func MaxNumber(s []interface{}) (interface{}, error) { // HL if len(s) == 0 { return nil, errors.New(&amp;#34;no values given&amp;#34;) } switch first := s[0].(type) { // HL case int: // HL max := first for _, rawV := range s[1:] { v := rawV.</description><content>&lt;h1 id="什么是泛型">什么是泛型&lt;/h1>
&lt;h1 id="类型系统">类型系统&lt;/h1>
&lt;h2 id="类型内存布局">类型内存布局&lt;/h2>
&lt;h2 id="类型检查">类型检查&lt;/h2>
&lt;ul>
&lt;li>强类型、弱类型&lt;/li>
&lt;li>静态检查、动态检查&lt;/li>
&lt;/ul>
&lt;p>静态检查: 编译阶段
动态检查: 运行时阶段
Go的类型检查发生在编译阶段&lt;/p>
&lt;ul>
&lt;li>类型推导&lt;/li>
&lt;/ul>
&lt;p>编译器来做类型推导&lt;/p>
&lt;h2 id="非泛型突破类型的限制">非泛型突破类型的限制&lt;/h2>
&lt;h3 id="手工复制">手工复制&lt;/h3>
&lt;h3 id="代码生成">代码生成&lt;/h3>
&lt;p>&lt;a href="https://github.com/cheekybits/genny">genny&lt;/a>&lt;/p>
&lt;ul>
&lt;li>需要一些集成的手段去使用这些库，可能让代码构建变的更复杂。&lt;/li>
&lt;li>增加了编译时间。&lt;/li>
&lt;li>增加了二进制包的体积。&lt;/li>
&lt;/ul>
&lt;h3 id="类型断言">类型断言&lt;/h3>
&lt;p>通过将函数中的参数类型转换为根类型(interface{}),然后对根类型进行期望的类型断言&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;errors&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#66d9ef">error&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">s&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;no values given&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>].(&lt;span style="color:#66d9ef">type&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>: &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">rawV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rawV&lt;/span>.(&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span>
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span>: &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">rawV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rawV&lt;/span>.(&lt;span style="color:#66d9ef">float64&lt;/span>) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span>
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#66d9ef">default&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unsupported element type of given slice: %T&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">first&lt;/span>)
}
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">err1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">m2&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4.1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8.1&lt;/span>, &lt;span style="color:#ae81ff">15.1&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err1&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span>) &lt;span style="color:#75715e">// &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">m2&lt;/span>) &lt;span style="color:#75715e">// 15 15.1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>调用方需要将参数包装或转换成根类型。&lt;/li>
&lt;li>实现方代码中耦合了大量的类型断言代码。&lt;/li>
&lt;li>失去了编译器的类型安全保障。&lt;/li>
&lt;/ul>
&lt;h3 id="反射">反射&lt;/h3>
&lt;p>用反射的技术在运行时获取类型信息,通过对类型的枚举判断来实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// source: https://github.com/danielfurman/presentations/blob/master/lets-go-generic/max.go
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;errors&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;reflect&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#66d9ef">error&lt;/span>) { &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">s&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;no values given&amp;#34;&lt;/span>)
}
&lt;span style="color:#a6e22e">first&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">CanInt&lt;/span>() {
&lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">Int&lt;/span>()
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ifV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">ifV&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">CanInt&lt;/span>() {
&lt;span style="color:#a6e22e">intV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Int&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">intV&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">intV&lt;/span>
}
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">CanFloat&lt;/span>() {
&lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>.&lt;span style="color:#a6e22e">Float&lt;/span>()
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ifV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:] {
&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">ifV&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">CanFloat&lt;/span>() {
&lt;span style="color:#a6e22e">intV&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Float&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">intV&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">max&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span> = &lt;span style="color:#a6e22e">intV&lt;/span>
}
}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unsupported element type of given slice: %T&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">err1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">m2&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">MaxNumber&lt;/span>([]&lt;span style="color:#66d9ef">interface&lt;/span>{}{&lt;span style="color:#ae81ff">4.1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8.1&lt;/span>, &lt;span style="color:#ae81ff">15.1&lt;/span>}) &lt;span style="color:#75715e">// HL
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err1&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span>) &lt;span style="color:#75715e">// &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">m1&lt;/span>, &lt;span style="color:#a6e22e">m2&lt;/span>) &lt;span style="color:#75715e">// 15 15.1
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>可读性可能不太好，因为用到了复杂的反射技术。&lt;/li>
&lt;li>会导致运行时性能差。运行时反射要比直接的代码多了很多指令操作，所以性能要慢很多。&lt;/li>
&lt;li>失去了编译器的类型安全保障。&lt;/li>
&lt;/ul>
&lt;h3 id="接口">接口&lt;/h3>
&lt;p>SOLID设计模式中的依赖倒置原则（Dependency Inversion Principle）要求软件接口在设计中应该依赖抽象而不是具体。&lt;/p>
&lt;ul>
&lt;li>可能需要定义很多数据类型。&lt;/li>
&lt;/ul>
&lt;h1 id="实现泛型">实现泛型&lt;/h1>
&lt;p>通常意义下的泛型也叫参数多态，指的是声明与定义函数、复合类型、变量时不指定其具体的类型，而把这部分类型作为参数使用，使得该定义对各种具体类型都适用。参数化多态使得语言更具表达力，同时保持了完全的静态类型安全。这被称为泛化函数、泛化数据类型、泛型变量，形成了泛型编程的基础。&lt;/p>
&lt;blockquote>
&lt;p>编程语言理论(PLT)中多态(Polymorphism)包含三个主要方面：特设多态(Ad-hoc)，参数多态(Parametric)和子类型(Subtyping)。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Ad-hoc：也叫重载(Overloading)，允许具有相同名称的函数对不同类型执行不同的操作。例如，+运算符即可以将两个整数相加，也可以连接两个字符串。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Subtyping：也叫包容性多态(Inclusion)，是指通过基类指针和引用使用派生类的能力。&lt;/p>
&lt;/blockquote>
&lt;p>子类型多态(Subtyping)是面向对象编程(OOP)中很重要的一个概念，它也称为运行时多态性，因为编译器在编译时不定位函数的地址，而是在运行时动态调用函数。这也称为动态派发(Dynamic Dispatch)。&lt;/p>
&lt;p>派发目的是让程序运行时知道被执行的函数或方法所在的内存位置。派发分为：&lt;/p>
&lt;p>静态派发(Static dispatch/early binding)：当程序在编译时可以找到执行的函数。C++默认使用的是直接派发，加上virtual修饰符可以改成虚函数表(Vtable)派发。直接派发是最快的，原因是调用指令少，还可通过编译器进行内联等方式的优化。这种派发缺点是不灵活，无法实现一些面向对象所需的技术如多态性。
动态派发(dynamic dispatch/run-time dispatch/virtual method call/late binding)：当程序在运行时可以找到执行的函数。Java默认使用的是虚函数表(Vtable)派发，通过final修饰符可改成直接派发。虚函数表派发是有动态性的，一个类里会用表来存储类成员函数的指针，子类重写(Override)父类的函数会替代父类的函数，子类添加的函数会被加到这个表里。当程序运行时派发时会从这个表中找到对应的函数，这样就可以实现动态派发。面向对象的编程语言正是靠此机制实现了多态性(Polymorphic)。
消息机制(message passing)：通过消息传递来调用被执行的函数。这种机制是在运行时可以改变函数的行为，甚至函数可以未实现，也不会引发运行时错误。比如Objective-C中就是通过消息传递来调用被执行的函数，甚至可以在程序运行过程中实现热更新代码。
以上三种派发方式都有其优劣：比如静态派发的速度是最快的，但并不灵活。而动态派发虽然比较慢，但却可以实现面向对象多态的功能。消息机制是最灵活的方式，但性能也最差。&lt;/p>
&lt;h2 id="类型擦除">类型擦除&lt;/h2>
&lt;h2 id="虚函数表">虚函数表&lt;/h2>
&lt;h2 id="字典">字典&lt;/h2>
&lt;h2 id="单态化">单态化&lt;/h2>
&lt;h2 id="模版">模版&lt;/h2>
&lt;h2 id="蜡印">蜡印&lt;/h2>
&lt;h1 id="总结">总结&lt;/h1></content></item><item><title>限流算法</title><link>https://xujiajiadexiaokeai.github.io/2022-08-20/current-limiting-algorithm/</link><pubDate>Sat, 20 Aug 2022 15:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-08-20/current-limiting-algorithm/</guid><description>固定窗口 滑动窗口 漏斗 令牌桶</description><content>&lt;h1 id="固定窗口">固定窗口&lt;/h1>
&lt;h1 id="滑动窗口">滑动窗口&lt;/h1>
&lt;h1 id="漏斗">漏斗&lt;/h1>
&lt;h1 id="令牌桶">令牌桶&lt;/h1></content></item><item><title>Goroutine</title><link>https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/</link><pubDate>Wed, 13 Jul 2022 10:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-13/go-goroutine/</guid><description>基本概念 进程 进程是应用程序的启动实例 有独立的内存空间 不同进程通过进程间通信的方式进行通信 线程 线程是cpu调度的基本单位 不同线程可以共享进程的资源 不同线程通过共享内存等线程间通信方式进行通信 协程 协程调度由用户程序提供,不直接受操作系统调度 协程调度器按照调度策略把协程调度到线程中执行 协程的优势 过多的线程会导致上下文切换的开销变大,而工作在用户态的协程则能大大减少上下文切换的开销
协程调度器把可运行的协程逐个调度到线程中执行,同时及时把阻塞的协程调度出线程
有效地避免了线程的频繁切换
实现了使用少量线程实现高并发的效果
多个协程分享操作系统分给线程的时间片
协程调度器决定了协程运行的顺序
线程运行调度器指派的协程,每一时刻只能运行一个协程
调度模型 线程模型 线程可分为用户线程和内核线程 用户线程由用户创建、同步合销毁
根据用户线程管理方式的不同,分为三种线程模型:
N:1模型 N个用户线程运行在1个内核线程中,上下文切换较快 1:1模型 每个用户线程对应一个内核线程,上下文切换较慢 M:N模型 充分利用cpu且上下文切换较快,但调度算法较为复杂 Go GPM模型 G: goroutine,Go协程,每个go关键字都会创建一个goroutine
P: processor,处理器(Go定义的一个概念,不是指cpu),包含运行Go代码的必要资源,也有调度goroutine的能力
M: machine,工作线程,由操作系统调度
M必须持有P才能运行代码 M会被系统调用阻塞
P的个数在程序启动时决定,默认等于CPU的核数,可以使用环境变量GOMAXPROCS或在程序中使用runtime.GOMAXPROCS()方法指定P的个数
export GOMAXPROC=80 runtime.GOMAXPROCS(80) M的个数通常稍大于P的个数,因为除了运行Go代码,还有其他内置任务需要处理.
调度策略 队列轮转 每个处理器P维护着一个协程G的队列, 处理器P依次将协程G调度到M中执行 P会周期性地查看全局队列中是否有G待运行,防止“饥饿” 全局队列中的G主要来自从系统调用中恢复的G
系统调用</description><content>&lt;h1 id="基本概念">基本概念&lt;/h1>
&lt;ol>
&lt;li>进程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>进程是应用程序的启动实例&lt;/li>
&lt;li>有独立的内存空间&lt;/li>
&lt;li>不同进程通过进程间通信的方式进行通信&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>线程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>线程是cpu调度的基本单位&lt;/li>
&lt;li>不同线程可以共享进程的资源&lt;/li>
&lt;li>不同线程通过共享内存等线程间通信方式进行通信&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>协程&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>协程调度由用户程序提供,不直接受操作系统调度&lt;/li>
&lt;li>协程调度器按照调度策略把协程调度到线程中执行&lt;/li>
&lt;/ul>
&lt;h1 id="协程的优势">协程的优势&lt;/h1>
&lt;p>过多的线程会导致上下文切换的开销变大,而工作在用户态的协程则能大大减少上下文切换的开销&lt;/p>
&lt;p>协程调度器把可运行的协程逐个调度到线程中执行,同时及时把阻塞的协程调度出线程&lt;/p>
&lt;p>有效地避免了线程的频繁切换&lt;/p>
&lt;p>实现了使用少量线程实现高并发的效果&lt;/p>
&lt;p>多个协程分享操作系统分给线程的时间片&lt;/p>
&lt;p>协程调度器决定了协程运行的顺序&lt;/p>
&lt;p>线程运行调度器指派的协程,每一时刻只能运行一个协程&lt;/p>
&lt;h1 id="调度模型">调度模型&lt;/h1>
&lt;ol>
&lt;li>线程模型
线程可分为用户线程和内核线程&lt;/li>
&lt;/ol>
&lt;p>用户线程由用户创建、同步合销毁&lt;/p>
&lt;p>根据用户线程管理方式的不同,分为三种线程模型:&lt;/p>
&lt;ul>
&lt;li>N:1模型
N个用户线程运行在1个内核线程中,上下文切换较快&lt;/li>
&lt;li>1:1模型
每个用户线程对应一个内核线程,上下文切换较慢&lt;/li>
&lt;li>M:N模型
充分利用cpu且上下文切换较快,但调度算法较为复杂&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>Go GPM模型&lt;/li>
&lt;/ol>
&lt;p>G: goroutine,Go协程,每个&lt;code>go&lt;/code>关键字都会创建一个goroutine&lt;/p>
&lt;p>P: processor,处理器(Go定义的一个概念,不是指cpu),包含运行Go代码的必要资源,也有调度goroutine的能力&lt;/p>
&lt;p>M: machine,工作线程,由操作系统调度&lt;/p>
&lt;p>M必须持有P才能运行代码
M会被系统调用阻塞&lt;/p>
&lt;p>P的个数在程序启动时决定,默认等于CPU的核数,可以使用环境变量GOMAXPROCS或在程序中使用runtime.GOMAXPROCS()方法指定P的个数&lt;/p>
&lt;pre tabindex="0">&lt;code>export GOMAXPROC=80
runtime.GOMAXPROCS(80)
&lt;/code>&lt;/pre>&lt;p>M的个数通常稍大于P的个数,因为除了运行Go代码,还有其他内置任务需要处理.&lt;/p>
&lt;h1 id="调度策略">调度策略&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>队列轮转
每个处理器P维护着一个协程G的队列, 处理器P依次将协程G调度到M中执行
P会周期性地查看全局队列中是否有G待运行,防止“饥饿”
全局队列中的G主要来自从系统调用中恢复的G&lt;/p>
&lt;/li>
&lt;li>
&lt;p>系统调用&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>P的个数默认等于CPU的核数, 每个M必须持有一个P才能执行G
一般情况下M的个数略大于P,多出来的M将会在G产生系统调用时发挥作用&lt;/p>
&lt;p>M池
当M运行的某个G产生系统调用时: // TODO&lt;/p>
&lt;ol start="3">
&lt;li>工作量窃取
通过&lt;code>go&lt;/code>关键字创建的协程通常会优先放到当前协程对应的多处理器队列中
可能有些协程自身会不断派生新协程,有些协程不会派生,导致多个P中维护的G队列是不均衡的&lt;/li>
&lt;/ol>
&lt;p>所以Go调度器提供了工作量窃取策略: 当某个P没有需要调度的协程时, 将从其他处理器中偷取协程&lt;/p>
&lt;p>发生窃取前,会查询全局队列,如果全局队列中没有需要调度的协程,才会从其他P中偷取,一次偷一半&lt;/p>
&lt;ol start="4">
&lt;li>抢占式调度
避免某个协程长时间执行,而阻碍其他协程被调度的机制&lt;/li>
&lt;/ol>
&lt;p>调度器会监控每个协程的执行时间, 一旦执行时间过程且有其他协程在等待时,会把当前协程暂停,转而调度等待的协程,类似&lt;code>时间片轮转&lt;/code>&lt;/p></content></item><item><title>Go Memory</title><link>https://xujiajiadexiaokeai.github.io/2022-07-13/go-memory/</link><pubDate>Wed, 13 Jul 2022 08:15:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-13/go-memory/</guid><description>内存分配 内存分配过程 针对待分配对象大小的不同有不同的分配逻辑:
(0, 16B)且不包含指针的对象: Tiny分配 (0, 16B)且包含指针的对象: 正常分配 [16B, 32KB] : 正常分配 (32KB, ∞): 大对象分配 以申请size为n的内存为例,分配步骤如下:
获取当前线程的私有缓存mcache 根据size计算出适合的class的ID 从mcache的alloc[class]链表中查询可用的span 如果macache没有可用的span, 则从mcentral申请一个新的span加入mcache 如果mcentral中也没有可用的span, 则从mheap中申请一个新的span加入mcentral 从该span中获取空闲对象地址并返回 小结 Go程序启动时申请一大块内存, 并划分成span、bitmap、arena区域 arena区域按页划分成一个个小块 span管理一个或多个页 mcentral管理多个span供线程申请使用 mcache作为线程私有资源, 资源来源于mcentral 垃圾回收 常见垃圾回收算法 引用计数 对每个对象维护一个引用计数, 当引用改对象的对象被销毁时,引用计数减1, 当引用计数器为0时回收改对象 优点: 对象可以很快被回收,不会出现内存耗尽或达到某个阈值时才回收 缺点: 不能很好地处理循环引用, 而且实时维护引用计数也有一定代价
标记-清除 从根变量开始遍历所有引用对象, 引用的对象标记为“被引用”, 没有标记的对象被回收 优点: 解决了引用计数的缺点 缺点: 需要”Stop The World“
分代收集 按照对象生命周期的长短划分不同的代空间, 生命周期长的放入老生代, 短的放入新生代, 不同代有不同的回收算法和回收频率 优点: 回收性能好 缺点: 算法复杂</description><content>&lt;h1 id="内存分配">内存分配&lt;/h1>
&lt;h2 id="内存分配过程">内存分配过程&lt;/h2>
&lt;p>针对待分配对象大小的不同有不同的分配逻辑:&lt;/p>
&lt;ul>
&lt;li>(0, 16B)且不包含指针的对象: Tiny分配&lt;/li>
&lt;li>(0, 16B)且包含指针的对象: 正常分配&lt;/li>
&lt;li>[16B, 32KB] : 正常分配&lt;/li>
&lt;li>(32KB, ∞): 大对象分配&lt;/li>
&lt;/ul>
&lt;p>以申请size为n的内存为例,分配步骤如下:&lt;/p>
&lt;ol>
&lt;li>获取当前线程的私有缓存mcache&lt;/li>
&lt;li>根据size计算出适合的class的ID&lt;/li>
&lt;li>从mcache的alloc[class]链表中查询可用的span&lt;/li>
&lt;li>如果macache没有可用的span, 则从mcentral申请一个新的span加入mcache&lt;/li>
&lt;li>如果mcentral中也没有可用的span, 则从mheap中申请一个新的span加入mcentral&lt;/li>
&lt;li>从该span中获取空闲对象地址并返回&lt;/li>
&lt;/ol>
&lt;h2 id="小结">小结&lt;/h2>
&lt;ul>
&lt;li>Go程序启动时申请一大块内存, 并划分成span、bitmap、arena区域&lt;/li>
&lt;li>arena区域按页划分成一个个小块&lt;/li>
&lt;li>span管理一个或多个页&lt;/li>
&lt;li>mcentral管理多个span供线程申请使用&lt;/li>
&lt;li>mcache作为线程私有资源, 资源来源于mcentral&lt;/li>
&lt;/ul>
&lt;h1 id="垃圾回收">垃圾回收&lt;/h1>
&lt;h2 id="常见垃圾回收算法">常见垃圾回收算法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>引用计数
对每个对象维护一个引用计数, 当引用改对象的对象被销毁时,引用计数减1, 当引用计数器为0时回收改对象
优点: 对象可以很快被回收,不会出现内存耗尽或达到某个阈值时才回收
缺点: 不能很好地处理循环引用, 而且实时维护引用计数也有一定代价&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标记-清除
从根变量开始遍历所有引用对象, 引用的对象标记为“被引用”, 没有标记的对象被回收
优点: 解决了引用计数的缺点
缺点: 需要”Stop The World“&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分代收集
按照对象生命周期的长短划分不同的代空间, 生命周期长的放入老生代, 短的放入新生代, 不同代有不同的回收算法和回收频率
优点: 回收性能好
缺点: 算法复杂&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="go垃圾回收">Go垃圾回收&lt;/h2>
&lt;h3 id="标记-清除算法原理">“标记-清除”算法原理&lt;/h3>
&lt;h3 id="内存标记">内存标记&lt;/h3>
&lt;p>在&lt;code>mspan&lt;/code>的数据结构中, bitmap&lt;code>allocBits&lt;/code>表示每个内存块的使用情况, bitmap&lt;code>gcmarkBits&lt;/code>用于标记内存块被引用的情况
在标记阶段对每块内存进行标记, 有对象引用的内存标记为1,没有引用的保持为0(default)
&lt;code>allocBits&lt;/code>和&lt;code>gcmarkBits&lt;/code>的数据结构完全一样, 标记结束后进行内存回收, 回收时将allocBits指向gcmarkBits, 代表标记过的内存才是存活的, gcmarkBits会在下次标记时重新分配内存&lt;/p>
&lt;h3 id="三色标记法">三色标记法&lt;/h3>
&lt;p>三色主要是为了对应gc过程中对象的三种状态:&lt;/p>
&lt;ul>
&lt;li>灰色: 对象还在标记队列中等待&lt;/li>
&lt;li>黑色: 对象已被标记, gcmarkBits对应的位为1(本次不会被清理)&lt;/li>
&lt;li>白色: 对象未被标记, gcmarkBits对应的位为0(本次会被清理)&lt;/li>
&lt;/ul>
&lt;h3 id="stop-the-world">Stop The World&lt;/h3>
&lt;p>在gc过程中, 需要控制内存的变化, 否则在回收过程中指针传递会引起内存引用关系变化
STW时间的长短直接影响了应用的执行&lt;/p>
&lt;h2 id="垃圾回收优化">垃圾回收优化&lt;/h2>
&lt;h3 id="写屏障write-barrier">写屏障(Write Barrier)&lt;/h3>
&lt;p>STW的目的是防止GC扫描时内存变化而停止goroutine, 而写屏障就是让goroutine与GC同时运行的手段.
虽然写屏障不能完全消除STW,但是可以大大缩短STW的时间&lt;/p>
&lt;h3 id="辅助gcmutator-assist">辅助GC(Mutator Assist)&lt;/h3>
&lt;p>在GC过程中, 如果goroutine需要分配内存, 那么改goroutine会参与以部分GC的工作&lt;/p>
&lt;h2 id="gc的触发时机">GC的触发时机&lt;/h2>
&lt;ol>
&lt;li>内存分配量达到阈值触发GC&lt;/li>
&lt;li>定期触发GC&lt;/li>
&lt;li>手动触发&lt;/li>
&lt;/ol>
&lt;h2 id="gc性能优化">GC性能优化&lt;/h2>
&lt;p>GC性能与对象数量负相关&lt;/p>
&lt;ul>
&lt;li>减少对象分配: 对象复用或使用大对象组合多个小对象&lt;/li>
&lt;li>内存逃逸也会加重GC负担&lt;/li>
&lt;/ul>
&lt;h1 id="逃逸分析">逃逸分析&lt;/h1>
&lt;p>逃逸分析(escape analysis)是指编译器决定内存分配的位置, 不需要程序员指定
在函数中申请一个新的对象:&lt;/p>
&lt;ul>
&lt;li>如果分配在栈中, 则函数执行结束后可自动将内存回收&lt;/li>
&lt;li>如果分配在堆中, 则函数执行结束后可交给GC处理&lt;/li>
&lt;/ul>
&lt;h2 id="逃逸策略">逃逸策略&lt;/h2>
&lt;p>在函数中申请一个闲的对象, 编译器会根据该对象是否被函数外部引用来决定是否逃逸:&lt;/p>
&lt;ul>
&lt;li>如果函数外部没有引用, 则优先放入栈中&lt;/li>
&lt;li>如果函数外部存在引用, 则优先放入堆中&lt;/li>
&lt;li>对于仅在函数内部使用的对象, 也有可能放到堆中, 比如内存过大超过栈的大小&lt;/li>
&lt;/ul>
&lt;h2 id="逃逸场景">逃逸场景&lt;/h2>
&lt;ol>
&lt;li>指针逃逸
Go返回了局部变量的指针&lt;/li>
&lt;li>栈空间不足
当栈空间不足以存放当前对象或无法判断当前切片长度时会将对象分配到堆中&lt;/li>
&lt;li>动态类型逃逸
如果函数中使用了动态类型参数, 编译期间很难确定参数类型, 也会产生逃逸&lt;/li>
&lt;li>闭包引用对象逃逸
闭包中的局部对象由于闭包的引用, 产生逃逸&lt;/li>
&lt;/ol>
&lt;h2 id="小结-1">小结&lt;/h2>
&lt;ul>
&lt;li>栈上分配内存比在堆中分配内存有更高的效率&lt;/li>
&lt;li>逃逸分析的目的是决定分配到栈还是堆&lt;/li>
&lt;li>逃逸分析在编译阶段完成&lt;/li>
&lt;/ul></content></item><item><title>Go Channel</title><link>https://xujiajiadexiaokeai.github.io/2022-07-12/go-channel/</link><pubDate>Tue, 12 Jul 2022 21:12:06 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-12/go-channel/</guid><description>读写nil管道均会阻塞 关闭的管道仍然可以读取数据 向关闭的管道写数据会触发panic
只有一个缓冲区的管道,写入数据 —&amp;gt; 加锁; 读出数据 -&amp;gt; 解锁
特性 初始化 变量声明 var ch chan int declare chan, value == nil make() ch1 := make(chan string) no-buffered chan ch2 := make(chan string, 5) buffered chan 管道操作 操作符: &amp;lt;- -&amp;gt; 默认为双向可读写,在函数传递间可使用操作符限制读写 func ChanParamR(ch &amp;lt;-chan int) { only can read from chan } func ChanParamW(ch chan&amp;lt;- int) { only can write to chan } 数据读写 协程读取管道时,阻塞的条件有: chan no-buffer chan buffer no data chan value == nil 协程写入管道时,阻塞的条件有: chan no-buffer chan buffer is full chan value == nil 实现原理 数据结构 https://cs.</description><content>&lt;p>读写nil管道均会阻塞
关闭的管道仍然可以读取数据
向关闭的管道写数据会触发panic&lt;/p>
&lt;p>只有一个缓冲区的管道,写入数据 —&amp;gt; 加锁; 读出数据 -&amp;gt; 解锁&lt;/p>
&lt;h1 id="特性">特性&lt;/h1>
&lt;h2 id="初始化">初始化&lt;/h2>
&lt;ul>
&lt;li>变量声明&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">declare&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>make()&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">ch1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#a6e22e">no&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">buffered&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
&lt;span style="color:#a6e22e">ch2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#a6e22e">buffered&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="管道操作">管道操作&lt;/h2>
&lt;ul>
&lt;li>操作符: &amp;lt;- -&amp;gt;
默认为双向可读写,在函数传递间可使用操作符限制读写&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">ChanParamR&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;span style="color:#a6e22e">only&lt;/span> &lt;span style="color:#a6e22e">can&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">ChanParamW&lt;/span>(&lt;span style="color:#a6e22e">ch&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>&lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;span style="color:#a6e22e">only&lt;/span> &lt;span style="color:#a6e22e">can&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span> &lt;span style="color:#a6e22e">to&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>数据读写
协程读取管道时,阻塞的条件有:&lt;/li>
&lt;li>chan no-buffer&lt;/li>
&lt;li>chan buffer no data&lt;/li>
&lt;li>chan value == nil
协程写入管道时,阻塞的条件有:&lt;/li>
&lt;li>chan no-buffer&lt;/li>
&lt;li>chan buffer is full&lt;/li>
&lt;li>chan value == nil&lt;/li>
&lt;/ul>
&lt;h1 id="实现原理">实现原理&lt;/h1>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/runtime/chan.go">https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/runtime/chan.go&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">hchan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">qcount&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// total data in the queue
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">dataqsiz&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// size of the circular queue
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">buf&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span> &lt;span style="color:#75715e">// points to an array of dataqsiz elements
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">elemsize&lt;/span> &lt;span style="color:#66d9ef">uint16&lt;/span>
&lt;span style="color:#a6e22e">closed&lt;/span> &lt;span style="color:#66d9ef">uint32&lt;/span>
&lt;span style="color:#a6e22e">elemtype&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#75715e">// element type
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">sendx&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// send index
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">recvx&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> &lt;span style="color:#75715e">// receive index
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">recvq&lt;/span> &lt;span style="color:#a6e22e">waitq&lt;/span> &lt;span style="color:#75715e">// list of recv waiters
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">sendq&lt;/span> &lt;span style="color:#a6e22e">waitq&lt;/span> &lt;span style="color:#75715e">// list of send waiters
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// lock protects all fields in hchan, as well as several
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// fields in sudogs blocked on this channel.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Do not change another G&amp;#39;s status while holding this lock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// (in particular, do not ready a G), as this can deadlock
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// with stack shrinking.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">lock&lt;/span> &lt;span style="color:#a6e22e">mutex&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>环形队列
chan内部实现了一个环形队列,队列长度在chan创建时指定
sendx: 队尾, 写入位
recvx: 队首, 读取位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等待队列&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>goroutine从chan读 -&amp;gt; buf为空或没有buf -&amp;gt; 当前goroutine阻塞 -&amp;gt; 加入recvq&lt;/li>
&lt;li>goroutine向chan写 -&amp;gt; buf已满或没有buf -&amp;gt; 当前goroutine阻塞 -&amp;gt; 加入sendq
处于等待队列中的协程会在其他协程操作管道时被唤醒:&lt;/li>
&lt;li>因读阻塞的协程会被向管道写入的协程唤醒&lt;/li>
&lt;li>因写阻塞的协程会被从管道读取的协程唤醒&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>Invariants:
At least one of c.sendq and c.recvq is empty,
except for the case of an unbuffered channel with a single goroutine
blocked on it for both sending and receiving using a select statement,
in which case the length of c.sendq and c.recvq is limited only by the
size of the select statement.
For buffered channels, also:
c.qcount &amp;gt; 0 implies that c.recvq is empty.
c.qcount &amp;lt; c.dataqsiz implies that c.sendq is empty.
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>类型信息&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>一个管道只能传递一种类型的值&lt;/li>
&lt;li>如果需要管道传递任意类型的数据,可以使用interface{}类型&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>互斥锁
一个管道同时仅允许被一个协程读写&lt;/li>
&lt;/ol>
&lt;h2 id="管道操作-1">管道操作&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>创建管道
创建管道 -&amp;gt; 初始化hchan结构&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写入管道
trick:
当接收队列recvq不为空时,说明缓冲区中没有数据但有协程在等待数据
会把数据直接传递给recvq队列中的第一个协程,而不必再写入缓冲区&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读出管道
trick:
当等待发送队列sendq不为空,且没有缓冲区,
那么此时将直接从sendq队列的第一个协程中获取数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关闭管道
关闭管道时会把recvq中的协程全部唤醒, 协程会获取对应类型的零值
同时会把sendq队列中的协程全部唤醒,协程会触发panic&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>会触发panic的操作还有:&lt;/p>
&lt;ul>
&lt;li>关闭值为nil的管道&lt;/li>
&lt;li>关闭已经被关闭的管道&lt;/li>
&lt;li>向已经关闭的管道写入数据&lt;/li>
&lt;/ul>
&lt;h2 id="常见用法">常见用法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>单向管道&lt;/p>
&lt;/li>
&lt;li>
&lt;p>select
使用select可以监控多个管道
select的case语句读管道时不会阻塞&lt;/p>
&lt;/li>
&lt;li>
&lt;p>for-range
for-range可以持续从管道中读出数据,当管道中没有数据时会阻塞当前协程&lt;/p>
&lt;/li>
&lt;/ul></content></item></channel></rss>