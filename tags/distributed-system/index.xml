<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Distributed System on xujiajiadexiaokeai</title><link>https://xujiajiadexiaokeai.github.io/tags/distributed-system/</link><description>Recent content in Distributed System on xujiajiadexiaokeai</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2021-2023 xujiajiadexiaokeai</copyright><lastBuildDate>Fri, 01 Jul 2022 10:16:17 +0800</lastBuildDate><atom:link href="https://xujiajiadexiaokeai.github.io/tags/distributed-system/index.xml" rel="self" type="application/rss+xml"/><item><title>Bloom Filter VS Ribbon Filter</title><link>https://xujiajiadexiaokeai.github.io/2022-07-01/bloomfilter-vs-ribbonfilter/</link><pubDate>Fri, 01 Jul 2022 10:16:17 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2022-07-01/bloomfilter-vs-ribbonfilter/</guid><description>https://developer.aliyun.com/article/980796
由于Bloom Filter只需要占用极小的空间，便可以给出”可能存在“和”肯定不存在“的存在性判断，因此可以提前过滤掉许多不必要的数据块，从而节省了大量的磁盘IO</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://developer.aliyun.com/article/980796">https://developer.aliyun.com/article/980796&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>由于Bloom Filter只需要占用极小的空间，便可以给出”可能存在“和”肯定不存在“的存在性判断，因此可以提前过滤掉许多不必要的数据块，从而节省了大量的磁盘IO&lt;/p></content></item><item><title>[译]Progress in etcd</title><link>https://xujiajiadexiaokeai.github.io/2021-10-28/progress-in-etcd/</link><pubDate>Thu, 28 Oct 2021 15:00:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-10-28/progress-in-etcd/</guid><description>From etcd Raft Design Doc
Progress是etcd中leader保存的所有follower的progress的视图
Leader维护着所有follower的progress，并根据follower的progress向follower发送 replication message
replication message 是带着log entries信息的msgAppend 消息
progress有两个属性： match 和 next
match 是leader对该follower已确定日志(entry)中最高的index，如果leader对这个follower的日志复制情况(replication status)一无所知，match 则会被设置为0
next 是leader将要发送给该follower的第一条日志(entry)的index,leader会将从next 开始到最新的entries放到下一条replication message 中
一个follower的progress会处于以下三种状态： probe , replicate ,snapshot
+--------------------------------------------------------+ | send snapshot | | | +---------+----------+ +----------v---------+ +---&amp;gt; probe | | snapshot | | | max inflight = 1 &amp;lt;----------------------------------+ max inflight = 0 | | +---------+----------+ +--------------------+ | | 1. snapshot success | | (next=snapshot.</description><content>&lt;blockquote>
&lt;p>From etcd Raft Design Doc&lt;/p>
&lt;/blockquote>
&lt;p>Progress是etcd中leader保存的所有follower的progress的视图&lt;/p>
&lt;p>Leader维护着所有follower的progress，并根据follower的progress向follower发送 &lt;code>replication message&lt;/code>&lt;/p>
&lt;p>&lt;code>replication message&lt;/code> 是带着log entries信息的&lt;code>msgAppend&lt;/code> 消息&lt;/p>
&lt;p>progress有两个属性： &lt;code>match&lt;/code> 和 &lt;code>next&lt;/code>&lt;/p>
&lt;p>&lt;code>match&lt;/code> 是leader对该follower已确定日志(entry)中最高的index，如果leader对这个follower的日志复制情况(replication status)一无所知，&lt;code>match&lt;/code> 则会被设置为0&lt;/p>
&lt;p>&lt;code>next&lt;/code> 是leader将要发送给该follower的第一条日志(entry)的index,leader会将从&lt;code>next&lt;/code> 开始到最新的entries放到下一条&lt;code>replication message&lt;/code> 中&lt;/p>
&lt;p>一个follower的progress会处于以下三种状态： &lt;code>probe&lt;/code> , &lt;code>replicate&lt;/code> ,&lt;code>snapshot&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text"> +--------------------------------------------------------+
| send snapshot |
| |
+---------+----------+ +----------v---------+
+---&amp;gt; probe | | snapshot |
| | max inflight = 1 &amp;lt;----------------------------------+ max inflight = 0 |
| +---------+----------+ +--------------------+
| | 1. snapshot success
| | (next=snapshot.index + 1)
| | 2. snapshot failure
| | (no change)
| | 3. receives msgAppResp(rej=false&amp;amp;&amp;amp;index&amp;gt;lastsnap.index)
| | (match=m.index,next=match+1)
receives msgAppResp(rej=true)
(next=match+1)| |
| |
| |
| | receives msgAppResp(rej=false&amp;amp;&amp;amp;index&amp;gt;match)
| | (match=m.index,next=match+1)
| |
| |
| |
| +---------v----------+
| | replicate |
+---+ max inflight = n |
+--------------------+
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>probe&lt;/code> ：当follower处于待调查(probe)状态时，leader在一次心跳间隔(heartbeat interval)内最多向该follower发送一条&lt;code>replication message&lt;/code> 。leader慢慢向follower发送&lt;code>replication message&lt;/code> 并试探follower的实际复制进展(actual progress)。leader在收到&lt;code>msgHeartbeatResp&lt;/code> 或者&lt;code>msgAppResp&lt;/code> 的拒绝消息后会触发下一条&lt;code>replication message&lt;/code> 的发送。&lt;/p>
&lt;p>&lt;code>replicate&lt;/code> ：当follower处于复制(replicate)状态时，leader在向该follower发送&lt;code>replication message&lt;/code> 时，会乐观地(optimistically)将&lt;code>next&lt;/code> 增加至最新的index。这是一个最优的状态(optimized state)，可以快速的将日志(log entries)复制给follower。&lt;/p>
&lt;p>&lt;code>snapshot&lt;/code> ：当follower处于快照(snapshot)状态时，leader会停止向该follower发送&lt;code>replication message&lt;/code>&lt;/p>
&lt;h1 id="状态流转">状态流转&lt;/h1>
&lt;p>一个新选出的leader，会将所有follower的state设置为&lt;code>probe&lt;/code> 状态，&lt;code>match&lt;/code> 设置为0，&lt;code>next&lt;/code> 设置为自己最新的index。之后leader会缓慢的向各个follower发送&lt;code>replication message&lt;/code> (一次心跳最多一条)去试探他们的日志复制进展。&lt;/p>
&lt;p>在收到follower&lt;code>reject&lt;/code> 为&lt;code>false&lt;/code> 的&lt;code>msgAppResp&lt;/code> 时，会将该follower的progress设置为&lt;code>replicate&lt;/code> 状态，这表明发送的index已经和follower目前的index匹配上了，可以进行后续日志快速的发送。当follower回复一条reject的&lt;code>msgAppResp&lt;/code> 或者连接层(link layer) 报告follower不可连接时，该follower的progress会回到&lt;code>probe&lt;/code> 状态。我们积极地将&lt;code>next&lt;/code> 重置为&lt;code>match&lt;/code> +1，因为如果我们很快收到任何&lt;code>msgAppResp&lt;/code> ，&lt;code>match&lt;/code> 和&lt;code>next&lt;/code> 将直接增加到&lt;code>msgAppResp&lt;/code> 中的index。（如果将&lt;code>next&lt;/code> 设置过低，我们可能会发送一些重复条目。请参阅开放性问题）&lt;/p>
&lt;p>当follower远远落后并且需要快照(snapshot)时，该follower将从&lt;code>probe&lt;/code> 状态更改为&lt;code>snapshot&lt;/code> 状态。发送&lt;code>msgSnap&lt;/code> 后，leader将等待上一个快照发送成功、失败或中止。应用发送结果后，该follower的progress将返回到&lt;code>probe&lt;/code> 状态。&lt;/p>
&lt;h1 id="流转控制">流转控制&lt;/h1>
&lt;p>限制每条message发送的message最大大小。最大值应该是可配置的。降低探测状态的成本，因为我们限制每条消息的大小；如果下一步的罚分过低，则降低罚分&lt;/p>
&lt;p>当处于复制状态时，限制飞行中消息的数量 &amp;lt; N N应该是可配置的。大多数实现将在其实际网络传输层（不阻塞raft节点）的顶部有一个发送缓冲区。我们希望确保raft不会使缓冲区溢出，这可能会导致消息丢失并触发大量不必要的重复重发。&lt;/p></content></item><item><title>Dynamo</title><link>https://xujiajiadexiaokeai.github.io/2021-10-26/dynamo/</link><pubDate>Tue, 26 Oct 2021 13:52:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-10-26/dynamo/</guid><description>Dynamo is a peer-to-peer system can quickly find the key by DHT(distributed hash table)
为了保证能最快速的定位到key，所以在每个node中都保存了整个集群的信息，在客户端也保存了集群信息，可以将请求直接打到目标node
zero-hop (零跳)
一致性哈希的优点： node join or exit，only effect the adjacent nodes in the same hash ring
接着考虑到每个node的Heterogeneous(异构性)、处理能力不同，于是加入了virtual nodes（虚拟结点）的概念
尽量做到每个虚拟节点的处理能力一致
起初一致性哈希是为了解决新加入节点和退出节点对数据的影响最小，但是由于数据分布的不均匀，热点数据，节点能力的异构都会造成分布不均匀，于是加入的virtual nodes，但是为了同一份数据的replicas分布在不同的物理机器上，配置virtual也会造成一定的困难。
一致性和复制 replicate： the node that performs data replication is called coordinator
负责存储key的node被称为preference list
coordinator coordinator进行复制的时候，是异步进行的，（可尽快给用户返回），所以Dynamo是一个弱一致系统
NRW: 可自定义R和W的数量，但要满足 R + W &amp;gt; N
W(W&amp;lt;=N): 一个写操作只有成功更新了W个副本，才会被任务操作成功
R(R&amp;lt;=N): 一个读操作需要读的副本数量
R + W &amp;gt; N 能够保证读操作和写操作有节点交集：至少有一个节点会被读操作和写操作同时操作到
通过调整R和W能实现available和consistency之间的转换
W小R大 writes never fail -&amp;gt; high availability</description><content>&lt;p>Dynamo is a peer-to-peer system can quickly find the key by DHT(distributed hash table)&lt;/p>
&lt;p>为了保证能最快速的定位到key，所以在每个node中都保存了整个集群的信息，在客户端也保存了集群信息，可以将请求直接打到目标node&lt;/p>
&lt;p>zero-hop (零跳)&lt;/p>
&lt;h1 id="一致性哈希的优点">一致性哈希的优点：&lt;/h1>
&lt;p>node join or exit，only effect the adjacent nodes in the same hash ring&lt;/p>
&lt;p>接着考虑到每个node的Heterogeneous(异构性)、处理能力不同，于是加入了virtual nodes（虚拟结点）的概念&lt;/p>
&lt;p>尽量做到每个虚拟节点的处理能力一致&lt;/p>
&lt;p>起初一致性哈希是为了解决新加入节点和退出节点对数据的影响最小，但是由于数据分布的不均匀，热点数据，节点能力的异构都会造成分布不均匀，于是加入的virtual nodes，但是为了同一份数据的replicas分布在不同的物理机器上，配置virtual也会造成一定的困难。&lt;/p>
&lt;h1 id="一致性和复制">一致性和复制&lt;/h1>
&lt;h2 id="replicate">replicate：&lt;/h2>
&lt;p>the node that performs data replication is called coordinator&lt;/p>
&lt;p>负责存储key的node被称为preference list&lt;/p>
&lt;h2 id="coordinator">coordinator&lt;/h2>
&lt;p>coordinator进行复制的时候，是异步进行的，（可尽快给用户返回），所以Dynamo是一个弱一致系统&lt;/p>
&lt;h2 id="nrw">NRW:&lt;/h2>
&lt;p>可自定义R和W的数量，但要满足 R + W &amp;gt; N&lt;/p>
&lt;h3 id="wwn">W(W&amp;lt;=N):&lt;/h3>
&lt;p>一个写操作只有成功更新了W个副本，才会被任务操作成功&lt;/p>
&lt;h3 id="rrn">R(R&amp;lt;=N):&lt;/h3>
&lt;p>一个读操作需要读的副本数量&lt;/p>
&lt;h3 id="r--w--n">R + W &amp;gt; N&lt;/h3>
&lt;p>能够保证读操作和写操作有节点交集：至少有一个节点会被读操作和写操作同时操作到&lt;/p>
&lt;p>通过调整R和W能实现available和consistency之间的转换&lt;/p>
&lt;h3 id="w小r大">W小R大&lt;/h3>
&lt;p>writes never fail -&amp;gt; high availability&lt;/p>
&lt;h3 id="r小w大">R小W大&lt;/h3>
&lt;p>block for all replicas to be readable -&amp;gt; strong consistency&lt;/p>
&lt;p>每个node都记录自己的操作记录，通过向量时钟能够记录同一对象不同版本间的因果关系&lt;/p>
&lt;p>当节点接收到更新 -&amp;gt; 逐相对比本地向量钟和待更新数据的向量钟&lt;/p>
&lt;p>如果待更新向量钟的每一项都不小于本地向量钟，那么数据无冲突，新的值可以接受。&lt;/p>
&lt;p>Dynamo并不会贸然假定数据的冲突合并准则，而是保留全部的冲突数据，等待客户端处理。&lt;/p>
&lt;h1 id="容错">容错&lt;/h1>
&lt;p>Dynamo将异常分为两种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>临时性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>永久性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="临时性故障">临时性故障：&lt;/h2>
&lt;p>针对临时性故障，其处理策略就是仲裁(quorum)，但是如果严格执行仲裁策略，会影响Dynamo的可用性，因为需要等到N个节点都执行了，才能返回，此时如果其中一个结点故障了，会影响可用性。&lt;/p>
&lt;p>于是Dynamo采用了Sloppy Quorum策略，只需要N个healthy node即可&lt;/p>
&lt;p>Sloppy Quorum：&lt;/p>
&lt;p>如果某台机器故障了，则顺延将数据写入到后面的健康机器，并标注数据为hinted handoff，当机器恢复后，将数据进行回传&lt;/p>
&lt;h2 id="永久性故障">永久性故障：&lt;/h2>
&lt;p>针对永久性故障，其处理策略是Merkle Hash Tree.&lt;/p>
&lt;h3 id="merkle-hash-tree">Merkle Hash Tree:&lt;/h3>
&lt;p>非叶子结点对应多个文件，值是其所有子节点值结合以后的哈希值；&lt;/p>
&lt;p>叶子节点对应单个数据文件，值是文件内容的哈希&lt;/p>
&lt;p>通过对比Merkle树，就能找出不同的文件了&lt;/p>
&lt;h1 id="成员资格及错误检测">成员资格及错误检测&lt;/h1>
&lt;p>所有的node中都保存了集群中所有node的路由信息，这导致了有新节点加入或者节点退出的时候，需要将这消息传递给集群内的所有人，使用了gossip协议&lt;/p>
&lt;h1 id="总体特点">总体特点&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>最终一致性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>即使故障也保障可写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许写冲突，由上层应用自行解决&lt;/p>
&lt;/li>
&lt;/ul></content></item><item><title>Quorum in etcd</title><link>https://xujiajiadexiaokeai.github.io/2021-10-12/quorum-in-etcd/</link><pubDate>Tue, 12 Oct 2021 22:44:30 +0800</pubDate><guid>https://xujiajiadexiaokeai.github.io/2021-10-12/quorum-in-etcd/</guid><description>CAP 一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)
WARO (Write All Read One)一种简单的副本控制协议。当Client请求向某副本写数据时,只有当所有的副本都更新成功后,才算写成功,否则都视为失败。
WARO牺牲了更新服务的可用性,最大程度增强了读服务的可用性
Quorum 一种权衡机制, 一种将“读写转化”的模型
quorum是“抽屉原理”的一个应用。定义:假设有N个副本,更新操作wi在W个副本中更新成功后,才认为此次更新操作wi成功。称成功提交的更新操作对应的数据为“成功提交的数据”。对于读操作而言,至少需要读R个副本才能读到此次更新的数据。其中,W+R&amp;gt;N,即W和R有重叠。一般W+R=N+1
Quorum机制分析 Quorum机制无法保证强一致性
如何读取最新的数据:在已经知道最近成功提交的数据版本号的前提下,最多读R个副本就可以了
如何确定 最高版本号 的数据是一个成功提交的数据: 继续读其他副本,直到读到了 W 次
基于Quorum机制选primary
中心节点读取R个副本,选择R个副本中版本号最高的副本作为新的Primary。
新选出的primary不能立即提供服务,还需要与至少W个副本完成同步后,才能提供服务 &amp;mdash;&amp;ndash;&amp;gt; 为了保证Quorum的规则: W+R &amp;gt; N
如何处理冲突？ (V2,V2,V1,V1,V1) R = 3
如果读取的是(V1,V1,V1),则V2需要丢弃
如果是(V2,V1,V1),则V1需要同步到V2
Quorum 在etcd中的应用 Quorum在etcd中主要作用有两个,一个是计算已被多数节点接收(Match)的Index,二是在进行Leader选举时,计算选举结果。
raft/quorum/quorum.go</description><content>&lt;h1 id="cap">CAP&lt;/h1>
&lt;p>一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)&lt;/p>
&lt;h1 id="waro">WARO&lt;/h1>
&lt;p>(Write All Read One)一种简单的副本控制协议。当Client请求向某副本写数据时,只有当所有的副本都更新成功后,才算写成功,否则都视为失败。&lt;/p>
&lt;p>WARO牺牲了更新服务的可用性,最大程度增强了读服务的可用性&lt;/p>
&lt;h1 id="quorum">Quorum&lt;/h1>
&lt;p>一种权衡机制, 一种将“读写转化”的模型&lt;/p>
&lt;p>quorum是“抽屉原理”的一个应用。定义:假设有N个副本,更新操作wi在W个副本中更新成功后,才认为此次更新操作wi成功。称成功提交的更新操作对应的数据为“成功提交的数据”。对于读操作而言,至少需要读R个副本才能读到此次更新的数据。其中,W+R&amp;gt;N,即W和R有重叠。一般W+R=N+1&lt;/p>
&lt;h2 id="quorum机制分析">Quorum机制分析&lt;/h2>
&lt;p>&lt;strong>Quorum机制无法保证强一致性&lt;/strong>&lt;/p>
&lt;p>如何读取最新的数据:在已经知道最近成功提交的数据版本号的前提下,最多读R个副本就可以了&lt;/p>
&lt;p>如何确定 最高版本号 的数据是一个成功提交的数据: 继续读其他副本,直到读到了 W 次&lt;/p>
&lt;p>基于Quorum机制选primary&lt;/p>
&lt;p>中心节点读取R个副本,选择R个副本中版本号最高的副本作为新的Primary。&lt;/p>
&lt;p>新选出的primary不能立即提供服务,还需要与至少W个副本完成同步后,才能提供服务 &amp;mdash;&amp;ndash;&amp;gt; 为了保证Quorum的规则: W+R &amp;gt; N&lt;/p>
&lt;h3 id="如何处理冲突">如何处理冲突？&lt;/h3>
&lt;p>(V2,V2,V1,V1,V1) R = 3&lt;/p>
&lt;p>如果读取的是(V1,V1,V1),则V2需要丢弃&lt;/p>
&lt;p>如果是(V2,V1,V1),则V1需要同步到V2&lt;/p>
&lt;h2 id="quorum-在etcd中的应用">Quorum 在etcd中的应用&lt;/h2>
&lt;p>Quorum在etcd中主要作用有两个,一个是计算已被多数节点接收(Match)的Index,二是在进行Leader选举时,计算选举结果。&lt;/p>
&lt;p>raft/quorum/quorum.go&lt;/p></content></item></channel></rss>